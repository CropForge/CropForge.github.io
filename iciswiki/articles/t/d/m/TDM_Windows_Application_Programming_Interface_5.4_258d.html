<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.14.0" />
		<meta name="keywords" content="TDM Windows Application Programming Interface 5.4,GMS standardName,GMS applyChanges" />
		<link rel="shortcut icon" href="../../../../misc/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="../../../../../opensearch_desc.php" title="ICISWiki (en)" />
		<link title="Creative Commons" type="application/rdf+xml" href="../../../../articles/t/d/m/TDM_Windows_Application_Programming_Interface_5.4_258d.html" rel="alternate meta" />
		<link rel="copyright" href="../../../../../COPYING.html" />
		<link rel="alternate" type="application/rss+xml" title="ICISWiki RSS Feed" href="http://localhost../../../../articles/r/e/c/Special%7ERecentChanges_e0d0.html" />
		<link rel="alternate" type="application/atom+xml" title="ICISWiki Atom Feed" href="http://localhost../../../../articles/r/e/c/Special%7ERecentChanges_e0d0.html" />
		<title>TDM Windows Application Programming Interface 5.4 - ICISWiki</title>
		<link rel="stylesheet" href="../../../../skins/common/shared.css?195" type="text/css" media="screen" />
		<link rel="stylesheet" href="../../../../skins/common/commonPrint.css?195" type="text/css" media="print" />
		<link rel="stylesheet" href="../../../../skins/monobook/main.css?195" type="text/css" media="screen" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="../../../../skins/monobook/IE50Fixes.css?195" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="../../../../skins/monobook/IE55Fixes.css?195" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="../../../../skins/monobook/IE60Fixes.css?195" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="../../../../skins/monobook/IE70Fixes.css?195" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="../../../../skins/../../../../raw/MediaWiki%7ECommon.css?195" type="text/css" />
		<link rel="stylesheet" href="../../../../skins/../../../../raw/MediaWiki%7EPrint.css?195" type="text/css" media="print" />
		<link rel="stylesheet" href="../../../../skins/../../../../raw/MediaWiki%7EMonobook.css?195" type="text/css" />
		<link rel="stylesheet" href="../../../../skins/../../../../raw/gen.css?195" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="../../../../skins/common/IEFixes.js?195"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "../../../../skins";
		var wgArticlePath = "../../../../$1";
		var wgScriptPath = "../../../../..";
		var wgScript = "/icis/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://localhost";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "TDM_Windows_Application_Programming_Interface_5.4";
		var wgTitle = "TDM Windows Application Programming Interface 5.4";
		var wgAction = "view";
		var wgArticleId = "2479";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = "13003";
		var wgVersion = "1.14.0";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="../../../../skins/common/wikibits.js?195"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="../../../../raw/gen.js"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-TDM_Windows_Application_Programming_Interface_5_4 skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
				<h1 id="firstHeading" class="firstHeading">TDM Windows Application Programming Interface 5.4</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From ICISWiki</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<table id="toc" class="toc" summary="Contents"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#DLL_Architecture"><span class="tocnumber">1</span> <span class="toctext">DLL Architecture</span></a>
<ul>
<li class="toclevel-2"><a href="#INTRODUCTION"><span class="tocnumber">1.1</span> <span class="toctext">INTRODUCTION</span></a>
<ul>
<li class="toclevel-3"><a href="#Conventions_of_ICIS_Application_Development"><span class="tocnumber">1.1.1</span> <span class="toctext">Conventions of ICIS Application Development</span></a></li>
<li class="toclevel-3"><a href="#Data_Source_Names_and_the_INI_file"><span class="tocnumber">1.1.2</span> <span class="toctext">Data Source Names and the INI file</span></a></li>
<li class="toclevel-3"><a href="#Return_values_for_ICIS_DLL_functions"><span class="tocnumber">1.1.3</span> <span class="toctext">Return values for ICIS DLL functions</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#ICIS_Data_Structures"><span class="tocnumber">2</span> <span class="toctext">ICIS Data Structures</span></a>
<ul>
<li class="toclevel-2"><a href="#Introduction_2"><span class="tocnumber">2.1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-2"><a href="#GMS_DATA_STRUCTURES"><span class="tocnumber">2.2</span> <span class="toctext">GMS DATA STRUCTURES</span></a>
<ul>
<li class="toclevel-3"><a href="#GMS_Germplasm_structure_.28in_order_of_declaration.29"><span class="tocnumber">2.2.1</span> <span class="toctext">GMS_Germplasm structure (in order of declaration)</span></a></li>
<li class="toclevel-3"><a href="#GMS_NameData_structure"><span class="tocnumber">2.2.2</span> <span class="toctext">GMS_NameData structure</span></a></li>
<li class="toclevel-3"><a href="#GMS_Attribute_structure"><span class="tocnumber">2.2.3</span> <span class="toctext">GMS_Attribute structure</span></a></li>
<li class="toclevel-3"><a href="#GMS_Method_structure"><span class="tocnumber">2.2.4</span> <span class="toctext">GMS_Method structure</span></a></li>
<li class="toclevel-3"><a href="#GMS_UDField_structure"><span class="tocnumber">2.2.5</span> <span class="toctext">GMS_UDField structure</span></a></li>
<li class="toclevel-3"><a href="#GMS_Changes_Structure"><span class="tocnumber">2.2.6</span> <span class="toctext">GMS_Changes Structure</span></a></li>
<li class="toclevel-3"><a href="#GMS_User_structure"><span class="tocnumber">2.2.7</span> <span class="toctext">GMS_User structure</span></a></li>
<li class="toclevel-3"><a href="#GMS_Installation_Structure"><span class="tocnumber">2.2.8</span> <span class="toctext">GMS_Installation Structure</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#LIST_DATA_STRUCTURE"><span class="tocnumber">2.3</span> <span class="toctext">LIST DATA STRUCTURE</span></a>
<ul>
<li class="toclevel-3"><a href="#GMS_ListName_Structure"><span class="tocnumber">2.3.1</span> <span class="toctext">GMS_ListName Structure</span></a></li>
<li class="toclevel-3"><a href="#GMS_ListData_Structure"><span class="tocnumber">2.3.2</span> <span class="toctext">GMS_ListData Structure</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#LMS_Data_Structure"><span class="tocnumber">2.4</span> <span class="toctext">LMS Data Structure</span></a>
<ul>
<li class="toclevel-3"><a href="#GMS_Location_structure"><span class="tocnumber">2.4.1</span> <span class="toctext">GMS_Location structure</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#DMS_DATA_STRUCTURE"><span class="tocnumber">2.5</span> <span class="toctext">DMS DATA STRUCTURE</span></a>
<ul>
<li class="toclevel-3"><a href="#DMS_STUDY_Structure"><span class="tocnumber">2.5.1</span> <span class="toctext">DMS_STUDY Structure</span></a></li>
<li class="toclevel-3"><a href="#DMS_FACTOR_Structure"><span class="tocnumber">2.5.2</span> <span class="toctext">DMS_FACTOR Structure</span></a></li>
<li class="toclevel-3"><a href="#DMS_VARIATE_Structure"><span class="tocnumber">2.5.3</span> <span class="toctext">DMS_VARIATE Structure</span></a></li>
<li class="toclevel-3"><a href="#DMS_DATAN_Structure"><span class="tocnumber">2.5.4</span> <span class="toctext">DMS_DATAN Structure</span></a></li>
<li class="toclevel-3"><a href="#DMS_DATAC_Structure"><span class="tocnumber">2.5.5</span> <span class="toctext">DMS_DATAC Structure</span></a></li>
<li class="toclevel-3"><a href="#DMS_LEVELC_Structure"><span class="tocnumber">2.5.6</span> <span class="toctext">DMS_LEVELC Structure</span></a></li>
<li class="toclevel-3"><a href="#DMS_LEVELN_Structure"><span class="tocnumber">2.5.7</span> <span class="toctext">DMS_LEVELN Structure</span></a></li>
<li class="toclevel-3"><a href="#EFFECT_Structure"><span class="tocnumber">2.5.8</span> <span class="toctext">EFFECT Structure</span></a></li>
<li class="toclevel-3"><a href="#DMS_VEFFECT"><span class="tocnumber">2.5.9</span> <span class="toctext">DMS_VEFFECT</span></a></li>
<li class="toclevel-3"><a href="#DMS_OINDEX_Structure"><span class="tocnumber">2.5.10</span> <span class="toctext">DMS_OINDEX Structure</span></a></li>
<li class="toclevel-3"><a href="#DMS_TRAIT_Structure"><span class="tocnumber">2.5.11</span> <span class="toctext">DMS_TRAIT Structure</span></a></li>
<li class="toclevel-3"><a href="#DMS_SCALE_Structure"><span class="tocnumber">2.5.12</span> <span class="toctext">DMS_SCALE Structure</span></a></li>
<li class="toclevel-3"><a href="#DMS_TMETHOD_Structure"><span class="tocnumber">2.5.13</span> <span class="toctext">DMS_TMETHOD Structure</span></a></li>
<li class="toclevel-3"><a href="#DMS_SCALECON"><span class="tocnumber">2.5.14</span> <span class="toctext">DMS_SCALECON</span></a></li>
<li class="toclevel-3"><a href="#DMS_SCALEDIS"><span class="tocnumber">2.5.15</span> <span class="toctext">DMS_SCALEDIS</span></a></li>
<li class="toclevel-3"><a href="#DMS_NumVALUE_Structure"><span class="tocnumber">2.5.16</span> <span class="toctext">DMS_NumVALUE Structure</span></a></li>
<li class="toclevel-3"><a href="#DMS_CharVALUE_Structure"><span class="tocnumber">2.5.17</span> <span class="toctext">DMS_CharVALUE Structure</span></a></li>
<li class="toclevel-3"><a href="#Source"><span class="tocnumber">2.5.18</span> <span class="toctext">Source</span></a></li>
<li class="toclevel-3"><a href="#DMS_DMSATTR"><span class="tocnumber">2.5.19</span> <span class="toctext">DMS_DMSATTR</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#IMS_DATA_STRUCTURES"><span class="tocnumber">2.6</span> <span class="toctext">IMS DATA STRUCTURES</span></a>
<ul>
<li class="toclevel-3"><a href="#IMS_LOT_Structure"><span class="tocnumber">2.6.1</span> <span class="toctext">IMS_LOT Structure</span></a></li>
<li class="toclevel-3"><a href="#IMS_TRANSACTION_Structure"><span class="tocnumber">2.6.2</span> <span class="toctext">IMS_TRANSACTION Structure</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#BIBREF_DATA_STRUCTURE"><span class="tocnumber">2.7</span> <span class="toctext">BIBREF DATA STRUCTURE</span></a></li>
<li class="toclevel-2"><a href="#GEMS_DATA_STRUCTURE"><span class="tocnumber">2.8</span> <span class="toctext">GEMS DATA STRUCTURE</span></a>
<ul>
<li class="toclevel-3"><a href="#GEMS_INFO_structure"><span class="tocnumber">2.8.1</span> <span class="toctext">GEMS_INFO structure</span></a></li>
<li class="toclevel-3"><a href="#GEMS_MARKER_DETECTOR_structure"><span class="tocnumber">2.8.2</span> <span class="toctext">GEMS_MARKER_DETECTOR structure</span></a></li>
<li class="toclevel-3"><a href="#GEMS_MV_structure"><span class="tocnumber">2.8.3</span> <span class="toctext">GEMS_MV structure</span></a></li>
<li class="toclevel-3"><a href="#GEMS_NAME_structure"><span class="tocnumber">2.8.4</span> <span class="toctext">GEMS_NAME structure</span></a></li>
<li class="toclevel-3"><a href="#GEMS_COMPONENT_structure"><span class="tocnumber">2.8.5</span> <span class="toctext">GEMS_COMPONENT structure</span></a></li>
<li class="toclevel-3"><a href="#GEMS_PD_COMP_structure"><span class="tocnumber">2.8.6</span> <span class="toctext">GEMS_PD_COMP structure</span></a></li>
<li class="toclevel-3"><a href="#GEMS_PROP_structure"><span class="tocnumber">2.8.7</span> <span class="toctext">GEMS_PROP structure</span></a></li>
<li class="toclevel-3"><a href="#GEMS_PD_structure"><span class="tocnumber">2.8.8</span> <span class="toctext">GEMS_PD structure</span></a></li>
<li class="toclevel-3"><a href="#GEMS_CONDITION_structure"><span class="tocnumber">2.8.9</span> <span class="toctext">GEMS_CONDITION structure</span></a></li>
<li class="toclevel-3"><a href="#PD_COMP_INFO_structure"><span class="tocnumber">2.8.10</span> <span class="toctext">PD_COMP_INFO structure</span></a></li>
<li class="toclevel-3"><a href="#GEMS_SCALE_structure"><span class="tocnumber">2.8.11</span> <span class="toctext">GEMS_SCALE structure</span></a></li>
<li class="toclevel-3"><a href="#GEMS_METHOD_structure"><span class="tocnumber">2.8.12</span> <span class="toctext">GEMS_METHOD structure</span></a></li>
<li class="toclevel-3"><a href="#PROP_INFO_structure"><span class="tocnumber">2.8.13</span> <span class="toctext">PROP_INFO structure</span></a></li>
<li class="toclevel-3"><a href="#GEMS_LOCUS_structure"><span class="tocnumber">2.8.14</span> <span class="toctext">GEMS_LOCUS structure</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#SUPPORTING_TABLES"><span class="tocnumber">2.9</span> <span class="toctext">SUPPORTING TABLES</span></a>
<ul>
<li class="toclevel-3"><a href="#SUP_PERSONS_structure"><span class="tocnumber">2.9.1</span> <span class="toctext">SUP_PERSONS structure</span></a></li>
<li class="toclevel-3"><a href="#SUP_INSTITUTE_structure"><span class="tocnumber">2.9.2</span> <span class="toctext">SUP_INSTITUTE structure</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#DLL_Functions_for_Access_Control"><span class="tocnumber">3</span> <span class="toctext">DLL Functions for Access Control</span></a>
<ul>
<li class="toclevel-2"><a href="#GENEALOGY_MANAGEMENT_SYSTEM_DATABASE_ACCESS_FUNCTIONS"><span class="tocnumber">3.1</span> <span class="toctext">GENEALOGY MANAGEMENT SYSTEM DATABASE ACCESS FUNCTIONS</span></a>
<ul>
<li class="toclevel-3"><a href="#GMS_openDatabase"><span class="tocnumber">3.1.1</span> <span class="toctext">GMS_openDatabase</span></a></li>
<li class="toclevel-3"><a href="#GMS_openDatabase2"><span class="tocnumber">3.1.2</span> <span class="toctext">GMS_openDatabase2</span></a></li>
<li class="toclevel-3"><a href="#GMS_closeDatabase"><span class="tocnumber">3.1.3</span> <span class="toctext">GMS_closeDatabase</span></a></li>
<li class="toclevel-3"><a href="#GMS_commitData"><span class="tocnumber">3.1.4</span> <span class="toctext">GMS_commitData</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#DATA_MANAGEMENT_SYSTEM_DATABASE_ACCESS_FUNCTIONS"><span class="tocnumber">3.2</span> <span class="toctext">DATA MANAGEMENT SYSTEM DATABASE ACCESS FUNCTIONS</span></a>
<ul>
<li class="toclevel-3"><a href="#DMS_openDatabase"><span class="tocnumber">3.2.1</span> <span class="toctext">DMS_openDatabase</span></a></li>
<li class="toclevel-3"><a href="#DMS_closeDatabase"><span class="tocnumber">3.2.2</span> <span class="toctext">DMS_closeDatabase</span></a></li>
<li class="toclevel-3"><a href="#DMS_commitData"><span class="tocnumber">3.2.3</span> <span class="toctext">DMS_commitData</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#INVENTORY_MANAGEMENT_SYSTEM_DATABASE_ACCESS_FUNCTIONS"><span class="tocnumber">3.3</span> <span class="toctext">INVENTORY MANAGEMENT SYSTEM DATABASE ACCESS FUNCTIONS</span></a>
<ul>
<li class="toclevel-3"><a href="#IMS_OpenDatabase"><span class="tocnumber">3.3.1</span> <span class="toctext">IMS_OpenDatabase</span></a></li>
<li class="toclevel-3"><a href="#IMS_CloseDatabase"><span class="tocnumber">3.3.2</span> <span class="toctext">IMS_CloseDatabase</span></a></li>
<li class="toclevel-3"><a href="#IMS_commitData"><span class="tocnumber">3.3.3</span> <span class="toctext">IMS_commitData</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#GENE_MANAGEMENT_SYSTEM_DATABASE_ACCESS_FUNCTIONS"><span class="tocnumber">3.4</span> <span class="toctext">GENE MANAGEMENT SYSTEM DATABASE ACCESS FUNCTIONS</span></a>
<ul>
<li class="toclevel-3"><a href="#GEMS_openDatabase"><span class="tocnumber">3.4.1</span> <span class="toctext">GEMS_openDatabase</span></a></li>
<li class="toclevel-3"><a href="#GEMS_closeDatabase"><span class="tocnumber">3.4.2</span> <span class="toctext">GEMS_closeDatabase</span></a></li>
<li class="toclevel-3"><a href="#GEMS_commitData"><span class="tocnumber">3.4.3</span> <span class="toctext">GEMS_commitData</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#USER_AND_INSTALLATION"><span class="tocnumber">3.5</span> <span class="toctext">USER AND INSTALLATION</span></a>
<ul>
<li class="toclevel-3"><a href="#GMS_getUser"><span class="tocnumber">3.5.1</span> <span class="toctext">GMS_getUser</span></a></li>
<li class="toclevel-3"><a href="#GMS_getInstallation"><span class="tocnumber">3.5.2</span> <span class="toctext">GMS_getInstallation</span></a></li>
<li class="toclevel-3"><a href="#GMS_addUser"><span class="tocnumber">3.5.3</span> <span class="toctext">GMS_addUser</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#GMS_DLL_FUNCTIONS"><span class="tocnumber">4</span> <span class="toctext">GMS DLL FUNCTIONS</span></a>
<ul>
<li class="toclevel-2"><a href="#SEARCH_FUNCTIONS"><span class="tocnumber">4.1</span> <span class="toctext">SEARCH FUNCTIONS</span></a>
<ul>
<li class="toclevel-3"><a href="#GMS_findName"><span class="tocnumber">4.1.1</span> <span class="toctext">GMS_findName</span></a></li>
<li class="toclevel-3"><a href="#GMS_findName2"><span class="tocnumber">4.1.2</span> <span class="toctext">GMS_findName2</span></a></li>
<li class="toclevel-3"><a href="#GMS_findName3"><span class="tocnumber">4.1.3</span> <span class="toctext">GMS_findName3</span></a></li>
<li class="toclevel-3"><a href="#GMS_findDescendant"><span class="tocnumber">4.1.4</span> <span class="toctext">GMS_findDescendant</span></a></li>
<li class="toclevel-3"><a href="#GMS_findGermplasm"><span class="tocnumber">4.1.5</span> <span class="toctext">GMS_findGermplasm</span></a></li>
<li class="toclevel-3"><a href="#GMS_findCIDSID"><span class="tocnumber">4.1.6</span> <span class="toctext">GMS_findCIDSID</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#GMS_DATA_RETRIEVAL_functions"><span class="tocnumber">4.2</span> <span class="toctext">GMS DATA RETRIEVAL functions</span></a>
<ul>
<li class="toclevel-3"><a href="#GMS_getGermplasmRecord"><span class="tocnumber">4.2.1</span> <span class="toctext">GMS_getGermplasmRecord</span></a></li>
<li class="toclevel-3"><a href="#GMS_getGermplasm"><span class="tocnumber">4.2.2</span> <span class="toctext">GMS_getGermplasm</span></a></li>
<li class="toclevel-3"><a href="#GMS_getGermplasm2"><span class="tocnumber">4.2.3</span> <span class="toctext">GMS_getGermplasm2</span></a></li>
<li class="toclevel-3"><a href="#GMS_getGermplasm3"><span class="tocnumber">4.2.4</span> <span class="toctext">GMS_getGermplasm3</span></a></li>
<li class="toclevel-3"><a href="#GMS_getProgenitorID"><span class="tocnumber">4.2.5</span> <span class="toctext">GMS_getProgenitorID</span></a></li>
<li class="toclevel-3"><a href="#GMS_getNameRecord"><span class="tocnumber">4.2.6</span> <span class="toctext">GMS_getNameRecord</span></a></li>
<li class="toclevel-3"><a href="#GMS_getName"><span class="tocnumber">4.2.7</span> <span class="toctext">GMS_getName</span></a></li>
<li class="toclevel-3"><a href="#GMS_getAttribute"><span class="tocnumber">4.2.8</span> <span class="toctext">GMS_getAttribute</span></a></li>
<li class="toclevel-3"><a href="#GMS_getMethod"><span class="tocnumber">4.2.9</span> <span class="toctext">GMS_getMethod</span></a></li>
<li class="toclevel-3"><a href="#GMS_applyChanges"><span class="tocnumber">4.2.10</span> <span class="toctext">GMS_applyChanges</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Functions_to_add_data_to_the_local_database"><span class="tocnumber">4.3</span> <span class="toctext">Functions to add data to the local database</span></a>
<ul>
<li class="toclevel-3"><a href="#GMS_addGermplasm"><span class="tocnumber">4.3.1</span> <span class="toctext">GMS_addGermplasm</span></a></li>
<li class="toclevel-3"><a href="#GMS_addName"><span class="tocnumber">4.3.2</span> <span class="toctext">GMS_addName</span></a></li>
<li class="toclevel-3"><a href="#GMS_addAttribute"><span class="tocnumber">4.3.3</span> <span class="toctext">GMS_addAttribute</span></a></li>
<li class="toclevel-3"><a href="#GMS_addChanges"><span class="tocnumber">4.3.4</span> <span class="toctext">GMS_addChanges</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Functions_to_correct_LOCAL_GMS_records"><span class="tocnumber">4.4</span> <span class="toctext">Functions to correct LOCAL GMS records</span></a>
<ul>
<li class="toclevel-3"><a href="#GMS_setGermplasm"><span class="tocnumber">4.4.1</span> <span class="toctext">GMS_setGermplasm</span></a></li>
<li class="toclevel-3"><a href="#GMS_setProgenitorID"><span class="tocnumber">4.4.2</span> <span class="toctext">GMS_setProgenitorID</span></a></li>
<li class="toclevel-3"><a href="#GMS_setPreferredName"><span class="tocnumber">4.4.3</span> <span class="toctext">GMS_setPreferredName</span></a></li>
<li class="toclevel-3"><a href="#GMS_setPreferredAbbr"><span class="tocnumber">4.4.4</span> <span class="toctext">GMS_setPreferredAbbr</span></a></li>
<li class="toclevel-3"><a href="#GMS_setName"><span class="tocnumber">4.4.5</span> <span class="toctext">GMS_setName</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#BASIC_GMS_FUNCTIONS"><span class="tocnumber">4.5</span> <span class="toctext">BASIC GMS FUNCTIONS</span></a>
<ul>
<li class="toclevel-3"><a href="#GMS_generateTree"><span class="tocnumber">4.5.1</span> <span class="toctext">GMS_generateTree</span></a>
<ul>
<li class="toclevel-4"><a href="#Code_Example:"><span class="tocnumber">4.5.1.1</span> <span class="toctext">Code Example:</span></a></li>
<li class="toclevel-4"><a href="#CODEEXAMPLE_OUTPUT"><span class="tocnumber">4.5.1.2</span> <span class="toctext">CODEEXAMPLE OUTPUT</span></a></li>
</ul>
</li>
<li class="toclevel-3"><a href="#GMS_crossExpansion:"><span class="tocnumber">4.5.2</span> <span class="toctext">GMS_crossExpansion:</span></a></li>
<li class="toclevel-3"><a href="#GMS_listNames"><span class="tocnumber">4.5.3</span> <span class="toctext">GMS_listNames</span></a></li>
<li class="toclevel-3"><a href="#GMS_computeGenerationNo"><span class="tocnumber">4.5.4</span> <span class="toctext">GMS_computeGenerationNo</span></a></li>
<li class="toclevel-3"><a href="#GMS_getDerivativeNeighbor"><span class="tocnumber">4.5.5</span> <span class="toctext">GMS_getDerivativeNeighbor</span></a></li>
<li class="toclevel-3"><a href="#GMS_getMgmntNeighbor"><span class="tocnumber">4.5.6</span> <span class="toctext">GMS_getMgmntNeighbor</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#LIST_DLL_FUNCTIONS"><span class="tocnumber">5</span> <span class="toctext">LIST DLL FUNCTIONS</span></a>
<ul>
<li class="toclevel-2"><a href="#FUNCTIONS_ASSOCIATED_TO_LISTNMS_TABLE"><span class="tocnumber">5.1</span> <span class="toctext">FUNCTIONS ASSOCIATED TO LISTNMS TABLE</span></a>
<ul>
<li class="toclevel-3"><a href="#GMS_getListName"><span class="tocnumber">5.1.1</span> <span class="toctext">GMS_getListName</span></a></li>
<li class="toclevel-3"><a href="#GMS_findListName"><span class="tocnumber">5.1.2</span> <span class="toctext">GMS_findListName</span></a></li>
<li class="toclevel-3"><a href="#GMS_setListName"><span class="tocnumber">5.1.3</span> <span class="toctext">GMS_setListName</span></a></li>
<li class="toclevel-3"><a href="#GMS_addListName"><span class="tocnumber">5.1.4</span> <span class="toctext">GMS_addListName</span></a></li>
<li class="toclevel-3"><a href="#GMS_deleteListName"><span class="tocnumber">5.1.5</span> <span class="toctext">GMS_deleteListName</span></a></li>
<li class="toclevel-3"><a href="#GMS_getListByStatus"><span class="tocnumber">5.1.6</span> <span class="toctext">GMS_getListByStatus</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#FUNCTIONS_ASSOCIATED_WITH_LISTDATA_TABLE"><span class="tocnumber">5.2</span> <span class="toctext">FUNCTIONS ASSOCIATED WITH LISTDATA TABLE</span></a>
<ul>
<li class="toclevel-3"><a href="#GMS_getListData"><span class="tocnumber">5.2.1</span> <span class="toctext">GMS_getListData</span></a></li>
<li class="toclevel-3"><a href="#GMS_findListData"><span class="tocnumber">5.2.2</span> <span class="toctext">GMS_findListData</span></a></li>
<li class="toclevel-3"><a href="#GMS_setListData"><span class="tocnumber">5.2.3</span> <span class="toctext">GMS_setListData</span></a></li>
<li class="toclevel-3"><a href="#GMS_addListData"><span class="tocnumber">5.2.4</span> <span class="toctext">GMS_addListData</span></a></li>
<li class="toclevel-3"><a href="#GMS_deleteListData"><span class="tocnumber">5.2.5</span> <span class="toctext">GMS_deleteListData</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#USER_DEFINED_FIELDS_AND_CONSTANTS_FUNCTIONS"><span class="tocnumber">6</span> <span class="toctext">USER DEFINED FIELDS AND CONSTANTS FUNCTIONS</span></a>
<ul>
<li class="toclevel-2"><a href="#GMS_getUDField"><span class="tocnumber">6.1</span> <span class="toctext">GMS_getUDField</span></a></li>
<li class="toclevel-2"><a href="#GMS_getUDField2"><span class="tocnumber">6.2</span> <span class="toctext">GMS_getUDField2</span></a></li>
<li class="toclevel-2"><a href="#GMS_findUDField"><span class="tocnumber">6.3</span> <span class="toctext">GMS_findUDField</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#DMS_DLL_FUNCTIONS"><span class="tocnumber">7</span> <span class="toctext">DMS DLL FUNCTIONS</span></a>
<ul>
<li class="toclevel-2"><a href="#INTRODUCTION_3"><span class="tocnumber">7.1</span> <span class="toctext">INTRODUCTION</span></a></li>
<li class="toclevel-2"><a href="#ADD_FUNCTIONS"><span class="tocnumber">7.2</span> <span class="toctext">ADD FUNCTIONS</span></a>
<ul>
<li class="toclevel-3"><a href="#DMS_addStudy"><span class="tocnumber">7.2.1</span> <span class="toctext">DMS_addStudy</span></a></li>
<li class="toclevel-3"><a href="#DMS_addFactor"><span class="tocnumber">7.2.2</span> <span class="toctext">DMS_addFactor</span></a></li>
<li class="toclevel-3"><a href="#DMS_addVariate"><span class="tocnumber">7.2.3</span> <span class="toctext">DMS_addVariate</span></a></li>
<li class="toclevel-3"><a href="#DMS_addLevelN"><span class="tocnumber">7.2.4</span> <span class="toctext">DMS_addLevelN</span></a></li>
<li class="toclevel-3"><a href="#DMS_addLevelC"><span class="tocnumber">7.2.5</span> <span class="toctext">DMS_addLevelC</span></a></li>
<li class="toclevel-3"><a href="#DMS_addDataN"><span class="tocnumber">7.2.6</span> <span class="toctext">DMS_addDataN</span></a></li>
<li class="toclevel-3"><a href="#DMS_addDataC"><span class="tocnumber">7.2.7</span> <span class="toctext">DMS_addDataC</span></a></li>
<li class="toclevel-3"><a href="#DMS_addObsunit"><span class="tocnumber">7.2.8</span> <span class="toctext">DMS_addObsunit</span></a></li>
<li class="toclevel-3"><a href="#DMS_addOindex"><span class="tocnumber">7.2.9</span> <span class="toctext">DMS_addOindex</span></a></li>
<li class="toclevel-3"><a href="#0__DMS_addAttr"><span class="tocnumber">7.2.10</span> <span class="toctext">0  DMS_addAttr</span></a></li>
<li class="toclevel-3"><a href="#DMS_addTrait"><span class="tocnumber">7.2.11</span> <span class="toctext">DMS_addTrait</span></a></li>
<li class="toclevel-3"><a href="#DMS_addScale"><span class="tocnumber">7.2.12</span> <span class="toctext">DMS_addScale</span></a></li>
<li class="toclevel-3"><a href="#DMS_addTmethod"><span class="tocnumber">7.2.13</span> <span class="toctext">DMS_addTmethod</span></a></li>
<li class="toclevel-3"><a href="#DMS_addEffect"><span class="tocnumber">7.2.14</span> <span class="toctext">DMS_addEffect</span></a></li>
<li class="toclevel-3"><a href="#DMS_addVEffect"><span class="tocnumber">7.2.15</span> <span class="toctext">DMS_addVEffect</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#DMS_FIND_FUNCTIONS"><span class="tocnumber">7.3</span> <span class="toctext">DMS FIND FUNCTIONS</span></a>
<ul>
<li class="toclevel-3"><a href="#DMS_findStudy"><span class="tocnumber">7.3.1</span> <span class="toctext">DMS_findStudy</span></a></li>
<li class="toclevel-3"><a href="#DMS_findFactor"><span class="tocnumber">7.3.2</span> <span class="toctext">DMS_findFactor</span></a></li>
<li class="toclevel-3"><a href="#DMS_findVariate"><span class="tocnumber">7.3.3</span> <span class="toctext">DMS_findVariate</span></a></li>
<li class="toclevel-3"><a href="#DMS_findLevelN"><span class="tocnumber">7.3.4</span> <span class="toctext">DMS_findLevelN</span></a></li>
<li class="toclevel-3"><a href="#DMS_findLevelC"><span class="tocnumber">7.3.5</span> <span class="toctext">DMS_findLevelC</span></a></li>
<li class="toclevel-3"><a href="#DMS_findLabelC"><span class="tocnumber">7.3.6</span> <span class="toctext">DMS_findLabelC</span></a></li>
<li class="toclevel-3"><a href="#DMS_findLabelN"><span class="tocnumber">7.3.7</span> <span class="toctext">DMS_findLabelN</span></a></li>
<li class="toclevel-3"><a href="#DMS_findStOunit"><span class="tocnumber">7.3.8</span> <span class="toctext">DMS_findStOunit</span></a></li>
<li class="toclevel-3"><a href="#DMS_findStEffect"><span class="tocnumber">7.3.9</span> <span class="toctext">DMS_findStEffect</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#DMS_GENERAL_QUERY_FUNCTIONS"><span class="tocnumber">7.4</span> <span class="toctext">DMS GENERAL QUERY FUNCTIONS</span></a>
<ul>
<li class="toclevel-3"><a href="#DMS_searchLevelN"><span class="tocnumber">7.4.1</span> <span class="toctext">DMS_searchLevelN</span></a></li>
<li class="toclevel-3"><a href="#DMS_searchDataN"><span class="tocnumber">7.4.2</span> <span class="toctext">DMS_searchDataN</span></a></li>
<li class="toclevel-3"><a href="#DMS_searchLevelC"><span class="tocnumber">7.4.3</span> <span class="toctext">DMS_searchLevelC</span></a></li>
<li class="toclevel-3"><a href="#DMS_searchDataC"><span class="tocnumber">7.4.4</span> <span class="toctext">DMS_searchDataC</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#QUERY_THROUGH_OBSERVATION_UNIT"><span class="tocnumber">7.5</span> <span class="toctext">QUERY THROUGH OBSERVATION UNIT</span></a>
<ul>
<li class="toclevel-3"><a href="#DMS_defineOunitDN"><span class="tocnumber">7.5.1</span> <span class="toctext">DMS_defineOunitDN</span></a></li>
<li class="toclevel-3"><a href="#DMS_defineOunitDC"><span class="tocnumber">7.5.2</span> <span class="toctext">DMS_defineOunitDC</span></a></li>
<li class="toclevel-3"><a href="#DMS_defineOunitLN"><span class="tocnumber">7.5.3</span> <span class="toctext">DMS_defineOunitLN</span></a></li>
<li class="toclevel-3"><a href="#DMS_defineOunitLC"><span class="tocnumber">7.5.4</span> <span class="toctext">DMS_defineOunitLC</span></a></li>
<li class="toclevel-3"><a href="#DMS_extractOunitDN"><span class="tocnumber">7.5.5</span> <span class="toctext">DMS_extractOunitDN</span></a></li>
<li class="toclevel-3"><a href="#DMS_extractOunitDC"><span class="tocnumber">7.5.6</span> <span class="toctext">DMS_extractOunitDC</span></a></li>
<li class="toclevel-3"><a href="#DMS_extractOunitLN"><span class="tocnumber">7.5.7</span> <span class="toctext">DMS_extractOunitLN</span></a></li>
<li class="toclevel-3"><a href="#DMS_extractOunitLC"><span class="tocnumber">7.5.8</span> <span class="toctext">DMS_extractOunitLC</span></a></li>
<li class="toclevel-3"><a href="#DMS_describeOunit"><span class="tocnumber">7.5.9</span> <span class="toctext">DMS_describeOunit</span></a></li>
<li class="toclevel-3"><a href="#DMS_describeEffectOunit"><span class="tocnumber">7.5.10</span> <span class="toctext">DMS_describeEffectOunit</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#DMS_ACCESS_FUNCTIONS"><span class="tocnumber">7.6</span> <span class="toctext">DMS ACCESS FUNCTIONS</span></a>
<ul>
<li class="toclevel-3"><a href="#DMS_getStudy"><span class="tocnumber">7.6.1</span> <span class="toctext">DMS_getStudy</span></a></li>
<li class="toclevel-3"><a href="#DMS_getObsunit"><span class="tocnumber">7.6.2</span> <span class="toctext">DMS_getObsunit</span></a></li>
<li class="toclevel-3"><a href="#DMS_getLevelC"><span class="tocnumber">7.6.3</span> <span class="toctext">DMS_getLevelC</span></a></li>
<li class="toclevel-3"><a href="#DMS_getLabelC"><span class="tocnumber">7.6.4</span> <span class="toctext">DMS_getLabelC</span></a></li>
<li class="toclevel-3"><a href="#DMS_getAllLevelC"><span class="tocnumber">7.6.5</span> <span class="toctext">DMS_getAllLevelC</span></a></li>
<li class="toclevel-3"><a href="#DMS_getAllLabelC"><span class="tocnumber">7.6.6</span> <span class="toctext">DMS_getAllLabelC</span></a></li>
<li class="toclevel-3"><a href="#DMS_getLevelN"><span class="tocnumber">7.6.7</span> <span class="toctext">DMS_getLevelN</span></a></li>
<li class="toclevel-3"><a href="#DMS_getLabelN"><span class="tocnumber">7.6.8</span> <span class="toctext">DMS_getLabelN</span></a></li>
<li class="toclevel-3"><a href="#DMS_getAllLevelN"><span class="tocnumber">7.6.9</span> <span class="toctext">DMS_getAllLevelN</span></a></li>
<li class="toclevel-3"><a href="#0DMS_getAllLabelN"><span class="tocnumber">7.6.10</span> <span class="toctext">0DMS_getAllLabelN</span></a></li>
<li class="toclevel-3"><a href="#DMS_getDataC"><span class="tocnumber">7.6.11</span> <span class="toctext">DMS_getDataC</span></a></li>
<li class="toclevel-3"><a href="#DMS_getDataN"><span class="tocnumber">7.6.12</span> <span class="toctext">DMS_getDataN</span></a></li>
<li class="toclevel-3"><a href="#DMS_getTrait"><span class="tocnumber">7.6.13</span> <span class="toctext">DMS_getTrait</span></a></li>
<li class="toclevel-3"><a href="#DMS_getScale"><span class="tocnumber">7.6.14</span> <span class="toctext">DMS_getScale</span></a></li>
<li class="toclevel-3"><a href="#DMS_getScaleCon"><span class="tocnumber">7.6.15</span> <span class="toctext">DMS_getScaleCon</span></a></li>
<li class="toclevel-3"><a href="#DMS_getScaleDis2"><span class="tocnumber">7.6.16</span> <span class="toctext">DMS_getScaleDis2</span></a></li>
<li class="toclevel-3"><a href="#DMS_getScaleTab"><span class="tocnumber">7.6.17</span> <span class="toctext">DMS_getScaleTab</span></a></li>
<li class="toclevel-3"><a href="#DMS_getTmethod"><span class="tocnumber">7.6.18</span> <span class="toctext">DMS_getTmethod</span></a></li>
<li class="toclevel-3"><a href="#DMS_getOunitLevelN"><span class="tocnumber">7.6.19</span> <span class="toctext">DMS_getOunitLevelN</span></a></li>
<li class="toclevel-3"><a href="#DMS_getOunitLevelC"><span class="tocnumber">7.6.20</span> <span class="toctext">DMS_getOunitLevelC</span></a></li>
<li class="toclevel-3"><a href="#DMS_getEffectOunit"><span class="tocnumber">7.6.21</span> <span class="toctext">DMS_getEffectOunit</span></a></li>
<li class="toclevel-3"><a href="#DMS_getEffectRecord"><span class="tocnumber">7.6.22</span> <span class="toctext">DMS_getEffectRecord</span></a></li>
<li class="toclevel-3"><a href="#DMS_getEffectRecordV"><span class="tocnumber">7.6.23</span> <span class="toctext">DMS_getEffectRecordV</span></a></li>
<li class="toclevel-3"><a href="#DMS_getEffect"><span class="tocnumber">7.6.24</span> <span class="toctext">DMS_getEffect</span></a></li>
<li class="toclevel-3"><a href="#DMS_getFactorEffect"><span class="tocnumber">7.6.25</span> <span class="toctext">DMS_getFactorEffect</span></a></li>
<li class="toclevel-3"><a href="#DMS_getFactor"><span class="tocnumber">7.6.26</span> <span class="toctext">DMS_getFactor</span></a></li>
<li class="toclevel-3"><a href="#Long_DMS_getFactor.28_factor.2C_fOpt.29"><span class="tocnumber">7.6.27</span> <span class="toctext">Long DMS_getFactor( factor, fOpt)</span></a></li>
<li class="toclevel-3"><a href="#DMS_getFactorLabel"><span class="tocnumber">7.6.28</span> <span class="toctext">DMS_getFactorLabel</span></a></li>
<li class="toclevel-3"><a href="#DMS_getVariate"><span class="tocnumber">7.6.29</span> <span class="toctext">DMS_getVariate</span></a></li>
<li class="toclevel-3"><a href="#DMS_getDMSAttr"><span class="tocnumber">7.6.30</span> <span class="toctext">DMS_getDMSAttr</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#DMS_UPDATE_FUNCTIONS"><span class="tocnumber">7.7</span> <span class="toctext">DMS UPDATE FUNCTIONS</span></a>
<ul>
<li class="toclevel-3"><a href="#DMS_updateDataC"><span class="tocnumber">7.7.1</span> <span class="toctext">DMS_updateDataC</span></a></li>
<li class="toclevel-3"><a href="#DMS_updateDataN"><span class="tocnumber">7.7.2</span> <span class="toctext">DMS_updateDataN</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#DMS_DELETE_FUNCTION"><span class="tocnumber">7.8</span> <span class="toctext">DMS DELETE FUNCTION</span></a>
<ul>
<li class="toclevel-3"><a href="#DMS_deleteStudy"><span class="tocnumber">7.8.1</span> <span class="toctext">DMS_deleteStudy</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#MISCELLANEOUS_FUNCTIONS"><span class="tocnumber">7.9</span> <span class="toctext">MISCELLANEOUS FUNCTIONS</span></a>
<ul>
<li class="toclevel-3"><a href="#DMS_existCombination"><span class="tocnumber">7.9.1</span> <span class="toctext">DMS_existCombination</span></a></li>
<li class="toclevel-3"><a href="#DMS_existEffect"><span class="tocnumber">7.9.2</span> <span class="toctext">DMS_existEffect</span></a></li>
<li class="toclevel-3"><a href="#DMS_minOunitid"><span class="tocnumber">7.9.3</span> <span class="toctext">DMS_minOunitid</span></a></li>
<li class="toclevel-3"><a href="#DMS_deleteStudy_2"><span class="tocnumber">7.9.4</span> <span class="toctext">DMS_deleteStudy</span></a></li>
<li class="toclevel-3"><a href="#DMS_deleteDataC"><span class="tocnumber">7.9.5</span> <span class="toctext">DMS_deleteDataC</span></a></li>
<li class="toclevel-3"><a href="#DMS_deleteDataN"><span class="tocnumber">7.9.6</span> <span class="toctext">DMS_deleteDataN</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#IMS_DLL_FUNCTIONS"><span class="tocnumber">8</span> <span class="toctext">IMS DLL FUNCTIONS</span></a>
<ul>
<li class="toclevel-2"><a href="#ADD_Functions_2"><span class="tocnumber">8.1</span> <span class="toctext">ADD Functions</span></a>
<ul>
<li class="toclevel-3"><a href="#IMS_addLot"><span class="tocnumber">8.1.1</span> <span class="toctext">IMS_addLot</span></a></li>
<li class="toclevel-3"><a href="#IMS_addTransaction"><span class="tocnumber">8.1.2</span> <span class="toctext">IMS_addTransaction</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#DATA_RETRIEVAL_FUNCTIONS"><span class="tocnumber">8.2</span> <span class="toctext">DATA RETRIEVAL FUNCTIONS</span></a>
<ul>
<li class="toclevel-3"><a href="#IMS_findLotRecord"><span class="tocnumber">8.2.1</span> <span class="toctext">IMS_findLotRecord</span></a></li>
<li class="toclevel-3"><a href="#IMS_findTransactionRecord"><span class="tocnumber">8.2.2</span> <span class="toctext">IMS_findTransactionRecord</span></a></li>
<li class="toclevel-3"><a href="#IMS_getTransactionReserve"><span class="tocnumber">8.2.3</span> <span class="toctext">IMS_getTransactionReserve</span></a></li>
<li class="toclevel-3"><a href="#IMS_getTransactionDeposit"><span class="tocnumber">8.2.4</span> <span class="toctext">IMS_getTransactionDeposit</span></a></li>
<li class="toclevel-3"><a href="#IMS_getReserveByPerson"><span class="tocnumber">8.2.5</span> <span class="toctext">IMS_getReserveByPerson</span></a></li>
<li class="toclevel-3"><a href="#IMS_getDepositByPerson"><span class="tocnumber">8.2.6</span> <span class="toctext">IMS_getDepositByPerson</span></a></li>
<li class="toclevel-3"><a href="#IMS_getBalanceOfLot"><span class="tocnumber">8.2.7</span> <span class="toctext">IMS_getBalanceOfLot</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#UPDATE_FUNCTIONS"><span class="tocnumber">8.3</span> <span class="toctext">UPDATE FUNCTIONS</span></a>
<ul>
<li class="toclevel-3"><a href="#IMS_setTransaction"><span class="tocnumber">8.3.1</span> <span class="toctext">IMS_setTransaction</span></a></li>
<li class="toclevel-3"><a href="#IMS_setLot"><span class="tocnumber">8.3.2</span> <span class="toctext">IMS_setLot</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#REPORT_FUNCTIONS"><span class="tocnumber">8.4</span> <span class="toctext">REPORT FUNCTIONS</span></a>
<ul>
<li class="toclevel-3"><a href="#IMS_reportAllTransaction"><span class="tocnumber">8.4.1</span> <span class="toctext">IMS_reportAllTransaction</span></a></li>
<li class="toclevel-3"><a href="#IMS_reportMaterialDist"><span class="tocnumber">8.4.2</span> <span class="toctext">IMS_reportMaterialDist</span></a></li>
<li class="toclevel-3"><a href="#IMS_reportByRequestor"><span class="tocnumber">8.4.3</span> <span class="toctext">IMS_reportByRequestor</span></a></li>
<li class="toclevel-3"><a href="#IMS_reportBalance"><span class="tocnumber">8.4.4</span> <span class="toctext">IMS_reportBalance</span></a></li>
<li class="toclevel-3"><a href="#IMS_reportEmptyShelves"><span class="tocnumber">8.4.5</span> <span class="toctext">IMS_reportEmptyShelves</span></a></li>
<li class="toclevel-3"><a href="#IMS_reportDormantEntries"><span class="tocnumber">8.4.6</span> <span class="toctext">IMS_reportDormantEntries</span></a></li>
<li class="toclevel-3"><a href="#IMS_reportMinimumAmount"><span class="tocnumber">8.4.7</span> <span class="toctext">IMS_reportMinimumAmount</span></a></li>
<li class="toclevel-3"><a href="#IMS_reportLotByEntity"><span class="tocnumber">8.4.8</span> <span class="toctext">IMS_reportLotByEntity</span></a></li>
<li class="toclevel-3"><a href="#IMS_reportLotByEntityGIDFrom"><span class="tocnumber">8.4.9</span> <span class="toctext">IMS_reportLotByEntityGIDFrom</span></a></li>
<li class="toclevel-3"><a href="#IMS_reportLotByEntityGIDRange"><span class="tocnumber">8.4.10</span> <span class="toctext">IMS_reportLotByEntityGIDRange</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#MISCELLANEOUS"><span class="tocnumber">8.5</span> <span class="toctext">MISCELLANEOUS</span></a>
<ul>
<li class="toclevel-3"><a href="#IMS_closeLot"><span class="tocnumber">8.5.1</span> <span class="toctext">IMS_closeLot</span></a></li>
<li class="toclevel-3"><a href="#IMS_calculateBalance"><span class="tocnumber">8.5.2</span> <span class="toctext">IMS_calculateBalance</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#LMS_DLL_FUNCTIONS"><span class="tocnumber">9</span> <span class="toctext">LMS DLL FUNCTIONS</span></a>
<ul>
<li class="toclevel-2"><a href="#GMS_findLocation"><span class="tocnumber">9.1</span> <span class="toctext">GMS_findLocation</span></a></li>
<li class="toclevel-2"><a href="#GMS_getLocation"><span class="tocnumber">9.2</span> <span class="toctext">GMS_getLocation</span></a></li>
<li class="toclevel-2"><a href="#GMS_getLocation2"><span class="tocnumber">9.3</span> <span class="toctext">GMS_getLocation2</span></a></li>
<li class="toclevel-2"><a href="#GMS_addLocation"><span class="tocnumber">9.4</span> <span class="toctext">GMS_addLocation</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#BIBREF_DLL_FUNCTIONS"><span class="tocnumber">10</span> <span class="toctext">BIBREF DLL FUNCTIONS</span></a>
<ul>
<li class="toclevel-2"><a href="#GMS_getBibrefs"><span class="tocnumber">10.1</span> <span class="toctext">GMS_getBibrefs</span></a></li>
<li class="toclevel-2"><a href="#GMS_addBibrefs"><span class="tocnumber">10.2</span> <span class="toctext">GMS_addBibrefs</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#GEMS_DLL_FUNCTIONS"><span class="tocnumber">11</span> <span class="toctext">GEMS DLL FUNCTIONS</span></a>
<ul>
<li class="toclevel-2"><a href="#ADD_FUNCTIONS_3"><span class="tocnumber">11.1</span> <span class="toctext">ADD FUNCTIONS</span></a>
<ul>
<li class="toclevel-3"><a href="#GEMS_addGEMSName"><span class="tocnumber">11.1.1</span> <span class="toctext">GEMS_addGEMSName</span></a></li>
<li class="toclevel-3"><a href="#GEMS_addComponent"><span class="tocnumber">11.1.2</span> <span class="toctext">GEMS_addComponent</span></a></li>
<li class="toclevel-3"><a href="#GEMS_addMD"><span class="tocnumber">11.1.3</span> <span class="toctext">GEMS_addMD</span></a></li>
<li class="toclevel-3"><a href="#GEMS_addMV"><span class="tocnumber">11.1.4</span> <span class="toctext">GEMS_addMV</span></a></li>
<li class="toclevel-3"><a href="#GEMS_addLocus"><span class="tocnumber">11.1.5</span> <span class="toctext">GEMS_addLocus</span></a></li>
<li class="toclevel-3"><a href="#GEMS_addPD"><span class="tocnumber">11.1.6</span> <span class="toctext">GEMS_addPD</span></a></li>
<li class="toclevel-3"><a href="#GEMS_addPdComp"><span class="tocnumber">11.1.7</span> <span class="toctext">GEMS_addPdComp</span></a></li>
<li class="toclevel-3"><a href="#GEMS_addProp"><span class="tocnumber">11.1.8</span> <span class="toctext">GEMS_addProp</span></a></li>
<li class="toclevel-3"><a href="#GEMS_addScale"><span class="tocnumber">11.1.9</span> <span class="toctext">GEMS_addScale</span></a></li>
<li class="toclevel-3"><a href="#GEMS_addMethod"><span class="tocnumber">11.1.10</span> <span class="toctext">GEMS_addMethod</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#GET_FUNCTIONS"><span class="tocnumber">11.2</span> <span class="toctext">GET FUNCTIONS</span></a>
<ul>
<li class="toclevel-3"><a href="#GEMS_getGemsMID"><span class="tocnumber">11.2.1</span> <span class="toctext">GEMS_getGemsMID</span></a></li>
<li class="toclevel-3"><a href="#GEMS_getGemsMVID"><span class="tocnumber">11.2.2</span> <span class="toctext">GEMS_getGemsMVID</span></a></li>
<li class="toclevel-3"><a href="#GEMS_getNameID"><span class="tocnumber">11.2.3</span> <span class="toctext">GEMS_getNameID</span></a></li>
<li class="toclevel-3"><a href="#GEMS_getProtocolID"><span class="tocnumber">11.2.4</span> <span class="toctext">GEMS_getProtocolID</span></a></li>
<li class="toclevel-3"><a href="#GEMS_getPdComp"><span class="tocnumber">11.2.5</span> <span class="toctext">GEMS_getPdComp</span></a></li>
<li class="toclevel-3"><a href="#GEMS_findPID"><span class="tocnumber">11.2.6</span> <span class="toctext">GEMS_findPID</span></a></li>
<li class="toclevel-3"><a href="#GEMS_findPdid"><span class="tocnumber">11.2.7</span> <span class="toctext">GEMS_findPdid</span></a></li>
<li class="toclevel-3"><a href="#GEMS_findPropID"><span class="tocnumber">11.2.8</span> <span class="toctext">GEMS_findPropID</span></a></li>
<li class="toclevel-3"><a href="#GEMS_findScale"><span class="tocnumber">11.2.9</span> <span class="toctext">GEMS_findScale</span></a></li>
<li class="toclevel-3"><a href="#GEMS_findMethod"><span class="tocnumber">11.2.10</span> <span class="toctext">GEMS_findMethod</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</td></tr></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<a name="DLL_Architecture" id="DLL_Architecture"></a><h2> <span class="mw-headline"> DLL Architecture </span></h2>
<a name="INTRODUCTION" id="INTRODUCTION"></a><h3> <span class="mw-headline"> INTRODUCTION</span></h3>
<p>ICIS applications can be written in any computer language under a WINDOWS 32-bit operating system.  They must only access the ICIS databases through the ICIS DLL functions. Programs, which access the database directly or through any other system, may 
be useful for loading data, but are not portable to other users and so, are not part of the ICIS system.  Any applications, which have potential value for other users, should only use the DLL.
</p>
<a name="Conventions_of_ICIS_Application_Development" id="Conventions_of_ICIS_Application_Development"></a><h4> <span class="mw-headline">Conventions of ICIS Application Development</span></h4>
<p>Most ICIS applications are expected to be WINDOWS 95, 32-bit programs but they could be WINDOWS NT, Windows 2000 or 32-bit console applications.  The restriction to 32 bit operating systems is due to requirements of the ICIS DLL and the ODBC drivers it uses.  This is not regarded as a serious restriction since ICIS will at least require a computer with a CD drive, and most of these are capable of running a 32-bit operating system.  Apart from this restriction applications can be written in any computer language which can access the ICIS DLL.  FORTRAN 90, Delphi PASCAL, Visual Basic, and C++ have been used to access the DLL so far. The first function of any ICIS application is to establish the ODBC data connections for the current session.  To do this it must read the ODBC data source names from an INI file.  The default file is called ICIS.INI.  An application initially looks for ICIS.INI in the WINDOWS&nbsp;%TEMP% directory (the name of this directory is stored in the environment variable temp), unless a parameter is passed together when an application is called.  The parameter to use a different INI file should contain the full pathname of the INI file to use.  The structure of ICIS.INI files is defined in 5.3.1, but new applications may require new sections in the file.  These sections should be headed by the application name and will be ignored by other applications.  Since several users and projects may wish to access different data sources on the same computer a system of replacing ICIS.INI for each session has been established through the LAUNCHER application (5.3). The second function of any application is to identify the user and verify his or her access privileges.
</p>
<a name="Data_Source_Names_and_the_INI_file" id="Data_Source_Names_and_the_INI_file"></a><h4> <span class="mw-headline">Data Source Names and the INI file</span></h4>
<p>Access to ICIS databases is provided through the ICIS DLL described in this chapter.  Functions in this DLL use ODBC to access the data in the Central and Local databases.  These must therefore be defined as ODBC data sources before ICIS applications will operate.  Steps to set up the sources are described in 5.2.3b. The ICIS DLL obtains information from an initialization file.  This file must exist  before applications will run, the application passes the name of the INI file to the DLL, but for general applications this name should be ICIS.INI.
</p>
<a name="Return_values_for_ICIS_DLL_functions" id="Return_values_for_ICIS_DLL_functions"></a><h4> <span class="mw-headline">Return values for ICIS DLL functions</span></h4>
<p>Most DLL functions return a long integer value which are: GMS_SUCCESS if the function call was successful, GMS_ERROR if the function call results in an error, GMS_NO_DATA if no data is found in the databases relevant to a particular call or GMS_NOACCESS if the ICIS user does not have access to the particular function being called.  Some functions return other values to indicate different events.  These are described in the function descriptions.  Note: When making DLL function calls, always initialize character arguments to null prior to calling the function.  If this is not done each and every time, errors may occur or you may accidentally filter your results.
</p><p><br />
GMS FUNCTIONS return value
</p>
<table border="1" cellpadding="2">
<tr>
<th>Return Code
</th><th>Value
</th></tr>
<tr>
<td>GMS_NO_DATA
</td><td>0
</td></tr>
<tr>
<td>GMS_SUCCESS
</td><td> 1
</td></tr>
<tr>
<td>GMS_ERROR
</td><td> -1
</td></tr>
<tr>
<td>GMS_NO_ACCESS
</td><td> -2
</td></tr>
<tr>
<td>GMS_INVALID_PASSWORD
</td><td> -3
</td></tr>
<tr>
<td>GMS_INVALID_USER
</td><td> -4
</td></tr>
<tr>
<td>GMS_NAME_EXISTS
</td><td> -5
</td></tr>
<tr>
<td>GMS_NOT_FOUND
</td><td> -6
</td></tr>
<tr>
<td> GMS_MORE_DATA
</td><td> -7
</td></tr>
<tr>
<td>GMS_READ_ONLY
</td><td> -8
</td></tr>
<tr>
<td>GMS_INVALID_INSTALLATION
</td><td> -9
</td></tr>
<tr>
<td>GMS_INVALID_DBSTRUCTURE
</td><td> -10
</td></tr></table>
<a name="ICIS_Data_Structures" id="ICIS_Data_Structures"></a><h2> <span class="mw-headline"> ICIS Data Structures </span></h2>
<a name="Introduction_2" id="Introduction_2"></a><h3> <span class="mw-headline">Introduction</span></h3>
<p>Several compound structures are used to pass information between the DLL and the application. Users may specify their own names for elements in the structures, but not their order data types. However we recommend using the field names supplied to ensure uniformity across applications. 
</p><p>The structures are defined in the following tables. The data type long is a 4-byte signed integer, the type double is an 8-byte real and the type single is a 4-byte real or float data type. Character or string elements are denoted char [n] where n is the length of the element in bytes. All character variables are NULL terminated strings so one byte will be used for the NULL character. 
</p><p>The size of elements in the structures is larger than the space allocated to corresponding fields in the database.  This facilitates data transfer to the DLL by accommodating the NULL termination character for character variables and by ensuring data alignment in most programming languages.  However, care must be taken that data passed to the database through the structures is not too large for the database fields.
</p><p>ICIS DATA TYPES
</p>
<table border="1" cellpadding="2">
<tr>
<th>Data Type
</th><th>Size in bytes
</th></tr>
<tr>
<td>Double
</td><td>8
</td></tr>
<tr>
<td>single or float
</td><td>4
</td></tr>
<tr>
<td>Long
</td><td>4
</td></tr>
<tr>
<td>char[n] (including null character)
</td><td>n
</td></tr></table>
<p><br />
</p>
<a name="GMS_DATA_STRUCTURES" id="GMS_DATA_STRUCTURES"></a><h3> <span class="mw-headline">GMS DATA STRUCTURES </span></h3>
<a name="GMS_Germplasm_structure_.28in_order_of_declaration.29" id="GMS_Germplasm_structure_.28in_order_of_declaration.29"></a><h4> <span class="mw-headline">GMS_Germplasm structure (in order of declaration)</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>GERMPLASM_ID
</td><td>long
</td><td>GID
</td></tr>
<tr>
<td>METHOD
</td><td>long
</td><td>METHNO
</td></tr>
<tr>
<td>NO_PROGENITORS
</td><td>long
</td><td>GNPGS
</td></tr>
<tr>
<td>PROGENITOR_ID1
</td><td>long
</td><td>GPID1
</td></tr>
<tr>
<td>PROGENITOR_ID2
</td><td>long
</td><td>GPID2
</td></tr>
<tr>
<td>USER
</td><td>long
</td><td>GERMUID
</td></tr>
<tr>
<td>LOCAL_GID
</td><td>long
</td><td>LGID
</td></tr>
<tr>
<td>LOCATION
</td><td>long
</td><td>LOCNO
</td></tr>
<tr>
<td>DATE
</td><td>long
</td><td>GDATE
</td></tr>
<tr>
<td>REFERENCE
</td><td>long
</td><td>GREF
</td></tr>
<tr>
<td>REPLACE
</td><td>long
</td><td>GRPLCE
</td></tr>
<tr>
<td>MANAGEMENT_GID
</td><td>long
</td><td>MGID
</td></tr></table>
<a name="GMS_NameData_structure" id="GMS_NameData_structure"></a><h4> <span class="mw-headline">GMS_NameData structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>NAME_IDENTIFIER
</td><td>long
</td><td>NNID
</td></tr>
<tr>
<td>GERMPLASM_ID
</td><td>long
</td><td>GID
</td></tr>
<tr>
<td>NAME_TYPE
</td><td>long
</td><td>NTYPE
</td></tr>
<tr>
<td>STATUS
</td><td>long
</td><td>NSTATUS
</td></tr>
<tr>
<td>USER
</td><td>long
</td><td>NUID
</td></tr>
<tr>
<td>LOCATION
</td><td>long
</td><td>NLOCNO
</td></tr>
<tr>
<td>DATE
</td><td>long
</td><td>NDATE
</td></tr>
<tr>
<td>REFERENCE
</td><td>long
</td><td>NREF
</td></tr></table>
<a name="GMS_Attribute_structure" id="GMS_Attribute_structure"></a><h4> <span class="mw-headline">GMS_Attribute structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>AID
</td><td>long
</td><td>Attribute identifier
</td></tr>
<tr>
<td>GERMPLASM
</td><td>long
</td><td>GERMPLASM_ID
</td></tr>
<tr>
<td>TYPE
</td><td>long
</td><td>ATTRIBUTE_TYPE
</td></tr>
<tr>
<td>USER
</td><td>long
</td><td>ATTRIBUTE_USER_ID
</td></tr>
<tr>
<td>LOCATION
</td><td>long
</td><td>ATTRIBUTE_LOCATION_NO
</td></tr>
<tr>
<td>DATE
</td><td>long
</td><td>ATTRIBUTE_DATE
</td></tr>
<tr>
<td>REFERENCE
</td><td>long
</td><td>NAME_REFERENCE
</td></tr></table>
<p><br />
</p>
<a name="GMS_Method_structure" id="GMS_Method_structure"></a><h4> <span class="mw-headline">GMS_Method structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>METHOD_ID
</td><td>long
</td><td>METHOD_ID
</td></tr>
<tr>
<td>REFERENCE
</td><td>long
</td><td>METHOD_REFERENCE
</td></tr>
<tr>
<td>NO_PROGENITORS
</td><td>long
</td><td>NO_PROG_REQUIRED
</td></tr>
<tr>
<td>NO_MATERNAL
</td><td>long
</td><td>NO_FEMALE_PARENTS
</td></tr>
<tr>
<td>ATTRIBUTE
</td><td>long
</td><td>METHOD_ATTRIBUTE
</td></tr>
<tr>
<td>TYPE
</td><td>char[4]
</td><td>METHOD_TYPE
</td></tr>
<tr>
<td>CODE
</td><td>char[12]
</td><td>METHOD_CODE
</td></tr>
<tr>
<td>NAME
</td><td>char[52]
</td><td>METHOD_NAME
</td></tr>
<tr>
<td>GROUP
</td><td>char[4]
</td><td>METHOD_GROUP
</td></tr>
<tr>
<td>GENEQ
</td><td>long
</td><td>GENETIC_EQUIVALENCE
</td></tr>
<tr>
<td>MUID
</td><td>long
</td><td>METHOD_USER
</td></tr>
<tr>
<td>LMID
</td><td>long
</td><td>LOCAL_METHOD_ID
</td></tr>
<tr>
<td>MDATE
</td><td>long
</td><td>METHOD_DATE
</td></tr></table>
<p><br />
</p>
<a name="GMS_UDField_structure" id="GMS_UDField_structure"></a><h4> <span class="mw-headline">GMS_UDField structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>UDFIELD_ID
</td><td>long
</td><td>FLDNO
</td></tr>
<tr>
<td>TABLE
</td><td>char[28]
</td><td>FTABLE
</td></tr>
<tr>
<td>TYPE
</td><td>char[16]
</td><td>FTYPE
</td></tr>
<tr>
<td>CODE
</td><td>char[12]
</td><td>FCODE
</td></tr>
<tr>
<td>NAME
</td><td>char[52]
</td><td>FNAME
</td></tr>
<tr>
<td>FORMAT
</td><td>char[256]
</td><td>FFMT
</td></tr>
<tr>
<td>LFLDNO
</td><td>long
</td><td>LFLDNO
</td></tr>
<tr>
<td>FUID
</td><td>long
</td><td>FUID
</td></tr>
<tr>
<td>FDATE
</td><td>long
</td><td>FDATE
</td></tr>
<tr>
<td>SCALEID
</td><td>long
</td><td>SCALEID
</td></tr></table>
<a name="GMS_Changes_Structure" id="GMS_Changes_Structure"></a><h4> <span class="mw-headline">GMS_Changes Structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>CID
</td><td>long
</td><td>CID
</td></tr>
<tr>
<td>CRECORD
</td><td>long
</td><td>CRECORD
</td></tr>
<tr>
<td>CFROM
</td><td>long
</td><td>CFROM
</td></tr>
<tr>
<td>CTO
</td><td>long
</td><td>CTO
</td></tr>
<tr>
<td>CDATE
</td><td>long
</td><td>CDATE
</td></tr>
<tr>
<td>CTIME
</td><td>long
</td><td>CTIME
</td></tr>
<tr>
<td>CUID
</td><td>long
</td><td>CUID
</td></tr>
<tr>
<td>CREF
</td><td>long
</td><td>CREF
</td></tr>
<tr>
<td>CTABLE
</td><td>char[16]
</td><td>CTABLE
</td></tr>
<tr>
<td>CFIELD
</td><td>char[16]
</td><td>CFIELD
</td></tr>
<tr>
<td>CGROUP
</td><td>char[20]
</td><td>CGROUP
</td></tr></table>
<a name="GMS_User_structure" id="GMS_User_structure"></a><h4> <span class="mw-headline">GMS_User structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>USER_ID
</td><td>long
</td><td>USER_ID
</td></tr>
<tr>
<td>INSTALLATION
</td><td>long
</td><td>INSTALLATION
</td></tr>
<tr>
<td>STATUS
</td><td>integer
</td><td>USER_STATUS
</td></tr>
<tr>
<td>ACCESS
</td><td>long
</td><td>USER_ACCESS
</td></tr>
<tr>
<td>TYPE
</td><td>char[32]
</td><td>USER_TYPE
</td></tr>
<tr>
<td>NAME
</td><td>char[32]
</td><td>USER_NAME
</td></tr>
<tr>
<td>PASSWORD
</td><td>char[12]
</td><td>USER_PASSWORD
</td></tr>
<tr>
<td>PERSON
</td><td>long
</td><td>PERSON_ID
</td></tr>
<tr>
<td>ASSIGN_DATE
</td><td>long
</td><td>ASSIGN_DATE
</td></tr>
<tr>
<td>CLOSE_DATE
</td><td>long
</td><td>CLOSE_DATE
</td></tr></table>
<p><br />
</p>
<a name="GMS_Installation_Structure" id="GMS_Installation_Structure"></a><h4> <span class="mw-headline">GMS_Installation Structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th width="35%">Element name
</th><th width="25%">Type
</th><th width="40%">Database Field Name
</th></tr>
<tr>
<td>INSTALLATION
</td><td>long
</td><td>INSTALLATION_NO
</td></tr>
<tr>
<td>ADMINISTRATOR
</td><td>long
</td><td>ADMIN_USER_ID
</td></tr>
<tr>
<td>UDATE
</td><td>long
</td><td>UPDATE_DATE
</td></tr>
<tr>
<td>UGID
</td><td>long
</td><td>UPDATE_GID
</td></tr>
<tr>
<td>ULOCN
</td><td>long
</td><td>UPDATE_LOCN
</td></tr>
<tr>
<td>UMETHN
</td><td>long
</td><td>UPDATE_METHN
</td></tr>
<tr>
<td>UFLDNO
</td><td>long
</td><td>UPDATE_FLDNO
</td></tr>
<tr>
<td>UREFNO
</td><td>long
</td><td>UPDATE_REFNO
</td></tr>
<tr>
<td>UPID
</td><td>long
</td><td>UPDATE_PID
</td></tr></table>
<a name="LIST_DATA_STRUCTURE" id="LIST_DATA_STRUCTURE"></a><h3> <span class="mw-headline">LIST DATA STRUCTURE</span></h3>
<a name="GMS_ListName_Structure" id="GMS_ListName_Structure"></a><h4> <span class="mw-headline">GMS_ListName Structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th width="35%">Element name
</th><th width="25%">Type
</th><th width="40%">Database Field Name
</th></tr>
<tr>
<td>LISTID
</td><td>long
</td><td>LISTID
</td></tr>
<tr>
<td>LISTNAME
</td><td>char[48]
</td><td>LISTNAME
</td></tr>
<tr>
<td>LISTDATE
</td><td>long
</td><td>LISTDATE
</td></tr>
<tr>
<td>LISTTYPE
</td><td>char[8]
</td><td>LISTTYPE
</td></tr>
<tr>
<td>LISTUID
</td><td>long
</td><td>LISTUID
</td></tr>
<tr>
<td>LISTDESC
</td><td>char[80]
</td><td>LISTDESC
</td></tr>
<tr>
<td>LISTSTATUS
</td><td>long
</td><td>LIST_STATUS
</td></tr>
<tr>
<td>LISTHIER
</td><td>long
</td><td>LIST_HIERARCHY
</td></tr></table>
<a name="GMS_ListData_Structure" id="GMS_ListData_Structure"></a><h4> <span class="mw-headline">GMS_ListData Structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th width="35%">Element name
</th><th width="25%">Type
</th><th width="40%">Database Field Name
</th></tr>
<tr>
<td>LISTID
</td><td>Long
</td><td>LISTID
</td></tr>
<tr>
<td>GID
</td><td>Long
</td><td>GID
</td></tr>
<tr>
<td>LRECID
</td><td>Long
</td><td>LRECID
</td></tr>
<tr>
<td>ENTRYCD
</td><td>char[48]
</td><td>ENTRYCD
</td></tr>
<tr>
<td>SOURCE
</td><td>char[48]
</td><td>SOURCE
</td></tr>
<tr>
<td>DESIG
</td><td>char[256]
</td><td>DESIG
</td></tr>
<tr>
<td>GRPNAME
</td><td>char[256]
</td><td>GRPNAME
</td></tr>
<tr>
<td>ENTRYID
</td><td>Long
</td><td>ENTRYID
</td></tr></table>
<a name="LMS_Data_Structure" id="LMS_Data_Structure"></a><h3> <span class="mw-headline">LMS Data Structure</span></h3>
<a name="GMS_Location_structure" id="GMS_Location_structure"></a><h5> <span class="mw-headline">GMS_Location structure</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="94%">
<tr>
<td><b>Element name</b>
</td><td><b>Type</b>
</td><td><b>Database Field Name (Table 4.3.1)</b>
</td></tr>
<tr>
<td>LOCATION_ID
</td><td>long
</td><td>LOCATION_ID
</td></tr>
<tr>
<td>TYPE
</td><td>long
</td><td>LTYPE
</td></tr>
<tr>
<td>NLLP
</td><td>long
</td><td>NLLP
</td></tr>
<tr>
<td>PREFERRED_NAME
</td><td>char[64]
</td><td>PREFERRED_NAME
</td></tr>
<tr>
<td>ABBREVIATION
</td><td>char[12]
</td><td>ABBREVIATION
</td></tr>
<tr>
<td>SUBNAT_LEVEL3
</td><td>long
</td><td>SUBNAT_LEVEL3
</td></tr>
<tr>
<td>SUBNAT_LEVEL2
</td><td>long
</td><td>SUBNAT_LEVEL2
</td></tr>
<tr>
<td>SUBNAT_LEVEL1
</td><td>long
</td><td>SUBNAT_LEVEL1
</td></tr>
<tr>
<td>COUNTRY
</td><td>long
</td><td>COUNTRY_CODE
</td></tr>
<tr>
<td>REPLACE
</td><td>long
</td><td>LOCATION_REPLACE
</td></tr>
</table>
<a name="DMS_DATA_STRUCTURE" id="DMS_DATA_STRUCTURE"></a><h3> <span class="mw-headline">DMS DATA STRUCTURE</span></h3>
<a name="DMS_STUDY_Structure" id="DMS_STUDY_Structure"></a><h5> <span class="mw-headline">DMS_STUDY Structure</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="76%">
<tr>
<td><b>Element Name</b>
</td><td><b>Type</b>
</td><td><b>Database Field Name</b>
</td></tr>
<tr>
<td>STUDYID
</td><td>Long
</td><td>STUDYID
</td></tr>
<tr>
<td>STUDY_NAME
</td><td>Char[52]
</td><td>SNAME
</td></tr>
<tr>
<td>PROGRAM_KEY
</td><td>Long
</td><td>PMKEY
</td></tr>
<tr>
<td>TITLE
</td><td>Char[256]
</td><td>TITLE
</td></tr>
<tr>
<td>INVESTIGATOR_ID
</td><td>Long
</td><td>INVESTID
</td></tr>
<tr>
<td>STUDY_TYPE
</td><td>Char[2]
</td><td>STYPE
</td></tr>
<tr>
<td>START_DATE
</td><td>Long
</td><td>SDATE
</td></tr>
<tr>
<td>END_DATE
</td><td>Long
</td><td>EDATE
</td></tr>
<tr>
<td>USERID
</td><td>Long
</td><td>USERID
</td></tr></table>
<a name="DMS_FACTOR_Structure" id="DMS_FACTOR_Structure"></a><h5> <span class="mw-headline">DMS_FACTOR Structure</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="76%">
<tr>
<td><b>Element Name</b>
</td><td><b>Type</b>
</td><td><b>Database Field Name</b>
</td></tr>
<tr>
<td>LABELID
</td><td>Long
</td><td>LABELID
</td></tr>
<tr>
<td>FACTORID
</td><td>Long
</td><td>FACTORID
</td></tr>
<tr>
<td>FACTOR_NAME
</td><td>Char[52]
</td><td>FNAME
</td></tr>
<tr>
<td>STUDYID
</td><td>Long
</td><td>STUDYID
</td></tr>
<tr>
<td>TRAITID
</td><td>Long
</td><td>TRAITID
</td></tr>
<tr>
<td>SCALEID
</td><td>Long
</td><td>SCALEID
</td></tr>
<tr>
<td>METHOD_ID
</td><td>Long
</td><td>TMETHID
</td></tr>
<tr>
<td>LEVEL_TYPE
</td><td>Char[2]
</td><td>LTYPE
</td></tr>
</table>
<a name="DMS_VARIATE_Structure" id="DMS_VARIATE_Structure"></a><h5> <span class="mw-headline">DMS_VARIATE Structure</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="76%">
<tr>
<td><b>Element Name</b>
</td><td><b>Type</b>
</td><td><b>Database Field Name</b>
</td></tr>
<tr>
<td>VARIATID
</td><td>Long
</td><td>VARIATID
</td></tr>
<tr>
<td>VARIATE_NAME
</td><td>Char[52]
</td><td>VNAME
</td></tr>
<tr>
<td>VARIATE_TYPE
</td><td>Char[4]
</td><td>VTYPE
</td></tr>
<tr>
<td>STUDYID
</td><td>Long
</td><td>STUDYID
</td></tr>
<tr>
<td>TRAITID
</td><td>Long
</td><td>TRAITID
</td></tr>
<tr>
<td>SCALEID
</td><td>Long
</td><td>SCALEID
</td></tr>
<tr>
<td>METHOD_ID
</td><td>Long
</td><td>TMETHID
</td></tr>
<tr>
<td>DATA_TYPE
</td><td>Char[2]
</td><td>DTYPE
</td></tr>
</table>
<a name="DMS_DATAN_Structure" id="DMS_DATAN_Structure"></a><h5> <span class="mw-headline">DMS_DATAN Structure</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="76%">
<tr>
<td><b>Element Name</b>
</td><td><b>Type</b>
</td><td><b>Database Field Name</b>
</td></tr>
<tr>
<td>OBSERVATION_UNIT
</td><td>Long
</td><td>OUNITID
</td></tr>
<tr>
<td>VARIATID
</td><td>Long
</td><td>VARIATID
</td></tr>
<tr>
<td>DATA_VALUE
</td><td>Double
</td><td>DVALUE
</td></tr>
</table>
<a name="DMS_DATAC_Structure" id="DMS_DATAC_Structure"></a><h5> <span class="mw-headline">DMS_DATAC Structure</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="76%">
<tr>
<td><b>Element Name</b>
</td><td><b>Type</b>
</td><td><b>Database Field Name</b>
</td></tr>
<tr>
<td>OBSERVATION_UNIT
</td><td>Long
</td><td>OUNITID
</td></tr>
<tr>
<td>VARIATID
</td><td>Long
</td><td>VARIATID
</td></tr>
<tr>
<td>DATA_VALUE
</td><td>Char[256]
</td><td>DVALUE
</td></tr>
</table>
<a name="DMS_LEVELC_Structure" id="DMS_LEVELC_Structure"></a><h5> <span class="mw-headline">DMS_LEVELC Structure</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="76%">
<tr>
<td><b>Element Name</b>
</td><td><b>Type</b>
</td><td><b>Database Field Name</b>
</td></tr>
<tr>
<td>LABELID
</td><td>Long
</td><td>LABELID
</td></tr>
<tr>
<td>FACTORID
</td><td>Long
</td><td>FACTORID
</td></tr>
<tr>
<td>LEVELNO
</td><td>Long
</td><td>LEVELNO
</td></tr>
<tr>
<td>LEVEL_VALUE
</td><td>Char[256]
</td><td>LVALUE
</td></tr>
</table>
<a name="DMS_LEVELN_Structure" id="DMS_LEVELN_Structure"></a><h5> <span class="mw-headline">DMS_LEVELN Structure</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="76%">
<tr>
<td><b>Element Name</b>
</td><td><b>Type</b>
</td><td><b>Database Field Name</b>
</td></tr>
<tr>
<td>LABELID
</td><td>Long
</td><td>LABELID
</td></tr>
<tr>
<td>FACTORID
</td><td>Long
</td><td>FACTORID
</td></tr>
<tr>
<td>LEVELNO
</td><td>Long
</td><td>LEVELNO
</td></tr>
<tr>
<td>LEVEL_VALUE
</td><td>Double
</td><td>LVALUE
</td></tr>
</table>
<a name="EFFECT_Structure" id="EFFECT_Structure"></a><h5> <span class="mw-headline">EFFECT Structure</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="76%">
<tr>
<td><b>Element Name</b>
</td><td><b>Type</b>
</td><td><b>Database Field Name</b>
</td></tr>
<tr>
<td>REPRESENTATION_NO
</td><td>Long
</td><td>REPRESNO
</td></tr>
<tr>
<td>FACTORID
</td><td>Long
</td><td>FACTORID
</td></tr>
<tr>
<td>EFFECTID
</td><td>Long
</td><td>EFFECTID
</td></tr>
</table>
<a name="DMS_VEFFECT" id="DMS_VEFFECT"></a><h5> <span class="mw-headline">DMS_VEFFECT</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="76%">
<tr>
<td><b>Element Name</b>
</td><td><b>Type</b>
</td><td><b>Database Field Name</b>
</td></tr>
<tr>
<td>REPRESENTATION_NO
</td><td>Long
</td><td>REPRESNO
</td></tr>
<tr>
<td>VARIATID
</td><td>Long
</td><td>VARIATID
</td></tr>
</table>
<a name="DMS_OINDEX_Structure" id="DMS_OINDEX_Structure"></a><h5> <span class="mw-headline">DMS_OINDEX Structure</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="76%">
<tr>
<td><b>Element Name</b>
</td><td><b>Type</b>
</td><td><b>Database Field Name</b>
</td></tr>
<tr>
<td>OUNITID
</td><td>Long
</td><td>OUNITID
</td></tr>
<tr>
<td>FACTORID
</td><td>Long
</td><td>FACTORID
</td></tr>
<tr>
<td>LEVELNO
</td><td>Long
</td><td>LEVELNO
</td></tr>
</table>
<a name="DMS_TRAIT_Structure" id="DMS_TRAIT_Structure"></a><h5> <span class="mw-headline">DMS_TRAIT Structure</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="76%">
<tr>
<td><b>Element Name</b>
</td><td><b>Type</b>
</td><td><b>Database Field Name</b>
</td></tr>
<tr>
<td>TID
</td><td>Long
</td><td>TID
</td></tr>
<tr>
<td>TRAITID
</td><td>Long
</td><td>TRAITID
</td></tr>
<tr>
<td>TRAIT_NAME
</td><td>Char[52]
</td><td>TRNAME
</td></tr>
<tr>
<td>TRAIT_ABBR
</td><td>Char[8]
</td><td>TRABBR
</td></tr>
<tr>
<td>TR_NAME_STAT
</td><td>Long
</td><td>TNSTAT
</td></tr>
<tr>
<td>SCALEID
</td><td>Long
</td><td>SCALEID
</td></tr>
<tr>
<td>METHOD_ID
</td><td>Long
</td><td>TMETHID
</td></tr>
</table>
<a name="DMS_SCALE_Structure" id="DMS_SCALE_Structure"></a><h5> <span class="mw-headline">DMS_SCALE Structure</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="76%">
<tr>
<td><b>Element Name</b>
</td><td><b>Type</b>
</td><td><b>Database Field Name</b>
</td></tr>
<tr>
<td>SCALEID
</td><td>Long
</td><td>SCALEID
</td></tr>
<tr>
<td>TRAITID
</td><td>Long
</td><td>TRAITID
</td></tr>
<tr>
<td>SCALE_NAME
</td><td>Char[32]
</td><td>SCNAME
</td></tr>
<tr>
<td>SCALE_TYPE
</td><td>Char[2]
</td><td>SCTYPE
</td></tr>
</table>
<a name="DMS_TMETHOD_Structure" id="DMS_TMETHOD_Structure"></a><h5> <span class="mw-headline">DMS_TMETHOD Structure</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="76%">
<tr>
<td><b>Element Name</b>
</td><td><b>Type</b>
</td><td><b>Database Field Name</b>
</td></tr>
<tr>
<td>METHOD_ID
</td><td>Long
</td><td>TMETHID
</td></tr>
<tr>
<td>TRAITID
</td><td>Long
</td><td>TRAITID
</td></tr>
<tr>
<td>METHOD_NAME
</td><td>Char[52]
</td><td>TMNAME
</td></tr>
<tr>
<td>METHOD_ABBR
</td><td>Char[8]
</td><td>TMABBR
</td></tr>
</table>
<a name="DMS_SCALECON" id="DMS_SCALECON"></a><h5> <span class="mw-headline">DMS_SCALECON</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="76%">
<tr>
<td><b>Element Name</b>
</td><td><b>Type</b>
</td><td><b>Database Field Name</b>
</td></tr>
<tr>
<td>SCALEID
</td><td>Long
</td><td>SCALEID
</td></tr>
<tr>
<td>SLEVEL
</td><td>Long
</td><td>SLEVEL
</td></tr>
<tr>
<td>ELEVEL
</td><td>Long
</td><td>ELEVEL
</td></tr>
</table>
<a name="DMS_SCALEDIS" id="DMS_SCALEDIS"></a><h5> <span class="mw-headline">DMS_SCALEDIS</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="76%">
<tr>
<td><b>Element Name</b>
</td><td><b>Type</b>
</td><td><b>Database Field Name</b>
</td></tr>
<tr>
<td>SCALEID
</td><td>Long
</td><td>SCALEI
</td></tr>
<tr>
<td>VALUE
</td><td>Char[24]
</td><td>VALUE
</td></tr>
<tr>
<td>VALDESC
</td><td>Char[256]
</td><td>VALDESC
</td></tr>
</table>
<a name="DMS_NumVALUE_Structure" id="DMS_NumVALUE_Structure"></a><h5> <span class="mw-headline">DMS_NumVALUE Structure</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="52%">
<tr>
<td><b>          Element Name</b>
</td><td><b>Type</b>
</td></tr>
<tr>
<td>ounitid
</td><td>Long
</td></tr>
<tr>
<td>traitid
</td><td>Long
</td></tr>
<tr>
<td>scaleid
</td><td>Long
</td></tr>
<tr>
<td>tmethid
</td><td>Long
</td></tr>
<tr>
<td>nvalue
</td><td>Double
</td></tr>
</table>
<a name="DMS_CharVALUE_Structure" id="DMS_CharVALUE_Structure"></a><h5> <span class="mw-headline">DMS_CharVALUE Structure</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="52%">
<tr>
<td><b>Element Name</b>
</td><td><b>Type</b>
</td></tr>
<tr>
<td>ounitid
</td><td>Long
</td></tr>
<tr>
<td>traitid
</td><td>Long
</td></tr>
<tr>
<td>scaleid
</td><td>Long
</td></tr>
<tr>
<td>tmethid
</td><td>Long
</td></tr>
<tr>
<td>cvalue
</td><td>Char[256]
</td></tr>
</table>
<a name="Source" id="Source"></a><h5> <span class="mw-headline">Source</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="52%">
<tr>
<td><b>Element Name</b>
</td><td><b>Type</b>
</td></tr>
<tr>
<td>factorid
</td><td>Long
</td></tr>
<tr>
<td>levelno
</td><td>Long
</td></tr>
</table>
<a name="DMS_DMSATTR" id="DMS_DMSATTR"></a><h5> <span class="mw-headline">DMS_DMSATTR</span></h5>
<table border="2" cellspacing="0" cellpadding="4" width="73%">
<tr>
<td><b>Element Name</b>
</td><td><b>Type</b>
</td><td><b>Database Field Name</b>
</td></tr>
<tr>
<td>ATTRIBUTE_ID
</td><td>Long
</td><td>DMSATID
</td></tr>
<tr>
<td>ATTRIBUTE_TYPE
</td><td>Long
</td><td>DMSATYPE
</td></tr>
<tr>
<td>TABLE_NAME
</td><td>Long
</td><td>DMSATAB
</td></tr>
<tr>
<td>RECORDID_IN_TABLE
</td><td>Long
</td><td>DMSATREC
</td></tr>
</table>
<p><br />
</p>
<a name="IMS_DATA_STRUCTURES" id="IMS_DATA_STRUCTURES"></a><h3> <span class="mw-headline">IMS DATA STRUCTURES</span></h3>
<a name="IMS_LOT_Structure" id="IMS_LOT_Structure"></a><h4> <span class="mw-headline">IMS_LOT Structure</span></h4>
<table border="2" cellspacing="0" cellpadding="4" width="83%">
<tr>
<td align="justify"><b>Element Name</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Database Field Name</b>
</td></tr>
<tr>
<td align="justify">LOTID
</td><td align="justify">Long
</td><td align="justify">LOTID
</td></tr>
<tr>
<td align="justify">LOTUSER
</td><td align="justify">long
</td><td align="justify">USERID
</td></tr>
<tr>
<td align="justify">ETYPE
</td><td align="justify">Char[16]
</td><td align="justify">ETYPE
</td></tr>
<tr>
<td align="justify">EID
</td><td align="justify">Long
</td><td align="justify">EID
</td></tr>
<tr>
<td align="justify">LOCID
</td><td align="justify">Long
</td><td align="justify">LOCID
</td></tr>
<tr>
<td align="justify">SCALE
</td><td align="justify">Long
</td><td align="justify">SCALEID
</td></tr>
<tr>
<td align="justify">STATUS
</td><td align="justify">Long
</td><td align="justify">STATUS
</td></tr>
<tr>
<td align="justify">SOURCEID
</td><td align="justify">Long
</td><td align="justify">SOURCEID
</td></tr>
<tr>
<td align="justify">COMMENTS
</td><td align="justify">Char[256]
</td><td align="justify">COMMENTS
</td></tr>
</table>
<a name="IMS_TRANSACTION_Structure" id="IMS_TRANSACTION_Structure"></a><h4> <span class="mw-headline">IMS_TRANSACTION Structure</span></h4>
<table border="2" cellspacing="0" cellpadding="4" width="83%">
<tr>
<td align="justify"><b>Element Name</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Database Field Name</b>
</td></tr>
<tr>
<td align="justify">TRNID
</td><td align="justify">Long
</td><td align="justify">TRNID
</td></tr>
<tr>
<td align="justify">TRNUSER
</td><td align="justify">Long
</td><td align="justify">USERID
</td></tr>
<tr>
<td align="justify">LOTID
</td><td align="justify">Long
</td><td align="justify">LOTID
</td></tr>
<tr>
<td align="justify">TRNDATE
</td><td align="justify">Long
</td><td align="justify">TRNDATE
</td></tr>
<tr>
<td align="justify">TRNSTAT
</td><td align="justify">Long
</td><td align="justify">TRNSTAT
</td></tr>
<tr>
<td align="justify">CMTDATE
</td><td align="justify">Long
</td><td align="justify">CMTDATE
</td></tr>
<tr>
<td align="justify">COMMENTS
</td><td align="justify">Char[256]
</td><td align="justify">COMMENTS
</td></tr>
<tr>
<td align="justify">TRNQTY
</td><td align="justify">Double
</td><td align="justify">TRNQTY
</td></tr>
<tr>
<td align="justify">PREVAMOUNT
</td><td align="justify">Double
</td><td align="justify">PREVAMOUNT
</td></tr>
<tr>
<td align="justify">SOURCETYPE
</td><td align="justify">Char[12]
</td><td align="justify">SOURCETYPE
</td></tr>
<tr>
<td align="justify">SOURCEID
</td><td align="justify">Long
</td><td align="justify">SOURCEID
</td></tr>
<tr>
<td align="justify">RECORDID
</td><td align="justify">Long
</td><td align="justify">RECORDID
</td></tr>
</table>
<a name="BIBREF_DATA_STRUCTURE" id="BIBREF_DATA_STRUCTURE"></a><h3> <span class="mw-headline">BIBREF DATA STRUCTURE</span></h3>
<table border="2" cellspacing="0" cellpadding="4" width="94%">
<tr>
<td><b>Element name</b>
</td><td><b>Type</b>
</td><td><b>Database Field Name (Table 3.8.4)</b>
</td></tr>
<tr>
<td>REFID
</td><td>long
</td><td>REFID
</td></tr>
<tr>
<td>PUBTYPE
</td><td>long
</td><td>PUBLICATION_TYPE
</td></tr>
<tr>
<td>PUBDATE
</td><td>long
</td><td>PUBLICATION_DATE
</td></tr>
<tr>
<td>AUTHORS
</td><td>Char[100]
</td><td>AUTHOR_NAME
</td></tr>
<tr>
<td>EDITORS
</td><td>Char[100]
</td><td>EDITOR_NAME
</td></tr>
<tr>
<td>ANALYT
</td><td>Char[255]
</td><td>ANALYT
</td></tr>
<tr>
<td>MONOG
</td><td>Char[255]
</td><td>MONOG
</td></tr>
<tr>
<td>SERIES
</td><td>Char[255]
</td><td>SERIES
</td></tr>
<tr>
<td>VOLUME
</td><td>Char[10]
</td><td>VOLUME
</td></tr>
<tr>
<td>ISSUE
</td><td>Char[10]
</td><td>ISSUE
</td></tr>
<tr>
<td>PAGECOL
</td><td>Char[25]
</td><td>PAGECOL
</td></tr>
<tr>
<td>PUBLISH
</td><td>Char[50]
</td><td>PUBLISH
</td></tr>
<tr>
<td>PUBCITY
</td><td>Char[30]
</td><td>PUBCITY
</td></tr>
<tr>
<td>PUBCNTRY
</td><td>Char[75]
</td><td>PUBCNTRY
</td></tr>
</table>
<p><br />
</p>
<a name="GEMS_DATA_STRUCTURE" id="GEMS_DATA_STRUCTURE"></a><h3> <span class="mw-headline">GEMS DATA STRUCTURE</span></h3>
<a name="GEMS_INFO_structure" id="GEMS_INFO_structure"></a><h4> <span class="mw-headline">GEMS_INFO structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>GOBJID
</td><td>LONG
</td><td>GOBJID
</td></tr>
<tr>
<td>GNVAL
</td><td>CHAR[256]
</td><td>GNVAL
</td></tr>
<tr>
<td>GOBJTYPE
</td><td>CHAR[256]
</td><td>GOBJTYPE
</td></tr>
<tr>
<td>MARKERID
</td><td>LONG
</td><td>MARKERID
</td></tr></table>
<p><br />
</p>
<a name="GEMS_MARKER_DETECTOR_structure" id="GEMS_MARKER_DETECTOR_structure"></a><h4> <span class="mw-headline">GEMS_MARKER_DETECTOR structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>MDID
</td><td>LONG
</td><td>MDID
</td></tr>
<tr>
<td>MATYPE
</td><td>CHAR[256]
</td><td>MATYPE
</td></tr>
<tr>
<td>FPRIMER
</td><td>CHAR[256]
</td><td>FPRIMER
</td></tr>
<tr>
<td>RPRIMER
</td><td>CHAR[256]
</td><td>RPRIMER
</td></tr>
<tr>
<td>LMID
</td><td>LONG
</td><td>MARKERID
</td></tr>
<tr>
<td>MAUID
</td><td>LONG
</td><td>MAUID
</td></tr>
<tr>
<td>MAREF
</td><td>LONG
</td><td>MAREF
</td></tr>
<tr>
<td>MINALLELE
</td><td>LONG
</td><td>MINALLELE
</td></tr>
<tr>
<td>MAXALLELE
</td><td>LONG
</td><td>MAXALLELE
</td></tr></table>
<p><br />
</p>
<a name="GEMS_MV_structure" id="GEMS_MV_structure"></a><h4> <span class="mw-headline">GEMS_MV structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>MVID
</td><td>LONG
</td><td>MVID
</td></tr>
<tr>
<td>MARKERID
</td><td>LONG
</td><td>MARKERID
</td></tr>
<tr>
<td>MVTYPE
</td><td>LONG
</td><td>MVTYPE
</td></tr>
<tr>
<td>MWT
</td><td>DOUBLE
</td><td>MWT
</td></tr>
<tr>
<td>MDID
</td><td>LONG
</td><td>MDID
</td></tr>
<tr>
<td>LMVID
</td><td>LONG
</td><td>LMVID
</td></tr>
<tr>
<td>MVUID
</td><td>LONG
</td><td>MVUID
</td></tr>
<tr>
<td>MVREF
</td><td>LONG
</td><td>MVREF
</td></tr></table>
<p><br />
</p>
<a name="GEMS_NAME_structure" id="GEMS_NAME_structure"></a><h4> <span class="mw-headline">GEMS_NAME structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>GNID
</td><td>LONG
</td><td>GNID
</td></tr>
<tr>
<td>GOBJID
</td><td>LONG
</td><td>GOBJID
</td></tr>
<tr>
<td>GOBJTYPE
</td><td>CHAR[256]
</td><td>GOBJTYPE
</td></tr>
<tr>
<td>GNTYPE
</td><td>LONG
</td><td>GNTYPE
</td></tr>
<tr>
<td>GNSTAT
</td><td>LONG
</td><td>GNSTAT
</td></tr>
<tr>
<td>GNUID
</td><td>LONG
</td><td>GNUID
</td></tr>
<tr>
<td>GNVAL
</td><td>CHAR(256)
</td><td>GNVAL
</td></tr>
<tr>
<td>GNLOCN
</td><td>LONG
</td><td>GNLOCN
</td></tr>
<tr>
<td>GNDATE
</td><td>LONG
</td><td>GNDATE
</td></tr>
<tr>
<td>GNREF
</td><td>LONG
</td><td>GNREF
</td></tr></table>
<a name="GEMS_COMPONENT_structure" id="GEMS_COMPONENT_structure"></a><h4> <span class="mw-headline">GEMS_COMPONENT structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>CID
</td><td>LONG
</td><td>CID
</td></tr>
<tr>
<td>CONDID
</td><td>LONG
</td><td>CONDID
</td></tr>
<tr>
<td>COMID
</td><td>LONG
</td><td>COMID
</td></tr>
<tr>
<td>COMVAL
</td><td>CHAR(256])
</td><td>GNTYPE
</td></tr>
<tr>
<td>PID
</td><td>LONG
</td><td>PID
</td></tr>
<tr>
<td>COMTYPE
</td><td>CHAR(256)
</td><td>COMTYPE
</td></tr>
<tr>
<td>COMGRP
</td><td>CHAR(256)
</td><td>COMGRP
</td></tr>
<tr>
<td>COMUID
</td><td>LONG
</td><td>COMUID
</td></tr>
<tr>
<td>COMREF
</td><td>LONG
</td><td>COMREF
</td></tr></table>
<p><br />
</p>
<a name="GEMS_PD_COMP_structure" id="GEMS_PD_COMP_structure"></a><h4> <span class="mw-headline">GEMS_PD_COMP structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>PD_COMP
</td><td>LONG
</td><td>PD_COMP
</td></tr>
<tr>
<td>PDID
</td><td>LONG
</td><td>PDID
</td></tr>
<tr>
<td>CID
</td><td>LONG
</td><td>CID
</td></tr></table>
<a name="GEMS_PROP_structure" id="GEMS_PROP_structure"></a><h4> <span class="mw-headline">GEMS_PROP structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>PID
</td><td>LONG
</td><td>PID
</td></tr>
<tr>
<td>PROPID
</td><td>LONG
</td><td>PROPID
</td></tr>
<tr>
<td>PROPNAME
</td><td>CHAR(256)
</td><td>PROPNAME
</td></tr>
<tr>
<td>SCALEID
</td><td>LONG
</td><td>SCALEID
</td></tr>
<tr>
<td>METHID
</td><td>LONG
</td><td>METHID
</td></tr>
<tr>
<td>PROPGRP
</td><td>CHAR(256)
</td><td>PROPGRP
</td></tr></table>
<p><br />
</p>
<a name="GEMS_PD_structure" id="GEMS_PD_structure"></a><h4> <span class="mw-headline">GEMS_PD structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>PDID
</td><td>LONG
</td><td>PDID
</td></tr>
<tr>
<td>CONDID
</td><td>LONG
</td><td>CONDID
</td></tr>
<tr>
<td>MDID
</td><td>LONG
</td><td>MDID
</td></tr></table>
<p><br />
</p>
<a name="GEMS_CONDITION_structure" id="GEMS_CONDITION_structure"></a><h4> <span class="mw-headline">GEMS_CONDITION structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>CONID
</td><td>LONG
</td><td>CONID
</td></tr>
<tr>
<td>CONDNAME
</td><td>CHAR(256)
</td><td>CONDNAME
</td></tr></table>
<p><br />
</p>
<a name="PD_COMP_INFO_structure" id="PD_COMP_INFO_structure"></a><h4> <span class="mw-headline">PD_COMP_INFO structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>CID
</td><td>LONG
</td><td>CID
</td></tr>
<tr>
<td>CONDITION
</td><td>LONG
</td><td>CONDITION
</td></tr>
<tr>
<td>PDID
</td><td>LONG
</td><td>PDID
</td></tr></table>
<p><br />
</p>
<a name="GEMS_SCALE_structure" id="GEMS_SCALE_structure"></a><h4> <span class="mw-headline">GEMS_SCALE structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>SCALEID
</td><td>LONG
</td><td>SCALEID
</td></tr>
<tr>
<td>SCNAME
</td><td>CHAR(256)
</td><td>SCNAME
</td></tr>
<tr>
<td>PROPID
</td><td>LONG
</td><td>PROPID
</td></tr>
<tr>
<td>SCTYPE
</td><td>CHAR(256)
</td><td>SCTYPE
</td></tr></table>
<p><br />
</p>
<a name="GEMS_METHOD_structure" id="GEMS_METHOD_structure"></a><h4> <span class="mw-headline">GEMS_METHOD structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>METHID
</td><td>LONG
</td><td>METHID
</td></tr>
<tr>
<td>MNAME
</td><td>CHAR(256)
</td><td>MNAME
</td></tr>
<tr>
<td>MABBR
</td><td>CHAR(256)
</td><td>MABBR
</td></tr>
<tr>
<td>MDESC
</td><td>CHAR(256)
</td><td>MDESC
</td></tr></table>
<p><br />
</p>
<a name="PROP_INFO_structure" id="PROP_INFO_structure"></a><h4> <span class="mw-headline">PROP_INFO structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>PID
</td><td>LONG
</td><td>PID
</td></tr>
<tr>
<td>MNAME
</td><td>CHAR(256)
</td><td>MNAME
</td></tr>
<tr>
<td>SNAME
</td><td>CHAR(256)
</td><td>SNAME
</td></tr>
<tr>
<td>PNAME
</td><td>CHAR(256)
</td><td>PNAME
</td></tr>
<tr>
<td>PGRPNAME
</td><td>CHAR(256)
</td><td>PGRPNAME
</td></tr></table>
<p><br />
</p>
<a name="GEMS_LOCUS_structure" id="GEMS_LOCUS_structure"></a><h4> <span class="mw-headline">GEMS_LOCUS structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>LOCUSID
</td><td>LONG
</td><td>LOCUSID
</td></tr>
<tr>
<td>CHROMOSOME
</td><td>CHAR(256)
</td><td>CHROMOSOME
</td></tr>
<tr>
<td>POSITION
</td><td>CHAR(256)
</td><td>POSITION
</td></tr></table>
<a name="SUPPORTING_TABLES" id="SUPPORTING_TABLES"></a><h3> <span class="mw-headline"> SUPPORTING TABLES </span></h3>
<a name="SUP_PERSONS_structure" id="SUP_PERSONS_structure"></a><h4> <span class="mw-headline">SUP_PERSONS structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>PERSONID
</td><td>LONG
</td><td>PERSONID
</td></tr>
<tr>
<td>FNAME
</td><td>CHAR[24]
</td><td>FNAME
</td></tr>
<tr>
<td>LNAME
</td><td>CHAR[52]
</td><td>LNAME
</td></tr>
<tr>
<td>IONAME
</td><td>CHAR[16]
</td><td>IONAME
</td></tr>
<tr>
<td>INSTITID
</td><td>long
</td><td>INSTITID
</td></tr>
<tr>
<td>PTITLE
</td><td>CHAR[28]
</td><td>PTITLE
</td></tr>
<tr>
<td>PONAME
</td><td>char[52]
</td><td>PONAME
</td></tr>
<tr>
<td>PLANGU
</td><td>LONG
</td><td>PLANGU
</td></tr>
<tr>
<td>PPHONE
</td><td>CHAR[24]
</td><td>PPHONE
</td></tr>
<tr>
<td>PEXTENT
</td><td>CHAR[24]
</td><td>PEXTENT
</td></tr>
<tr>
<td>PFAX
</td><td>CHAR[24]
</td><td>PFAX
</td></tr>
<tr>
<td>PEMAIL
</td><td>CHAR[44]
</td><td>PEMAIL
</td></tr>
<tr>
<td>PROLE
</td><td>LONG
</td><td>PROLE
</td></tr>
<tr>
<td>SPERSON
</td><td>LONG
</td><td>SPERSON
</td></tr>
<tr>
<td>EPERSON
</td><td>LONG
</td><td>EPERSON
</td></tr>
<tr>
<td>PSTATUS
</td><td>LONG
</td><td>PSTATUS
</td></tr>
<tr>
<td>CONTACT
</td><td>CHAR[256]
</td><td>CONTACT
</td></tr></table>
<a name="SUP_INSTITUTE_structure" id="SUP_INSTITUTE_structure"></a><h4> <span class="mw-headline">SUP_INSTITUTE structure</span></h4>
<table border="1" cellpadding="2">
<tr>
<th>Element name
</th><th>Type
</th><th>Database Field Name
</th></tr>
<tr>
<td>INSTITID
</td><td>LONG
</td><td>INSTITID
</td></tr>
<tr>
<td>PINSID
</td><td>LONG
</td><td>PINSID
</td></tr>
<tr>
<td>INSNAME
</td><td>CHAR[152]
</td><td>INSNAME
</td></tr>
<tr>
<td>INSACR
</td><td>CHAR[24]
</td><td>INSACR
</td></tr>
<tr>
<td>INSTYPE
</td><td>LONG
</td><td>INSTYPE
</td></tr>
<tr>
<td>STREET
</td><td>char[128]
</td><td>STREET
</td></tr>
<tr>
<td>POSTBOX
</td><td>CHAR[28]
</td><td>POSTBOX
</td></tr>
<tr>
<td>CITY
</td><td>CHAR[36]
</td><td>CITY
</td></tr>
<tr>
<td>STATEID
</td><td>LONG
</td><td>STATEID
</td></tr>
<tr>
<td>CPOSTAL
</td><td>CHAR[12]
</td><td>CPOSTAL
</td></tr>
<tr>
<td>CNTRYID
</td><td>LONG
</td><td>CNTRYID
</td></tr>
<tr>
<td>APHONE
</td><td>char[28]
</td><td>APHONE
</td></tr>
<tr>
<td>AFAX
</td><td>CHAR[28]
</td><td>AFAX
</td></tr>
<tr>
<td>AEMAIL
</td><td>CHAR[44]
</td><td>AEMAIL
</td></tr>
<tr>
<td>WEBURL
</td><td>CHAR[64]
</td><td>WEBURL
</td></tr>
<tr>
<td>SINS
</td><td>LONG
</td><td>SINS
</td></tr>
<tr>
<td>EINS
</td><td>LONG
</td><td>EINS
</td></tr>
<tr>
<td>ICHANGE
</td><td>LONG
</td><td>ICHANGE
</td></tr></table>
<a name="DLL_Functions_for_Access_Control" id="DLL_Functions_for_Access_Control"></a><h2> <span class="mw-headline"> DLL Functions for Access Control </span></h2>
<p>Access to the different subsystems of ICIS is through a pair of open and close commands.  Before any functions associated to the subsystem can be called, the open access command must executed first.  However, access to the ICIS applications is based on the right granted to the current user of the installation as specified in the USERS and INSTLN tables.  This right is checked and verified through the open access function of GMS subsystem.
</p>
<a name="GENEALOGY_MANAGEMENT_SYSTEM_DATABASE_ACCESS_FUNCTIONS" id="GENEALOGY_MANAGEMENT_SYSTEM_DATABASE_ACCESS_FUNCTIONS"></a><h3> <span class="mw-headline">GENEALOGY MANAGEMENT SYSTEM DATABASE ACCESS FUNCTIONS</span></h3>
<a name="GMS_openDatabase" id="GMS_openDatabase"></a><h4> <span class="mw-headline">GMS_openDatabase</span></h4>
<dl><dd>GMS_openDatabase reads the initialization file identified by the value of argument szIniFile.  The data source names, DBMS user IDs and DBMS passwords are read from this file and the associated databases opened. GMS_openDatabase does not check ICIS User IDs or passwords, but logs the user as GUEST with password GUEST with read-only access to the central and local database.  To obtain full access to either database, use GMS_openDatabase2.  The format of the INI file is described in 5.2.3b, and the convention is to set szIniFile to ICIS.INI, which should exist in the default windows&nbsp;%TEMP% directory (6.1.1).  It is not necessary to follow this convention for specific applications.
</dd></dl>
<dl><dd><b>Syntax</b>
</dd><dd>long <b>GMS_openDatabase</b>(<i>szIniFile</i>)
</dd></dl>
<dl><dd><b>Arguments</b>
</dd></dl>
<dl><dd><table border="1" cellpadding="2">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>szIniFile
</td><td>char *
</td><td>Input
</td><td>Pointer to NULL terminated string containing the name of an existing initialization file.  If an INI file other than&nbsp;%TEMP%\ICIS.INI is used, it should be passed as a parameter to the application including the full pathname.
</td></tr></table></dd></dl>
<p><br />
</p>
<dl><dd><b>Returns</b>
</dd><dd>GMS_SUCCESS, GMS_ERRORor GMS_NOACCESS
</dd><dd><b>Comments</b>
</dd><dd>The function returns GMS_ERROR if the one or both GMS databases are not opened successfully. No data sources are connected unless all are found and opened.
</dd></dl>
<p><br />
</p>
<a name="GMS_openDatabase2" id="GMS_openDatabase2"></a><h4> <span class="mw-headline">GMS_openDatabase2</span></h4>
<dl><dd>GMS_openDatabase2 reads the initialization file identified by the value of argument szIniFile.  There are two levels of access control to ICIS databases.  First, the database management system may have a system of user IDs and passwords to control opening the database.  Secondly, GMS has a table of user IDs, access privileges, and passwords controlling access to the ICIS fundamental functions.  The data source names, database user IDs and database passwords are read from the initialization file szIniFile. The ICIS user name of the current user is passed in szUserName and the ICIS password in szPassword.  These must be obtained by the application, and one short cut to this is to read them from the INI fil.  The function returns the USER_ID of the current user in argument userID.
</dd></dl>
<dl><dd><b>Syntax</b>
</dd><dd>long <b>GMS_openDatabase2</b>(<i>szIniFile, szUserName, szPassword, userID</i>)
</dd></dl>
<dl><dd><b>Arguments</b>
</dd></dl>
<dl><dd><table border="1" cellpadding="2">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>szIniFile
</td><td>char *
</td><td>input
</td><td>Pointer to NULL terminated string containing the name of an existing initialization file. The file must exist and be present in the Windows subdirectory.
</td></tr>
<tr>
<td>szUserName
</td><td>char *
</td><td>input
</td><td>Pointer to NULL terminated string containing the user name
</td></tr>
<tr>
<td>szPassword
</td><td>char *
</td><td>input
</td><td>Pointer to NULL terminated string containing the password of the user
</td></tr>
<tr>
<td>userID
</td><td>long *
</td><td>output
</td><td>Pointer to a long integer to contain the User ID corresponding to szUserName or 32678 for a guest user.
</td></tr></table></dd></dl>
<dl><dd><b>Returns</b>
</dd><dd>GMS_SUCCESS, GMS_ERROR GMS_NO_ACCESS, GMS_INVALID_PASSWORD, GMS_INVALID_USER, or GMS_INVALID_INSTALLATION .
</dd></dl>
<dl><dd><b>Comments</b>
</dd><dd>The function returns GMS_INVALID_USER if szUserName is not found. If the szPassword is incorrect it returns GMS_INVALID_PASSWORD. If the users installation (USERS.INSTALID) is zero (database administrators only) then the function will allow write access to any local database. Otherwise, the function checks that the local installation (INSTLN.INSTALID) is the same as the users installation (USERS.INSTALID). If the users installation is not zero and does not match the current local database, the function restricts the user to read only access and returns GMS_READ_ONLY. 
</dd><dd>If the local installation (INSTLN.INSTALID) is negative (new installation) then no further checks are made, but if it is positive (existing installation) then the function checks that the local installation fields are identical to the central fields for the matching installation. If not, the function returns GMS_INVALID_INSTALLATION.
</dd><dd>The function also checks the security setting specified in the SECURITY key of the ICIS.INI file. If the security setting is 1, the user and password in the INI file is used to open the database and is checked against .  If the security setting is 2, access is allowed only to users with USTATUS = 2 and the password is encrypted to have access to ICIS database.  .  If the security setting is 3, access is allowed only to users with USTAUS = 3.  Password is encrypted to have access to ICIS database and user name is encrypted to have access to central GMS Database.  If the security setting is 4, access is allowed only to users with USTATUS = 4; password is encrypted to have access to RDBMS database and to ICIS DLL.
</dd><dd>The function returns GMS_ERROR if the one or both GMS databases are not opened successfully, or cause by any internal error.
</dd></dl>
<a name="GMS_closeDatabase" id="GMS_closeDatabase"></a><h4> <span class="mw-headline">GMS_closeDatabase</span></h4>
<dl><dd>GMS_closeDatabase closes the connection to both Central and Local databases.  Frees up all allocated memory used by the databases and DLL.
</dd></dl>
<dl><dd><b>Syntax</b> (Procedure)
</dd><dd>GMS_closeDatabase 			
</dd></dl>
<dl><dd><b>Arguments</b>
</dd><dd>No arguments
</dd></dl>
<dl><dd><b>Returns</b>
</dd><dd>No return value
</dd></dl>
<p><br />
</p>
<a name="GMS_commitData" id="GMS_commitData"></a><h4> <span class="mw-headline">GMS_commitData</span></h4>
<dl><dd>GMS_commitData will permanently write all changes to the database made by calling add or change functions. 
</dd></dl>
<dl><dd><b>Syntax</b>
</dd><dd><b>GMS_commitData	</b>		No arguments, No returns
</dd></dl>
<dl><dd><b>Comment</b>
</dd><dd>Caution should be observed in using this function because it clears the cache used by the SQL driver and clears all SQL transactions. Hence if it is called between a FIND_FIRST and FIND_NEXT sequence in a search, a function sequence error will occur on the next search call with fOpt set to FIND_NEXT.
</dd></dl>
<a name="DATA_MANAGEMENT_SYSTEM_DATABASE_ACCESS_FUNCTIONS" id="DATA_MANAGEMENT_SYSTEM_DATABASE_ACCESS_FUNCTIONS"></a><h3> <span class="mw-headline">DATA MANAGEMENT SYSTEM DATABASE ACCESS FUNCTIONS</span></h3>
<a name="DMS_openDatabase" id="DMS_openDatabase"></a><h4> <span class="mw-headline">DMS_openDatabase</span></h4>
<dl><dd>DMS_openDatabase is the primary function that establishes connection to the DMS databases through the initialization file identified by the argument szInifile.  Data source names, DBMS user IDs and pass words needed to connect are read from this file.  
</dd><dd><b>Syntax</b>
</dd><dd>long DMS_openDatabase(szInifile)
</dd><dd><b>Arguments</b>
</dd></dl>
<dl><dd><table border="1" cellpadding="2">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>szInifile
</td><td>Char *
</td><td>Input
</td><td>Pointer to a NULL terminated string containing the name of an existing initialization file.  This file must reside in the default WINDOWS directory.
</td></tr></table></dd></dl>
<dl><dd><b>Returns</b>
</dd><dd>DMS_SUCCESS(1), DMS_ERROR(-1)
</dd></dl>
<a name="DMS_closeDatabase" id="DMS_closeDatabase"></a><h4> <span class="mw-headline">DMS_closeDatabase</span></h4>
<dl><dd>DMS_closeDatabase closes connection to both Central and Local DMS databases.  The function also frees up allocated memory of  handlers associated with it.
</dd></dl>
<dl><dd><b>Syntax</b> (Procedure)
</dd><dd>void <b>DMS_closeDatabase</b>()
</dd></dl>
<dl><dd><b>Arguments</b>
</dd><dd>No arguments
</dd></dl>
<dl><dd><b>Returns</b>
</dd><dd>No return value
</dd></dl>
<a name="DMS_commitData" id="DMS_commitData"></a><h4> <span class="mw-headline">DMS_commitData</span></h4>
<dl><dd>DMS_commitData will permanently write all changes to the database made by calling add or change functions. 
</dd></dl>
<dl><dd><b>Syntax</b>
</dd><dd><b>DMS_commitData	</b>		No arguments, No returns
</dd></dl>
<dl><dd><b>Comment</b>
</dd><dd>Caution should be observed in using this function because it clears the cache used by the SQL driver and clears all SQL transactions. Hence if it is called between a FIND_FIRST and FIND_NEXT sequence in a search, a function sequence error will occur on the next search call with fOpt set to FIND_NEXT.
</dd></dl>
<a name="INVENTORY_MANAGEMENT_SYSTEM_DATABASE_ACCESS_FUNCTIONS" id="INVENTORY_MANAGEMENT_SYSTEM_DATABASE_ACCESS_FUNCTIONS"></a><h3> <span class="mw-headline">INVENTORY MANAGEMENT SYSTEM DATABASE ACCESS FUNCTIONS</span></h3>
<a name="IMS_OpenDatabase" id="IMS_OpenDatabase"></a><h4> <span class="mw-headline">IMS_OpenDatabase</span></h4>
<dl><dd>IMS_OpenDatabase is the primary function that establishes a connection to the inventory database through the initialisation file identified by the argument szInifile.  Data source names, DBMS user IDs and passwords are read from this file.
</dd></dl>
<dl><dd><b>Syntax</b>
</dd><dd>long IMS_OpenDatabase(szInifile)
</dd><dd><b>Arguments</b>
</dd></dl>
<dl><dd><table border="1" cellpadding="2">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>szInifile
</td><td>Char
</td><td>Input
</td><td>Pointer to a NULL terminated string containing the name of an existing initialisation file. This file must reside in the default WINDOWS directory.
</td></tr></table></dd></dl>
<dl><dd><b>Returns</b>
</dd><dd>IMS_SUCCESS(1), IMS_ERROR(-1)
</dd></dl>
<p><br />
</p>
<a name="IMS_CloseDatabase" id="IMS_CloseDatabase"></a><h4> <span class="mw-headline">IMS_CloseDatabase</span></h4>
<dl><dd>IMS_closeDatabase closes connection to the inventory database.  The function also frees up allocated memory used by the DLL.
</dd></dl>
<dl><dd><b>Syntax</b>
</dd><dd>void IMS_closeDatabase()
</dd></dl>
<dl><dd><b>Arguments</b>
</dd><dd>No arguments
</dd></dl>
<dl><dd><b>Returns</b>
</dd><dd>No return value
</dd></dl>
<a name="IMS_commitData" id="IMS_commitData"></a><h4> <span class="mw-headline">IMS_commitData</span></h4>
<dl><dd>IMS_commitData will permanently write all changes to the IMS database made by calling add or change functions. 
</dd></dl>
<dl><dd><b>Syntax</b>
</dd><dd><b>IMS_commitData	</b>		No arguments, No returns
</dd></dl>
<dl><dd><b>Comment</b>
</dd><dd>Caution should be observed in using this function because it clears the cache used by the SQL driver and clears all SQL transactions. Hence if it is called between a FIND_FIRST and FIND_NEXT sequence in a search, a function sequence error will occur on the next search call with fOpt set to FIND_NEXT.
</dd></dl>
<a name="GENE_MANAGEMENT_SYSTEM_DATABASE_ACCESS_FUNCTIONS" id="GENE_MANAGEMENT_SYSTEM_DATABASE_ACCESS_FUNCTIONS"></a><h3> <span class="mw-headline">GENE MANAGEMENT SYSTEM DATABASE ACCESS FUNCTIONS</span></h3>
<a name="GEMS_openDatabase" id="GEMS_openDatabase"></a><h4> <span class="mw-headline">GEMS_openDatabase</span></h4>
<dl><dd>GEMS_openDatabase establishes connection to the GEMS database using the information specified in the initialization file identified by the argument szInifile.  The information read from this file are Data source names, DBMS user IDs and pass words needed to connect.  
</dd></dl>
<dl><dd><b>Syntax</b>
</dd><dd>long GEMS_openDatabase(szInifile)
</dd><dd><b>Arguments</b>
</dd></dl>
<dl><dd><table border="1" cellpadding="2">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>szInifile
</td><td>Char *
</td><td>Input
</td><td>Pointer to a NULL terminated string containing the name of an existing initialization file.  This file must reside in the default WINDOWS directory.
</td></tr></table></dd></dl>
<dl><dd><b>Returns</b>
</dd><dd>DMS_SUCCESS(1), DMS_ERROR(-1)
</dd></dl>
<a name="GEMS_closeDatabase" id="GEMS_closeDatabase"></a><h4> <span class="mw-headline">GEMS_closeDatabase</span></h4>
<dl><dd>GEMS_closeDatabase closes connection to GEMS database.  The function also frees up allocated memory of  handlers associated with it.
</dd></dl>
<dl><dd><b>Syntax</b> (Procedure)
</dd><dd>void <b>GEMS_closeDatabase</b>()
</dd></dl>
<dl><dd><b>Arguments</b>
</dd><dd>No arguments
</dd></dl>
<dl><dd><b>Returns</b>
</dd><dd>No return value
</dd></dl>
<p><br />
</p>
<a name="GEMS_commitData" id="GEMS_commitData"></a><h4> <span class="mw-headline">GEMS_commitData</span></h4>
<dl><dd>GEMS_commitData will permanently write all changes to the GEMS database made by calling add or change functions. 
</dd></dl>
<dl><dd><b>Syntax</b>
</dd><dd><b>GEMS_commitData	</b>		No arguments, No returns
</dd></dl>
<dl><dd><b>Comment</b>
</dd><dd>Caution should be observed in using this function because it clears the cache used by the SQL driver and clears all SQL transactions. Hence if it is called between a FIND_FIRST and FIND_NEXT sequence in a search, a function sequence error will occur on the next search call with fOpt set to FIND_NEXT.
</dd></dl>
<a name="USER_AND_INSTALLATION" id="USER_AND_INSTALLATION"></a><h3> <span class="mw-headline">USER AND INSTALLATION</span></h3>
<a name="GMS_getUser" id="GMS_getUser"></a><h4> <span class="mw-headline">GMS_getUser</span></h4>
<dl><dd>GMS_getUser will retrieve user information. The first argument is a pointer to a GMS_User structure (6.1.2g).  If the USER_ID element is not zero when the function is called then it returns the details for the corresponding user.  If it is zero then a user name must be supplied in the NAME element and the function returns details for the first user with the specified name if fOpt = FIND_FIRST or for the next available user with that name if fOpt = FIND_NEXT. Any call which fails to get user information returns GMS_NO_DATA.
</dd></dl>
<dl><dd><b>Syntax</b>
</dd><dd>long GMS_getUser(user, fOpt)
</dd></dl>
<dl><dd><b>Arguments</b>
</dd></dl>
<dl><dd><table border="1" cellpadding="2">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>User
</td><td>GMS_User*
</td><td>input/output
</td><td>Address of a GMS_User structure
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>input
</td><td>Either FIND_FIRST  or FIND_NEXT
</td></tr></table></dd></dl>
<dl><dd><b>Returns</b>
</dd><dd>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</dd></dl>
<dl><dd><b>Comments</b>
</dd><dd>The principle of using GMS_getUser is almost the same as GMS_getAttribute.  If there is a problem accessing the database, the function will return GMS_ERROR.
</dd></dl>
<a name="GMS_getInstallation" id="GMS_getInstallation"></a><h4> <span class="mw-headline">GMS_getInstallation</span></h4>
<dl><dd>GMS_getInstallation will retrieve installation information.
</dd></dl>
<dl><dd><b>Syntax</b>
</dd><dd>long GMS_getInstallation(instln,szDesc,nszDesc)
</dd></dl>
<dl><dd><b>Arguments</b>
</dd></dl>
<dl><dd><table border="1" cellpadding="2">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>instln
</td><td>GMS_Installation*
</td><td>input/ output
</td><td>Address of a GMS_Installation structure to contain the installation parameters.
</td></tr>
<tr>
<td>szDesc
</td><td>char*
</td><td>output
</td><td>Address of a character variable to contain the installation description
</td></tr>
<tr>
<td>nszDesc
</td><td>Long
</td><td>input
</td><td>Maximum data size szDesc can hold (including the null terminator).
</td></tr></table></dd></dl>
<dl><dd><b>Returns</b>
</dd><dd>GMS_ERROR, GMS_NO_DATA , GMS_SUCCESS
</dd></dl>
<dl><dd><b>Comments</b>
</dd><dd>If the instno field of instln structure is zero then the function will return the current installation record from the local database. Otherwise, it will return the installation record corresponding to the value of the instno field. The function returns GMS_ERROR  if there is no local INSTALLATION table or if the installation record corresponding to INSTNO field is not found in the central database. Otherwise, it returns GMS_SUCCESS .
</dd></dl>
<a name="GMS_addUser" id="GMS_addUser"></a><h4> <span class="mw-headline">GMS_addUser</span></h4>
<dl><dd>GMS_addUser adds a new user to the local USERS table. Details of the reference must be stored in appropriate elements of the user parameter. The next available user number will be returned in the USERID element. New data is not committed to the local database until the function GMS_commitData (6.8.1) has been called, and uncommitted data can be deleted from the buffer with the GMS_rollbackData function (6.8.2)
</dd></dl>
<dl><dd><b>Syntax</b>
</dd><dd>long GMS_addUser(user,szEname,security)
</dd></dl>
<dl><dd><b>Arguments</b>
</dd></dl>
<dl><dd><table border="1" cellpadding="2">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>user
</td><td>GMS_USERS *
</td><td>input/output
</td><td>Address of a GMS_BIBREFS structure
</td></tr>
<tr>
<td>szEname
</td><td>Char *
</td><td>output
</td><td>Address of NULL terminated string to place the encrypted user name
</td></tr>
<tr>
<td>security
</td><td>long
</td><td>input
</td><td>The level of security
</td></tr></table></dd></dl>
<dl><dd><b>Returns</b>
</dd><dd>GMS_SUCCESS, GMS_ERROR , GMS_NO_ACCESS
</dd></dl>
<a name="GMS_DLL_FUNCTIONS" id="GMS_DLL_FUNCTIONS"></a><h2> <span class="mw-headline">GMS DLL FUNCTIONS</span></h2>
<a name="SEARCH_FUNCTIONS" id="SEARCH_FUNCTIONS"></a><h3> <span class="mw-headline">SEARCH FUNCTIONS</span></h3>
<a name="GMS_findName" id="GMS_findName"></a><h4> <span class="mw-headline">GMS_findName</span></h4>
<dl><dd>GMS_findName searches all names in the NAMES tables for the search string szNameSrch. If fOpt is FIND_FIRST the function  stores the name details of the first match of the germplasm record that has not been replaced in structure nameData and the NAME value in szName.  The germplasm details of the matched record are retrieved to the structure germData..  If fOpt is FIND_NEXT it stores the succeeding non-replaced match. 
</dd></dl>
<dl><dd><b>Syntax</b>
</dd><dd>long <b>GMS_findName</b>(<i>szNameSrch, nameData, germData,  szName,  nszName, fOpt</i>)
</dd></dl>
<dl><dd><b>Arguments</b>
</dd></dl>
<dl><dd><table border="1">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>SzNameSrch
</td><td>char *
</td><td>input
</td><td>Address of NULL terminated string containing the name search
</td></tr>
<tr>
<td>NameData
</td><td>GMS_NameData*
</td><td>input/ output
</td><td>Address of a GMS_NameData structure to contain the name data
</td></tr>
<tr>
<td>GermData
</td><td>GMS_Germplasm*
</td><td>output
</td><td>Address of a GMS_Germplasm Structure to contain Germplasm data for the retrieved germplasm
</td></tr>
<tr>
<td>SzName
</td><td>char *
</td><td>output
</td><td>Address of NULL terminated string to place the NAME
</td></tr>
<tr>
<td>NszName
</td><td>long
</td><td>input
</td><td>Maximum length of szName
</td></tr>
<tr>
<td>Fopt
</td><td>long
</td><td>input
</td><td>Either FIND_FIRST  or FIND_NEXT
</td></tr></table></dd></dl>
<dl><dd><b>Returns</b>
</dd><dd>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA 
</dd></dl>
<dl><dd><b>Comments</b>
</dd><dd>The target name can contain wildcards within the 128 characters of the string. _ match any character and a terminal % matches any trailing characters.  On the first call to this function, fOpt should have a value of FIND_FIRST then call the function with fOpt set to FIND_NEXT repeatedly until it returns GMS_NO_DATA to find subsequent matching names. 
</dd><dd>The function updates the name record based on the modification stored in the CHANGES table.
</dd></dl>
<dl><dd><b>Returns</b>
</dd><dd>GMS_ERROR  if any internal ODBC function call fails.
</dd></dl>
<p><br />
</p>
<a name="GMS_findName2" id="GMS_findName2"></a><h4> <span class="mw-headline">GMS_findName2</span></h4>
<dl><dd>GMS_findName2 searches for string matches to any of three forms of a specified name.  The forms of the name are the specified string, the string with all spaces removed and with name standardization applied (see also the <a href="../../../../articles/g/m/s/GMS_standardName_1cd0.html" class="new" title="GMS standardName (page does not exist)">GMS_standardName</a> function ).  The function returns name and germplasm data for search matches.  If the STATUS  field of the NameData argument is non-zero then only names of the specified status are returned.
</dd></dl>
<dl><dd><b>Note</b>
<ul><li>This routine calls <a href="../../../../articles/g/m/s/GMS_applyChanges_8f03.html" class="new" title="GMS applyChanges (page does not exist)">GMS_applyChanges</a>  internally to update the germplasm record. 
</li><li>The function updates the name record based on the modification stored in the CHANGES table.
</li></ul>
</dd></dl>
<dl><dd><b>Syntax</b>
</dd><dd>long <b>GMS_findName2</b> (<i>szNameSrch, nameData, germData, szName, nszName, fOpt</i>)
</dd></dl>
<dl><dd><b>Arguments</b>
</dd><dd>As for GMS_findName except that a new argument Germ is included:
</dd></dl>
<dl><dd><table border="1">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>szNameSrch
</td><td>char *
</td><td>input
</td><td>Address of NULL terminated string containing the name search
</td></tr>
<tr>
<td>NameData
</td><td>GMS_NameData*
</td><td>input/ output
</td><td>Address of a GMS_NameData structure to contain the name data
</td></tr>
<tr>
<td>GermData
</td><td>GMS_Germplasm*
</td><td>output
</td><td>Address of a GMS_Germplasm Structure to contain Germplasm data for the retrieved germplasm
</td></tr>
<tr>
<td>SzName
</td><td>char *
</td><td>output
</td><td>Address of NULL terminated string to place the NAME
</td></tr>
<tr>
<td>NszName
</td><td>long
</td><td>input
</td><td>Maximum length of szName
</td></tr>
<tr>
<td>Fopt
</td><td>long
</td><td>input
</td><td>Either FIND_FIRST  or FIND_NEXT
</td></tr></table></dd></dl>
<dl><dd><b>Comments</b>
</dd><dd>This function works like GMS_findName but searches for matches to the supplied name szNameSrch with any internal spaces removed and after applying the name standardization algorithm (3.1.3 and 6.9.8).  Wildcards characters should appear within the first 128 characters of the strings with spaces removed and after name standardization, otherwise they will not be recognized as wildcards.
</dd><dd>The function updates the name record based on the modification stored in the CHANGES table.
</dd></dl>
<a name="GMS_findName3" id="GMS_findName3"></a><h4> <span class="mw-headline">GMS_findName3</span></h4>
<dl><dd>GMS_findName3 searches for a string in the NAMES table, both as specified and with any spaces removed, and returns name and germplasm data for search matches.  A value in TYPE or STATUS or LOCATION is specified, only those records matching the combination of values are returned.  Otherwise, it functions like GMS_findName. 
</dd></dl>
<dl><dd><b>Note</b>
</dd><dd>This routine calls GMS_applyChanges (6.4.10) internally to update the germplasm record before returning.
</dd></dl>
<dl><dd><b>Syntax</b>
</dd><dd>long <b>GMS_findName3</b> (<i>szNameSrch, nameData, germData, szName, nszName, fOpt</i>)
</dd></dl>
<dl><dd><b>Arguments</b>
</dd><dd>As for GMS_findName except that a new argument GermData is included:
</dd></dl>
<dl><dd><table border="1">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>GermData
</td><td>GMS_Germplasm*
</td><td>output
</td><td>Address of a GMS_Germplasm Structure to contain Germplasm data for the retrieved germplasm
</td></tr></table></dd></dl>
<dl><dd><b>Comments</b>
</dd><dd>This function works like GMS_findName but also returns the germplasm record and also searches for matches to the supplied name szNameSrch with any internal spaces removed but does not apply the name standardization algorithm.
</dd><dd>The function updates the name record based on the modification stored in the CHANGES table.
</dd></dl>
<dl><dd>Also see GMS_findName comments.
</dd></dl>
<dl><dd>GMS_ERROR if any internal ODBC function call fails.
</dd></dl>
<p><br />
</p>
<a name="GMS_findDescendant" id="GMS_findDescendant"></a><h4> <span class="mw-headline">GMS_findDescendant</span></h4>
<p>GMS_findDescendant searches the GPID1 and GPID2 fields of the GERMPLASM Table and the PID field of the OTHER PROGENITORS Table for the given <i>gid</i>. After a successful call to the function, <i>descendant </i>will contain the germplasm record of a derivative or offspring of the target germplasm and <i>progNo</i> will contain the number of the progenitor that matches <i>GID</i>.
</p>
<dl><dd><b>Note</b>
</dd></dl>
<p>This routine calls GMS_applyChanges (6.4.10) internally to update the germplasm record before returning.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_findDescendant</b>(gid, descendant, progNo, fOpt);
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>Gid
</td><td>long
</td><td>input
</td><td>GID for which descendants are sought
</td></tr>
<tr>
<td>descendant
</td><td>GMS-germplasm*
</td><td>output
</td><td>Pointer to a Germplasm record which will contain the germplasm data for a descendant of GID
</td></tr>
<tr>
<td>progNo
</td><td>long*
</td><td>output
</td><td>Number of the progenitor which matches GID
</td></tr>
<tr>
<td>fOpt
</td><td>long
</td><td>input
</td><td>Either FIND_FIRST or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<dl><dd><b>Note</b>
</dd></dl>
<p>GMS_findDescendant checks whether progenitor progNo has been changed through a local attribute before returning a value and it checks for progenitors which have been changed to gid by local change attributes.
</p>
<a name="GMS_findGermplasm" id="GMS_findGermplasm"></a><h4> <span class="mw-headline">GMS_findGermplasm</span></h4>
<p>GMS_findGermplasm will retrieve germplasm records for all germplasm matching specified criteria. The first argument of GMS_findGermplasm is a pointer to a GMS_Germplasm structure.  All elements of the structure must be set to valid values or zeros before calling the function with parameter fOpt=FIND_FIRST. This sets a search template restricting the search to records with fields matching the valid values. The first match is returned if <i>fOpt </i>= FIND_FIRST and the next matching location is returned if <i>fOpt </i>= FIND_NEXT
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_findGermplasm</b>(<i>germData, fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>germData
</td><td>GMS_Germplasm *
</td><td>Input/ output
</td><td>Enters with the name-string to search, returns with the location details of the next match
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<a name="GMS_findCIDSID" id="GMS_findCIDSID"></a><h4> <span class="mw-headline">GMS_findCIDSID</span></h4>
<p>GMS_findCIDSID searches for ICIS GID, CIMMYT CID and SID depending on the given parameters.  If  CID and/or  SID codes are given, it retrieves the corresponding GID.  If GID is given,  CID and SID are returned.  FIND_FIRST and FIND_NEXT are valid find options if CID is the input parameter.  If CID and SID are provided, the find option should be FIND_SPECIFIC=2.  If GID is the input parameter, FIND_FIRST option is used.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_findCIDSID</b><i>(CID,SID,GID, fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>CID
</td><td>long
</td><td>Input/ output
</td><td>The CID to search if input parameter or the CID returned by the function if GID is given.
</td></tr>
<tr>
<td>SID
</td><td>long
</td><td>Input/ output
</td><td>The SID to search if input parameter together with CID or the SID returned by the function  if GID or CID is given.
</td></tr>
<tr>
<td>GID
</td><td>long
</td><td>Input/ output
</td><td>The GID to search if input parameter  or the GID returned by the function if CID and/or SID are given.
</td></tr>
<tr>
<td>fOpt
</td><td>long
</td><td>input
</td><td>Either FIND_FIRST(0) or FIND_NEXT(1)  if CID is given;<br />FIND_FIRST(0)  if GID is given;<br />FIND_SPECIFIC(2)  if CID and SID are given.
</td></tr>
</table>
<p>Note:
</p><p>If the GERMPLSM table being accessed does not have CID and SID, the function returns GMS_INVALID_DBSTRUCTURE;
</p>
<a name="GMS_DATA_RETRIEVAL_functions" id="GMS_DATA_RETRIEVAL_functions"></a><h3> <span class="mw-headline">GMS DATA RETRIEVAL functions</span></h3>
<a name="GMS_getGermplasmRecord" id="GMS_getGermplasmRecord"></a><h4> <span class="mw-headline">GMS_getGermplasmRecord</span></h4>
<p>GMS_getGermplasmRecord retrieves data from the GERMPLASM table with GERMPLASM_ID equal to <i>gid</i> in structure <i>germData.  </i>The user must check the return status and the REPLACE field of <i>germData</i> for replaced or deleted germplasm and take appropriate action.  No check is made in the local database for change or replace attributes.  These can be applied by calling <b>GMS_applyChanges</b> (6.4.10).
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long GMS_getGermplasmRecord (<i>gid</i>, <i>germData</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>gid
</td><td>long
</td><td>input
</td><td>The GERMPLASM_ID to search
</td></tr>
<tr>
<td>germData
</td><td>GMS_Germplasm *
</td><td>output
</td><td>Address of a GMS_Germplasm record
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The GERMPLASM tables will be searched for the record with GERMPLASM_ID equal to <i>gid</i>. It is not possible for the search to have multiple results because the GERMPLASM_ID is unique across the two data sources (Central and Local GMS). It returns GMS_NO_DATA if there is no GERMPLASM record with GERMPLASM_ID (<i>gid</i>). If the record has been deleted or replaced (GRPLCE=<i>gid</i> for deleted, GRPLCE= &lt;<i>replacement gid</i>&gt; for replace) the function returns the deleted or replaced germplasm record and GMS_NO_DATA. It returns GMS_ERROR if any internal ODBC function call fails.
</p>
<a name="GMS_getGermplasm" id="GMS_getGermplasm"></a><h4> <span class="mw-headline">GMS_getGermplasm</span></h4>
<p>GMS_getGermplasm retrieves data from the GERMPLASM table with GERMPLASM_ID equal to <i>gid</i> in structure germData.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_getGermplasm</b> (<i>gid</i>, <i>germData</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>gid
</td><td>long
</td><td>input
</td><td>The GERMPLASM_ID to search
</td></tr>
<tr>
<td>germData
</td><td>GMS_Germplasm *
</td><td>output
</td><td>Address of a GMS_Germplasm record
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<dl><dd><b>Note</b>
</dd></dl>
<p>This routine calls GMS_applyChanges (6.4.10) internally to update the germplasm record before returning.
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>See GMS_getGermplasmRecord comments.
</p>
<a name="GMS_getGermplasm2" id="GMS_getGermplasm2"></a><h4> <span class="mw-headline">GMS_getGermplasm2</span></h4>
<p>GMS_getGermplasm2 retrieves all data from the GERMPLASM table and data for the preferred name from the NAMES table for germplasm <i>gid </i>or for its replacement if it is replaced. The function does not return data if germplasm <i>gid</i> is deleted. The germplasm data is returned in argument <i>germData,</i> the name data in argument <i>nameData</i> and the preferred name in <i>szName</i>. With GMS_getGermplasm2 the user only needs to check the return status for deleted germplasm.
</p>
<dl><dd><b>Note</b>
</dd></dl>
<p>GMS_getGermplasm2 checks the local CHANGES table for any replace or change attributes by calling GMS_applyChanges internally. If it finds them it applies the specified deletion, replacement or change before returning the data. This means that a local user can specify changes to central records and all applications that use this function will show the effect of those changes.
</p><p>The function updates the name record based on the modification stored in the CHANGES table.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_getGermplasm2</b> (gid, germData, nameData, szName, nszName)
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>gid
</td><td>long
</td><td>input
</td><td>The GERMPLASM_ID to search
</td></tr>
<tr>
<td>germData
</td><td>GMS_Germplasm *
</td><td>output
</td><td>Address of a GMS_Germplasm record
</td></tr>
<tr>
<td>nameData
</td><td>GMS_NameData*
</td><td>output
</td><td>Address of a GMS_NameData structure to contain details of the preferred name.
</td></tr>
<tr>
<td>szName
</td><td>char*
</td><td>output
</td><td>Address of a string variable to contain the preferred name as a null terminated string
</td></tr>
<tr>
<td>nszName
</td><td>long
</td><td>input
</td><td>Maximum length of the <i>szName</i>
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>If germplasm <i>gid</i> has been deleted (GRPLCE=GID), GMS_getGermplasm2<b> </b>sets the GERMPLASM_ID element of argument <i>germData</i> to zero and returns GMS_NO_DATA.  If the germplasm <i>gid</i> has been replaced (GRPLCE= <i>&lt;replacement gid&gt;</i>) the function returns data for the replaced germplasm and not germplasm GID. In this case the GERMPLASM_ID element of <i>germData</i> will have a different value to <i>gid</i>.  The routine also checks the local ATTRIBUTES table for any change or replacement attributes for the germplasm record and if it finds then the function applies the changes. If there is an ODBC error the function returns GMS_ERROR.
</p>
<a name="GMS_getGermplasm3" id="GMS_getGermplasm3"></a><h4> <span class="mw-headline">GMS_getGermplasm3</span></h4>
<p>GMS_getGermplasm3 works exactly like GMS_getGermplasm2 but with additional return argument for the abbreviation.
</p>
<dl><dd><b>Note</b>
</dd></dl>
<p>See GMS_getGermplasm2 note.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_getGermplasm3</b> (gid, germData, nameData, szName, nszName, szAbbreviation)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>gid
</td><td>long
</td><td>input
</td><td>The GERMPLASM_ID to search
</td></tr>
<tr>
<td>germData
</td><td>GMS_Germplasm *
</td><td>output
</td><td>Address of a GMS_Germplasm record
</td></tr>
<tr>
<td>nameData
</td><td>GMS_NameData*
</td><td>output
</td><td>Address of a GMS_NameData structure to contain details of the preferred name.
</td></tr>
<tr>
<td>szName
</td><td>char*
</td><td>output
</td><td>Address of a string variable to contain the preferred name as a null terminated string
</td></tr>
<tr>
<td>nszName
</td><td>long
</td><td>input
</td><td>Maximum length of the <i>szName</i>
</td></tr>
<tr>
<td>szAbbreviation
</td><td>char*
</td><td>output
</td><td>Address of a string variable to contain the preferred abbreviation name as a null terminated string
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>GMS_getGermplasm3 does not specify the length of the <i>szAbbreviation</i> for the routine expects it to be at least 9 bytes in length (&gt;=9).
</p><p>See GMS_getGermplasm2 comments.
</p>
<a name="GMS_getProgenitorID" id="GMS_getProgenitorID"></a><h4> <span class="mw-headline">GMS_getProgenitorID</span></h4>
<p>GMS_getProgenitorID retrieves the<i> </i>GERMPLASM_ID of <i>iProgen</i><sup>th</sup> progenitor of germplasm with GERMPLASM_ID <i>gid</i> in variable <i>pGid</i>.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_getProgenitorID</b>( gid, iProgent, pGid)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="84%">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>gid
</td><td>long
</td><td>input
</td><td>The GERMPLASM_ID to search
</td></tr>
<tr>
<td>iProgen
</td><td>long
</td><td>input
</td><td>No of the parent whose ID is required
</td></tr>
<tr>
<td>pGid
</td><td>long *
</td><td>output
</td><td>Address of a long integer variable to contain the GERMPLASM_ID of the <i>iProgen</i><sup>th</sup> progenitor
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>Returns GMS_NO_DATA  when there is no <i>iProgen</i><sup>th</sup> progenitor. Returns GMS_ERROR  if any internal ODBC function call fails.
</p><p>Although GMS_getProgenitorID can be called with <i>iProgen</i> equal to 1 or 2 it is usually not necessary as the germplasm data containing these parent IDs is often already available, and if not it is still more efficient to call it from the GMS_getGermplasm function. The routine checks the local ATTRIBUTES table for any changes in <i>iProgen</i><sup>th</sup> progenitor.
</p><p>See GMS_getGermplasm2 comments.
</p>
<a name="GMS_getNameRecord" id="GMS_getNameRecord"></a><h4> <span class="mw-headline">GMS_getNameRecord</span></h4>
<p>GMS_getNameRecord retrieves data from the NAMES table for the given <i>nid</i> in structure <i>nameData.  </i>The user must check the return  NSTAT field of <i>nameData</i> for deleted name and take appropriate action.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long GMS_getNameRecord (<i>nameData,szName,nszName</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>nameData
</td><td>GMS_Name *
</td><td>Input/output
</td><td>Address of a GMS_Name record
</td></tr>
<tr>
<td>szName
</td><td>Char *
</td><td>output
</td><td>Address of a string variable to contain the name as a null terminated string
</td></tr>
<tr>
<td>nszNamr
</td><td>long
</td><td>input
</td><td>The length of the szName string.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<a name="GMS_getName" id="GMS_getName"></a><h4> <span class="mw-headline">GMS_getName</span></h4>
<p>GMS_getName will retrieve all names associated with germplasm having specified germplasm ID and name STATUS or name TYPE. GMS_getName requires that the target germplasm ID is stored in the GERMPLASM element of the <i>nameData</i> argument (6.1.2b) and the STATUS and TYPE elements should be set to zero or a desired value before calling the function.  If TYPE and STATUS are zero, the function will retrieve all names of the target germplasm. If STATUS is non zero only names with matching status values are returned. If STATUS is zero and TYPE is non zero then only names with matching TYPE are returned. If <i>fOpt</i> equals FIND_FIRST the function returns the Name with the lowest value of TYPE. Subsequent calls with <i>fOpt</i> equal to FIND_NEXT return names in order of value of TYPE.  Any call that fails to find a name returns GMS_NO_DATA.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_getName</b>(nameData, szName, nszName, fOpt)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>nameData
</td><td>GMS_NameData*
</td><td>input/output
</td><td>Address of a GMS_NameData record
</td></tr>
<tr>
<td>szName
</td><td>char *
</td><td>output
</td><td>Address of NULL terminated string containing the NAME
</td></tr>
<tr>
<td>nszName
</td><td>long
</td><td>input
</td><td>Maximum size of <i>szName</i> in bytes
</td></tr>
<tr>
<td>fOpt
</td><td>long
</td><td>input
</td><td>Either FIND_FIRST  or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The germplasm ID and, if required, the name type of the germplasm for which names are required must be loaded into the GERMPLASM and TYPE elements of the GMS_NameData argument if fOpt=FIND_FIRST.  On return this argument contains all the other relevant fields for the returned name.  If no name is found the argument <i>szName</i> will contain a NULL string.  If the function is called with bad parameters or there was a problem accessing the database, the function will return GMS_ERROR. GMS_getName returns name data for deleted or replaced germplasm without warning.
</p>
<a name="GMS_getAttribute" id="GMS_getAttribute"></a><h4> <span class="mw-headline">GMS_getAttribute</span></h4>
<p>GMS_getAttribute will retrieve all attributes associated with germplasm having specified germplasm ID and attribute TYPE. GMS_getAttribute requires the germplasm ID and attribute type are stored in the GERMPLASM and TYPE fields of the <i>attribute</i> argument before calling the function. If TYPE is zero the function will retrieve all attributes of a germplasm regardless of attribute type.  If <i>fOpt</i> equals FIND_FIRST the function returns the attribute with the lowest value of attribute TYPE.  Subsequent calls with <i>fOpt</i> equal to FIND_NEXT return attributes in order of TYPE value. Any call that fails to find an attribute returns GMS_NO_DATA.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_getAttribute</b>(attribute, szAVal, nszAVal, fOpt)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>attribute
</td><td>GMS_Attribute*
</td><td>input/output
</td><td>Address of a GMS_Attribute record
</td></tr>
<tr>
<td>szAVal
</td><td>char *
</td><td>output
</td><td>Address of NULL terminated string to place the attribute value
</td></tr>
<tr>
<td>nszAVal
</td><td>Long
</td><td>input
</td><td>Length/Size of <i>szAVal</i>
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>input
</td><td>Either FIND_FIRST  or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The principle of using GMS_getAttribute is almost the same as GMS_getName.  The only difference is that the first argument is GMS_Attribute structure and the ATTRIBUTE table is searched. If the function is called with bad parameters or there was a problem accessing the database, the function will return GMS_ERROR. GMS_getAttribute returns attribute data for deleted or replaced germplasm without warning.
</p>
<a name="GMS_getMethod" id="GMS_getMethod"></a><h4> <span class="mw-headline">GMS_getMethod</span></h4>
<p>GMS_getMethod retrieves details of a method from the METHODS table. The first argument of GMS_getMethod is a pointer to a GMS_Method structure (6.1.2d).  If the METHOD_ID element is not zero when the function is called then the details for the corresponding method are retrieved.  If it is zero then the function returns details for the first method if <i>fOpt </i>= FIND_FIRST or for the next available method if <i>fOpt </i>= FIND_NEXT.  Any call which fails to find a method information returns GMS_NO_DATA.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_getMethod</b>(method, szMDesc,nszMDesc, fOpt)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>method
</td><td>GMS_Method*
</td><td>input/<br />output
</td><td>Address of a GMS_Method structure to contain method details
</td></tr>
<tr>
<td>szMDesc
</td><td>char *
</td><td>output
</td><td>Address of a string variable to contain the NULL terminated method description
</td></tr>
<tr>
<td>nszMDesc
</td><td>Long
</td><td>input
</td><td>Maximum size of <i>szMDesc </i>in bytes
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>input
</td><td>Either FIND_FIRST  or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The principle of using <b>GMS_getMethod</b> is almost the same as <b>GMS_getAttribute</b>. If the function is called and there was a problem accessing the database, the function will return GMS_ERROR. If <i>szMDesc </i>is NULL and <i>cMDesc </i>is zero then GMS_getMethod will not retrieve the method description.
</p><p><br />
</p>
<a name="GMS_applyChanges" id="GMS_applyChanges"></a><h4> <span class="mw-headline">GMS_applyChanges</span></h4>
<p>GMS_applyChanges returns the germplasm record after applying the changes as recorded in the local attributes table. This allows a local user to register changes to central germplasm and have those changes reflected immediately in all analysis applications that use the DLL. The changes are checked and physically made in the central database at update.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_applyChanges</b>(<i>germData</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>GermData
</td><td>GMS_Germplasm *
</td><td>input/ output
</td><td>Address of a GMS_Germplasm record
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_ERROR,GMS_SUCCESS
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>GMS_applyChanges searches the local ATTRIBUTS table where GID matches <i>germData.gid</i> and ATYPE value is either REPLACE (101) or CHANGE(102). GMS_applyChanges first looks for REPLACE attributes and gets the replacement germplasm. Next it looks for CHANGE attributes and applies the changes in chronological order with the most recent change last. GMS_applyChanges is called internally for central germplasm (positive gids) by the following routines before returning the germplasm data: GMS_getGermplasm2, GMS_getGermplasm3, GMS_getDescendant, GMS_findName, GMS_findName2, and GMS_findName3 GMS_findPreferredName<b>.</b>
</p>
<a name="Functions_to_add_data_to_the_local_database" id="Functions_to_add_data_to_the_local_database"></a><h3> <span class="mw-headline">Functions to add data to the local database</span></h3>
<a name="GMS_addGermplasm" id="GMS_addGermplasm"></a><h4> <span class="mw-headline">GMS_addGermplasm</span></h4>
<p>GMS_addGermplasm will add new germplasm and name information to the GMS database according to the information in the arguments.  If the germplasm is produced by a generative method with more than 2 progenitors then germplasm IDs for progenitors after the second are contained in array argument <i>aPID</i>.
</p><p>The GERMPLASM_ID field of the <i>germData</i> argument and the GERMPLASM field of the <i>nameData </i>argument must be zero on input, and will be set to the new germplasm ID value on exit.
</p><p>New data is not committed to the local database until the function GMS_commitData (6.8.1) has been called, and uncommitted data can be deleted from the buffer with the GMS_rollbackData function (6.8.2)
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_addGermplasm</b>( germData, nameData, szPName, aPID)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>germData
</td><td>GMS_Germplasm *
</td><td>input/<br />output
</td><td>Address of a GMS_Germplasm record
</td></tr>
<tr>
<td>nameData
</td><td>GMS_NameData *
</td><td>input/<br />output
</td><td>Address of a GMS_NameData record
</td></tr>
<tr>
<td>szPName
</td><td>char *
</td><td>input
</td><td>Address of NULL terminated string which contains the PREFERRED_NAME
</td></tr>
<tr>
<td><i>aPID</i>
</td><td>long *
</td><td>input
</td><td>Address of an array of Parent GIDs.  NULL if the number of progenitors is less than or equal to two.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_ACCESS
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The following fields of the <i>germData</i> structure should be properly populated with valid values before calling the function:
</p><p> METHOD  number of method used corresponding to METHOD_ID on the METHODS table;
</p><p> NO_PROGENITORS -  for a derivative process or the number of parents for a generative process;
</p><p> PROGENITOR_ID1 - Group ID for a derivative process or the ID of the first parent (usually the female) for a generative process. (Zero if unknown);
</p><p> PROGENITOR_ID2 - Source ID for a derivative process or the ID of the second parent for a generative process. (Zero if unknown);
</p><p> LOCATION - Location ID for the breeding or collection location (Zero if unknown);
</p><p> DATE - Date as YYYMMDD ( 0 if unknown);
</p><p> REFERENCE  reference number (missing id unknown).
</p><p>The elements GERMPLASM_ID, USER and REPLACE will be populated by the function.
</p><p>The string <i>szPname</i> may not be NULL and the following fields of the <i>Name</i> structure should be populated with valid values before calling the function:
</p><p> TYPE  name type number from the UDFIELDS table;
</p><p> STATUS - name status (preferred or not) and data storage mode (Table 3.8.3).
</p><p> LOCATION  name location number, often the same as LOCATION in <i>Germ</i>;
</p><p> DATE -  date the germplasm was named, same form as DATE in <i>Germ</i>;
</p><p> REFERENCE - if there is one available.
</p><p>The GERMPLASM and USER elements of <i>Name</i> will be populated by the function.
</p>
<a name="GMS_addName" id="GMS_addName"></a><h4> <span class="mw-headline">GMS_addName</span></h4>
<p>GMS_addName adds new name <i>szPName</i> for germplasm specified by the GERMPLASM field in the <i>nameData </i>structure.
</p><p>New data is not committed to the local database until the function GMS_commitData (6.8.1) has been called, and uncommitted data can be deleted from the buffer with the GMS_rollbackData function (6.8.2)
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_addName</b>(<i>nameData</i>, <i>szPName</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>nameData
</td><td>GMS_NameData *
</td><td>input
</td><td>Address of a GMS_NameData record
</td></tr>
<tr>
<td>szPName
</td><td>Char *
</td><td>input
</td><td>Address of NULL terminated string to place the name
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR , GMS_NO_ACCESS
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>	The string <i>szPname</i> may not be NULL and the following fields of the <i>Name</i> structure should be properly populated with valid values before calling the function:
</p><p> GERMPLASM  valid germplasm ID
</p><p> TYPE - the type of name;
</p><p> STATUS - name status (preferred or not) and data storage type;
</p><p> LOCATION
</p><p> DATE
</p><p> REFERENCE - if there is one available.
</p>
<a name="GMS_addAttribute" id="GMS_addAttribute"></a><h4> <span class="mw-headline">GMS_addAttribute</span></h4>
<p>GMS_addAttribute adds new attribute with value <i>szAVal</i> for germplasm defined by the GERMPLASM_ID field in the <i>attribute</i> structure.
</p><p>New data is not committed to the local database until the function GMS_commitData (6.8.1) has been called, and uncommitted data can be deleted from the buffer with the GMS_rollbackData function (6.8.2)
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_addAttribute</b>(<i>attribute</i>, <i>szAVal</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>attribute
</td><td>GMS_Attribute *
</td><td>input/<br />output
</td><td>Address of a GMS_Attribute structure
</td></tr>
<tr>
<td>szAVal
</td><td>char *
</td><td>input
</td><td>Address of NULL terminated string to place the value of the attribute
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR , GMS_NO_ACCESS
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The string <i>szAVal</i> should not be a NULL string and the following fields of the <i>attribute</i> structure should be properly populated with values before calling the function:
</p><p> GERMPLASM  valid germplasm ID
</p><p> TYPE - the type number of the attribute (from the UDFLDS Table);
</p><p> LOCATION
</p><p> DATE
</p><p> REFERENCE - if there is one available.
</p>
<a name="GMS_addChanges" id="GMS_addChanges"></a><h4> <span class="mw-headline">GMS_addChanges</span></h4>
<p>GMS_addChanges adds one record to the local CHANGES table specifying a change made to germplasm data.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_addChanges</b> (<i>changeData,szDesc</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td><i>changeData</i>
</td><td>GMS_Changes *
</td><td>Input/output
</td><td>Address of a GMS_Changes structure
</td></tr>
<tr>
<td><i>szDesc</i>
</td><td>char *
</td><td>Input
</td><td>Description of the change
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR
</p>
<dl><dd><b>Comment</b>
</dd></dl>
<p>The fields CTABLE, CFIELD, CRECORD, CFROM, CTO and CGROUP should be properly initialized. The routine will automatically assign values to CID, CUID, CDATE, and CTIME fields.
</p>
<a name="Functions_to_correct_LOCAL_GMS_records" id="Functions_to_correct_LOCAL_GMS_records"></a><h3> <span class="mw-headline">Functions to correct LOCAL GMS records</span></h3>
<a name="GMS_setGermplasm" id="GMS_setGermplasm"></a><h4> <span class="mw-headline">GMS_setGermplasm</span></h4>
<p>GMS_setGermplasm changes the value of any field in the local GERMPLASM table except the PREFERRED_NAME, NAME_EXTENSION and ABBREVIATION fields. Only the central database administrator can change field values in the Central database. However, a local user can request such changes by adding SETGERM attributes for central germplasm records to the local attributes table.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_setGermplasm</b>(<i>germData</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td><i>germData</i>
</td><td>GMS_Germplasm*
</td><td>Input
</td><td align="justify">Pointer to a GMS-Germplasm structure containing correct values for all fields whether they are to be changed or not.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>This function can be used to correct certain fields in the local GERMPLASM table. A call with positive GID will result in a GMS_ERROR return.
</p>
<a name="GMS_setProgenitorID" id="GMS_setProgenitorID"></a><h4> <span class="mw-headline">GMS_setProgenitorID</span></h4>
<p>GMS_setProgenitorID changes the value of a progenitor ID for germplasm GID in the local GMS database. If argument <i>iProgen </i>has value 1 or 2, the value is changed on the germplasm record, otherwise it is changed in the PROGENITORS table.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_setProgenitorID</b>(gid, iProgen,pGid)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>gid</i>
</td><td>long
</td><td>input
</td><td align="justify">GID of germplasm for which progenitor ID is to be set
</td></tr>
<tr>
<td> <i>iProgen</i>
</td><td>long
</td><td>input
</td><td>Progenitor number to be set
</td></tr>
<tr>
<td><i>pGid</i>
</td><td>long
</td><td>input
</td><td>GID to be stored as <i>iProgen</i><sup>th</sup> progenitor of germplasm GID
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>This function can be used to change the value of a progenitor ID either to another valid GID or to zero that indicates missing information on the progenitor. If  <i>iProgen</i> is 1 or 2 the value could be changed with the GMS_setGermplasm function, but GMS_setProgenitorID also works, and is the only way to change the value if  <i>iProgen</i> &gt;2. If <i>gid </i>is positive the function returns GMS_ERROR<i>.</i>
</p>
<a name="GMS_setPreferredName" id="GMS_setPreferredName"></a><h4> <span class="mw-headline">GMS_setPreferredName</span></h4>
<p>GMS_setPreferredName sets an existing, ASCII name as the preferred name of a germplasm and resets the name_status of the current preferred name to zero.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_setPreferredName </b>(<i>nameData,szPName</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>nameData</i>
</td><td>GMS_NameData*
</td><td>input
</td><td>Pointer to a GMS_NameData structure containing the name data of the existing name which is to be set as the preferred name
</td></tr>
<tr>
<td><i>szPName</i>
</td><td>char*
</td><td>input
</td><td>Pointer to a character variable containing the null terminated existing name to be set as the preferred name
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS , GMS_ERROR
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The new preferred name must exist on the NAMES table before the call to GMS-setPreferredName. The GERMPLASM_ID, NAME_USER, NVAL and NEXT fields should uniquely index the proposed preferred name. It must be an ASCII name, and not the current preferred name i.e. it must have NAME_STATUS 0 or 2. Any other value results in an error return, GMS_ERROR. If the proposed preferred name is already the preferred abbreviation then it is re-set as the preferred name. The NAME_STATUS of the existing preferred name is changed to 0 on the NAMES table. If the GERMPLASM_ID field of the <i>nameData</i> argument is positive the function returns GMS_ERROR.
</p>
<a name="GMS_setPreferredAbbr" id="GMS_setPreferredAbbr"></a><h4> <span class="mw-headline">GMS_setPreferredAbbr</span></h4>
<p>GMS_setPreferredAbbr sets an existing, ASCII name as the preferred abbreviation of a germplasm.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_setPreferredAbbr</b>(<i>namedata,szName</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>namedata</i>
</td><td>GMS_NameData*
</td><td>input
</td><td align="justify">Pointer to a GMS_NameData structure containing the name data of the existing name which is to be set as the preferred abbreviation
</td></tr>
<tr>
<td><i>szName</i>
</td><td>char*
</td><td>input
</td><td>Pointer to a character variable containing the null terminated existing name to be set as the preferred abbreviation
</td></tr>
</table>
<p><b>Returns</b>
</p><p>GMS_SUCCESS , GMS_ERROR
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The proposed preferred abbreviation must exist on the NAMES table before the call to GMS_setPreferredAbbr. The GERMPLASM_ID, NAME_USER and NVAL fields should uniquely index the proposed preferred abbreviation. It must be an ASCII name of less than eight characters and it may not be the current preferred name or preferred abbreviation i.e. it must have NAME_STATUS 0. Failure of these conditions results in an error return, GMS_ERROR . The NAME_STATUS of any existing preferred abbreviation is changed to 0 on the NAMES table. If the GERMPLASM_ID field of the <i>namedata</i> argument is positive the function returns GMS_ERROR.
</p>
<a name="GMS_setName" id="GMS_setName"></a><h4> <span class="mw-headline">GMS_setName</span></h4>
<p>GMS_setName changes the value of any field in the local NAMES given the NID.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_setName</b>(<i>nameData,szName,nszName</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>nameData
</td><td>GMS_NameData *
</td><td>input
</td><td align="justify">Pointer to a GMS-NameData structure containing correct values for all fields whether they are to be changed or not.
</td></tr>
<tr>
<td>szName
</td><td>Char *
</td><td>input
</td><td>Address of NULL terminated string to place the name
</td></tr>
<tr>
<td>nszName
</td><td>Long
</td><td>input
</td><td>Maximum size of the szName string
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>This function can be used to correct certain fields in the local NAMES table. A call with positive NID will result in a GMS_ERROR return.
</p><p>4.4.4 <b>GMS_setAttribute</b>
</p><p>GMS_setAttribute changes the value of any field in the local ATTRIBUT table given the AID.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_setAttribute</b>(<i>attrData,szAval</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>attrData
</td><td>GMS_Attribute*
</td><td>input
</td><td align="justify">Pointer to a GMS_Attribute structure containing correct values for all fields whether they are to be changed or not.
</td></tr>
<tr>
<td>szAval
</td><td>Char *
</td><td>input
</td><td>Address of NULL terminated string to contain the attribute value
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>This function can be used to correct certain fields in the local ATTRIBUT table.  If an attribute is to be deleted, change the ATYPE = 999.
</p>
<a name="BASIC_GMS_FUNCTIONS" id="BASIC_GMS_FUNCTIONS"></a><h3> <span class="mw-headline">BASIC GMS FUNCTIONS</span></h3>
<a name="GMS_generateTree" id="GMS_generateTree"></a><h4> <span class="mw-headline">GMS_generateTree</span></h4>
<p>GMS_generateTree retrieves preferred names and GIDs from the GERMPLASM table for all generative progenitors in the pedigree of germplasm <i>gid</i> down to a specified number of levels or until no further progenitors are known.
</p><p><b>Syntax:</b>
</p><p>long <b>GMS_generateTree</b>(gid,level,szBuffer,bufsz,aID,naID)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td><i>gid</i>
</td><td>long
</td><td>input
</td><td>Progenitor ID from which the tree will generate (as the root)
</td></tr>
<tr>
<td><i>level</i>
</td><td>long
</td><td>input
</td><td>Desired maximum level of the tree
</td></tr>
<tr>
<td><i>szBuffer</i>
</td><td>char *
</td><td>output
</td><td>Points to a buffer that receives a string representing the genealogical tree. The buffer is filled with one or more null-terminated strings (representing one line on the screen); the last string is followed by a second null character.
</td></tr>
<tr>
<td><i>nszBuffer</i>
</td><td>long
</td><td>input
</td><td>Specifies the size, in characters, of the buffer pointed to by the <i>szBuffer</i> parameter.
</td></tr>
<tr>
<td><i>aID</i>
</td><td>long *
</td><td>output
</td><td>Contains array of GIDs corresponding to the germplasm on each line of <i>szBuffer</i>
</td></tr>
<tr>
<td><i>naID</i>
</td><td>long
</td><td>input
</td><td>Maximum number of entries in aID
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS ,GMS_ERROR  or  GMS_MORE_DATA
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p><i>szBuffer</i> of size <i>nszBuffer</i> should be large enough to hold the whole generated tree. The routine will return GMS_MORE_DATA if the <i>szBuffer </i>does not contain the entire generated tree. Test the result for either GMS_SUCCESS or GMS_MORE_DATA. Argument <i>aID</i> returns with the list of GIDs corresponding to each line of the tree so that extra information can be extracted from the database and displayed on the tree as required. If there are more lines (entries) in the tree than spaces in <i>aID </i>(<i>naID</i>) then <b>GMS_generateTree</b> returns GMS_MORE_DATA.
</p><p>The tree is displayed horizontally. A line starting with &gt; indicates that the entry on the line above is a derivative of the entry on the current line. A line starting with + indicated that the entry on the current line is a generative progenitor of the entry above the +. Female progenitors are listed above male progenitors. ** following an entry name indicates that that entry has already been expanded in the current tree. &lt; following an entry indicates that there is further pedigree information available on that entry.
</p>
<a name="Code_Example:" id="Code_Example:"></a><h5> <span class="mw-headline">Code Example:</span></h5>
<p>The following code will display the generated tree:
</p>
<a name="CODEEXAMPLE_OUTPUT" id="CODEEXAMPLE_OUTPUT"></a><h5> <span class="mw-headline">CODEEXAMPLE OUTPUT</span></h5>
<table border="0" cellspacing="2" width="100%">
<tr>
<td><font size="1">
</td><td>char *p;
</td><td>&nbsp;
</td><td>&nbsp;
</td><td>&nbsp;
</td><td colspan="2">IR8</font>
</td></tr>
<tr>
<td><font size="1">
</td><td>p = szBuffer;
</td><td>&nbsp;
</td><td>&nbsp;
</td><td>&nbsp;
</td><td colspan="2">&gt; IR8</font>
</td></tr>
<tr>
<td colspan="3"><font size="1">
</td><td>while (*p!=\0)
</td><td>&nbsp;
</td><td>&nbsp;
</td><td>+--- PETA</font>
</td></tr>
<tr>
<td colspan="4"><font size="1">
</td><td>{  // dump to the console
</td><td>&nbsp;
</td><td>|    &gt; PETA</font>
</td></tr>
<tr>
<td colspan="3"><font size="1">
</td><td>   printf("s \n",p);
</td><td>&nbsp;
</td><td>&nbsp;
</td><td>|    +---CINA</font>
</td></tr>
<tr>
<td colspan="4"><font size="1">
</td><td>   p = p + strlen(p)+1;
</td><td>&nbsp;
</td><td>|    +---LATISAIL</font>
</td></tr>
<tr>
<td><font size="1">
</td><td>}
</td><td>&nbsp;
</td><td>&nbsp;
</td><td>&nbsp;
</td><td>&nbsp;
</td><td>+--- DEE-GEO-WOO-GEN</font>
</td></tr>
</table>
<a name="GMS_crossExpansion:" id="GMS_crossExpansion:"></a><h4> <span class="mw-headline">GMS_crossExpansion:</span></h4>
<p>GMS_crossExpansion interrogates the GMS recursively to generate a Purdey cross expansion for germplasm <i>gid.  </i>The expansion terminates after <i>level</i> generations or whenever a progenitor has a name of type <i>ntype</i>. The cross expansion is returned in argument <i>szBuffer</i>, and the list of GIDs for elements in the cross expansion (from left to right) is returned in array <i>aID</i>.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_crossExpansion</b>(gid,level,ntype,szBuffer,nszBuffer,aID,naID)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td><i>gid</i>
</td><td>long
</td><td>input
</td><td>germplasm id
</td></tr>
<tr>
<td><i>level</i>
</td><td>long
</td><td>input
</td><td>level of expansion
</td></tr>
<tr>
<td><i>ntype</i>
</td><td>Long
</td><td>Input
</td><td>Name type (i.e., 7-preferred name, 6-preferred abbreviation, etc.)
</td></tr>
<tr>
<td><i>szBuffer</i>
</td><td>char *
</td><td>output
</td><td>pointer to null terminated string containing the cross expansion string generated
</td></tr>
<tr>
<td><i>nszBuffer</i>
</td><td>long
</td><td>input
</td><td>maximum data size szBuffer can hold (including the null terminator).
</td></tr>
<tr>
<td><i>Aid</i>
</td><td>long *
</td><td>output
</td><td>an array of long integer containing the list of germplasm id
</td></tr>
<tr>
<td><i>naID</i>
</td><td>long
</td><td>input
</td><td>maximum size of the idList
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_ERROR, GMS_SUCCESS, GMS_MORE_DATA ,GMS_NO_DATA
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>Progenitors preferred name is the default name used when <i>ntype</i> is zero.  A <i>generation</i> is taken to be a generative process involving only derivative progenitors or a sequence of generative processes with the last one involving only derivative progenitors.  Thus a series of back crosses is one generation (back to the original single cross) and a triple cross or double cross generation involves two generative steps.
</p><p>If the input parameter <i>ntype</i> is specified (&gt;0) the expansion is built from progenitors having names of the specified type or preferred names of progenitors <i>level</i> generations back in the pedigree, whichever occurs first.
</p><p>Generative progenitors with one parent (mutations) are represented as &lt;parent&gt; /.  And ones with more than two parents as &lt;parent1&gt;/[&lt;parent2&gt;,&lt;parent3&gt;, ].  GMS_crossExpansion will not expand parents other than the first one.
</p><p>The routine returns GMS_MORE_DATA if either the szBuffer or idList is not large enough to hold the data. If the routine encounters a missing group ID in any source expansion of that branch it terminates with the name of that source. If it encounters a missing progenitor ID in any cross before <i>level</i> generations it places a query ? in the cross expansion at that point and terminates expansion of that branch.
</p>
<a name="GMS_listNames" id="GMS_listNames"></a><h4> <span class="mw-headline">GMS_listNames</span></h4>
<p>GMS_listNames searches the database for all names of germplasm <i>gid </i>and returns them in a null delimited test string.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_listNames</b>(gid,szBuffer,nszBuffer)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td><i>gid</i>
</td><td>long
</td><td>input
</td><td>germplasm id
</td></tr>
<tr>
<td><i>szBuffer</i>
</td><td>char *
</td><td>output
</td><td>pointer to null terminated string containing the list of Names
</td></tr>
<tr>
<td><i>nszBuffer</i>
</td><td>long
</td><td>input
</td><td>maximum data size szBuffer can hold (including the null terminator).
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_ERROR, GMS_SUCCESS, GMS_MORE_DATA ,GMS_NO_DATA
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>Names in szBuffer are separated by null characters and the whole list is terminated with two null characters. The function only searches the central database when <i>gid</i> is positive, but it always searches the local database. The preferred name (NSTAT = 1) is placed first in the list.
</p>
<a name="GMS_computeGenerationNo" id="GMS_computeGenerationNo"></a><h4> <span class="mw-headline">GMS_computeGenerationNo</span></h4>
<p>GMS_computeGenerationNo traces pedigrees through derivative and management generations and returns statistics indicating the number of each type of generation advance - derivative or management, and the last generation at which seed was harvested from a single plant or at which chromosome doubling was carried. GMS_computeGenerationNo also returns the type of method used in the last generation and/or the type of generative method most recently used. If the last generative method is a backcross, GMS_computeGenerationNo returns the number of crosses to the recurrent parent.
</p><p><b>Syntax:</b>
</p><p>long <b>GMS_computeGenerationNo</b>(gid,LSPS,NGEN,MAN,NBC,LDM,MCR)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td><i>gid</i>
</td><td>long
</td><td>input
</td><td>Germplasm ID from which the generation number will be computed
</td></tr>
<tr>
<td><i>LSPS</i>
</td><td>long *
</td><td>output
</td><td>Number of derivative generations from the cross to the last single plant selection or single seed descent (zero for F1s)
</td></tr>
<tr>
<td><i>NGEN</i>
</td><td>long *
</td><td>output
</td><td>Total number of generations from the cross (1 for F1s)
</td></tr>
<tr>
<td><i>MAN</i>
</td><td>long*
</td><td>output
</td><td>Number of management generations
</td></tr>
<tr>
<td><i>NBC</i>
</td><td>long *
</td><td>output
</td><td>Backcross dosage (zero for other cross types)
</td></tr>
<tr>
<td><i>LDM</i>
</td><td>Long *
</td><td>output
</td><td>ICIS method code for the last derivative method (zero for F1s)
</td></tr>
<tr>
<td><i>MCR</i>
</td><td>long *
</td><td>output
</td><td>ICIS method code for the last generative method
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS ,GMS_ERROR  or GMS_NO_DATA
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>NGEN and LSPS return with zero if there is an unknown source (GPID2=0) in any generation after the cross. This should usually be interpreted as complete inbreeding for self pollinating crops and as F1s for open pollinating species. If there are no unknown sources NGEN returns the number of derivative generations from the cross to the current generation, counting 1 for the cross and ignoring any management generations. If a double haploid method is used (method numbers 202 or 502 in Annex 2.2.b then LSPS returns minus the number of the derivative generation after the cross when this occurred otherwise LSPS returns the derivative generation number after the cross where the last single plant selection (method numbers 205, 504 in Annex 2.2.b) or single seed descent occurred (method numbers 208, 505 in Annex 2.2.b) or zero of none of these methods occur.
</p><p>MAN returns the number of generations where management methods (MTYPE=MAN in the METHODS Table) have been used between the group source and the current generation. NBC returns the number of crosses to a recurrent parent if the crossing method is backcross (method numbers 107 or 4 in Annex 2.2.b) otherwise NBC=0.
</p><p><b>Code Example:</b>
</p><p>I4=GMS_computeGenerationNo(GID,LSPS,NGEN,MAN,NBC,LDM,MCR)
</p><p>WRITE(0,130) LSPS,NGEN,MAN,NBC,LDM,MCR
</p><p>130       FORMAT(6I8)
</p><p>For IR 80000-B-B-S-B-B-B-B-B where B stands for bulk and S stands for single plant selection, this gives:
</p><p>3       9        0        0     204     101
</p><p>Notice that IR 80000 labels the F1, IR 80000-B labels the plot of F2s,  IR 80000-B-B labels the plot of F3s and  IR 80000-B-B-S represents the F4 seed from one F3 plant and labels the F4 row, ie  IR 80000-B-B-S is an F3 derived F4.
</p>
<a name="GMS_getDerivativeNeighbor" id="GMS_getDerivativeNeighbor"></a><h4> <span class="mw-headline">GMS_getDerivativeNeighbor</span></h4>
<dl><dd>GMS_getDerivativeNeighbor retrieves all germplasm in the derivative neighborhood of the given GID, m-step backward and n-step forward
</dd></dl>
<dl><dd><b>Syntax</b>
</dd><dd>long <b>GMS_getDerivativeNeighbor</b> (<i>gid, MStep,NStep,idList,idLstSz, blnDH</i>)
</dd></dl>
<dl><dd><b>Arguments</b>
</dd></dl>
<dl><dd><table border="1">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>gid
</td><td>long
</td><td>input
</td><td>The GID of the target germplasm
</td></tr>
<tr>
<td>MStep
</td><td>long
</td><td>input
</td><td>Number of step backward within the generation history  from the level of the target germplasm
</td></tr>
<tr>
<td>NStep
</td><td>long
</td><td>input
</td><td>Number of step forward within the generation history  from the level of the target germplasm
</td></tr>
<tr>
<td>idList
</td><td>long *
</td><td>output
</td><td>Array that will contain the germplasm within the specified level of derivative neighborhood
</td></tr>
<tr>
<td>idLstSz
</td><td>long *
</td><td>input/output
</td><td>As input, it is the maximum length of idList and as output, it is the number of germplasms retrieved if lower than the maximum length
</td></tr>
<tr>
<td>blnDH
</td><td>long
</td><td>input
</td><td>1 if Double Haploid germplasm is to be excluded as part of derivative neighborhood
</td></tr></table></dd></dl>
<p><br />
Note:  
</p>
<ul><li>Double Haploid option is not yet working very well
</li><li>Lines with derivative or management methods (GNPGS &lt; 0) are considered.
</li><li>The algorithm is a recursion which is called n+m times
</li></ul>
<p>Algorithm:  
</p>
<ol><li>Determine the root of the required neighborhood which is either the germplasm m backward step within the generation history of the specified target GID or its group germplasm if m is greater than generation level of the target GID
</li><li> Starting from the root, get the immediate derived lines 
</li><li> For each retrieved line, get the succeeding derived lines
</li><li> Repeat the 3rd step (n+m-2) times
</li></ol>
<a name="GMS_getMgmntNeighbor" id="GMS_getMgmntNeighbor"></a><h4> <span class="mw-headline">GMS_getMgmntNeighbor</span></h4>
<dl><dd>GMS_getMgmntNeighbor retrieves the management neighbors of the given management group germplasm
</dd></dl>
<dl><dd><b>Syntax</b>
</dd><dd>long <b>GMS_getMgmntNeighbor</b> (<i>mgid, data, name, szName, nszName, fopt</i>)
</dd></dl>
<dl><dd><b>Arguments</b>
</dd></dl>
<dl><dd><table border="1">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>mgid
</td><td>long
</td><td>input
</td><td>The GID of the root of the management group
</td></tr>
<tr>
<td>data
</td><td>GMS_Germplasm*
</td><td>output
</td><td>The germplasm record of the management neighbor
</td></tr>
<tr>
<td>name
</td><td>GMS_NameData*
</td><td>output
</td><td>The name record of the management neighbor
</td></tr>
<tr>
<td>szName
</td><td>Char*
</td><td>output
</td><td>Array of characters for the preferred name of the management neighbor
</td></tr>
<tr>
<td>nszName
</td><td>long
</td><td>input
</td><td>length of the szName
</td></tr>
<tr>
<td>fopt
</td><td>long
</td><td>input
</td><td>0 if getting the first record, 1 for succeeding record
</td></tr></table></dd></dl>
<a name="LIST_DLL_FUNCTIONS" id="LIST_DLL_FUNCTIONS"></a><h2> <span class="mw-headline">LIST DLL FUNCTIONS</span></h2>
<p>The GMS_openDatabase function mentioned in Section 3.1 should be called first before calling any functions mentioned in this section.  The different data structures used by the functions are discussed in section 2.
</p>
<a name="FUNCTIONS_ASSOCIATED_TO_LISTNMS_TABLE" id="FUNCTIONS_ASSOCIATED_TO_LISTNMS_TABLE"></a><h3> <span class="mw-headline">FUNCTIONS ASSOCIATED TO LISTNMS TABLE</span></h3>
<a name="GMS_getListName" id="GMS_getListName"></a><h4> <span class="mw-headline">GMS_getListName</span></h4>
<p>GMS_getListName retrieves a specific record from LISTNMS table for a particular value of <i>listid</i> field of GMS_ListName structure. To retrieve all records in the table initialize <i>listid</i> to zero, <i>fOpt</i> to FIND_FIRST for the first call and FIND_NEXT for the succeeding calls.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_getListName</b>(<i>listName</i>, <i>fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td><i>listName</i>
</td><td>GMS_ListName *
</td><td>input/output
</td><td>Address of a GMS_ListName structure to contain the list name for the retrieved record
</td></tr>
<tr>
<td><i>FOpt</i>
</td><td>long
</td><td>output
</td><td>either FIND_FIRST or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_NO_DATA, GMS_ERROR
</p><p><br />
</p>
<a name="GMS_findListName" id="GMS_findListName"></a><h4> <span class="mw-headline">GMS_findListName</span></h4>
<p>GMS_findListName retrieves records from LISTNMS table where the list name matches the given string szLName. Set <i>fOpt</i> to FIND_FIRST for the first call and FIND_NEXT for the succeeding calls.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_getListName</b>(<i>szLName</i>,<i>listName</i>, <i>fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td><i>szLName</i>
</td><td>String
</td><td>input
</td><td>Address of NULL terminated string containing the name to search
</td></tr>
<tr>
<td><i>listName</i>
</td><td>GMS_ListName *
</td><td>input/output
</td><td>Address of a GMS_ListName structure to contain the list name for the retrieved record
</td></tr>
<tr>
<td><i>FOpt</i>
</td><td>long
</td><td>output
</td><td>either FIND_FIRST or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_NO_DATA, GMS_ERROR
</p>
<a name="GMS_setListName" id="GMS_setListName"></a><h4> <span class="mw-headline">GMS_setListName</span></h4>
<p>GMS_setListName changes the value of all the fields in the local LISTNMS table except the LISTID field for a given <i>listid</i>.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_setListName</b>(<i>listName</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td><i>listName</i>
</td><td>GMS_ListName *
</td><td>input
</td><td>Address of a GMS_ListName structure
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR
</p>
<a name="GMS_addListName" id="GMS_addListName"></a><h4> <span class="mw-headline">GMS_addListName</span></h4>
<p>GMS_addListName adds one record to the LISTNMS table assigning value automatically to LISTID field.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_addListName</b>(<i>listName</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td><i>listName</i>
</td><td>GMS_ListName *
</td><td>input
</td><td>Address of a GMS_ListName structure
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR
</p>
<a name="GMS_deleteListName" id="GMS_deleteListName"></a><h4> <span class="mw-headline">GMS_deleteListName</span></h4>
<p>GMS_deleteListName deletes one record from the LISTNMS table for a given <i>listid</i>.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long GMS_deleteListName(<i>listid</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td><i>listid</i>
</td><td>Long
</td><td>input
</td><td>value of LISTID of which LISTNAME record to delete
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR
</p>
<a name="GMS_getListByStatus" id="GMS_getListByStatus"></a><h4> <span class="mw-headline">GMS_getListByStatus</span></h4>
<p>GMS_getListByStatus retrieves records from LISTNMS table for the given list status in the GMS_ListName structure. Set  <i>fOpt</i> to FIND_FIRST for the first call and FIND_NEXT for the succeeding calls.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_getListByStatus</b>(<i>listName</i>, <i>fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td><i>listName</i>
</td><td>GMS_ListName *
</td><td>input/output
</td><td>Address of a GMS_ListName structure to contain the list name for the retrieved record
</td></tr>
<tr>
<td><i>FOpt</i>
</td><td>Long
</td><td>output
</td><td>either FIND_FIRST or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_NO_DATA, GMS_ERROR
</p>
<a name="FUNCTIONS_ASSOCIATED_WITH_LISTDATA_TABLE" id="FUNCTIONS_ASSOCIATED_WITH_LISTDATA_TABLE"></a><h3> <span class="mw-headline">FUNCTIONS ASSOCIATED WITH LISTDATA TABLE</span></h3>
<a name="GMS_getListData" id="GMS_getListData"></a><h4> <span class="mw-headline">GMS_getListData</span></h4>
<p>GMS_getListData retrieves records from the LISTDATA table for  given <i>listid </i>and<i> gid </i>or<i> </i> <i>listid</i> and <i>entryid </i>values specified in the LISTID, GID and ENTRYID fields of the GMS_ListData structure.<b>   </b>A valid <i>listid</i> value must be specified, but the <i>gid</i> and <i>entryid</i> may be zero in<b> </b>which case all entries for the specified list will be retrieved. If <i>gid</i> is non zero, <i>entryid</i> must be zero and entries with specified <i>listid</i> and <i>gid</i> will be retrieved. If <i>entryid</i> is non zero, <i>gid</i> must be zero and the entry with the specified <i>listid </i>and <i>entryid</i> will be retrieved. <b> </b><i>fOpt</i> should be set equal to FIND_FIRST on the first call, and FIND_NEXT in the succeeding calls.  (If <i>entryid</i> is specified,  <i>fOpt</i> should be FIND_FIRST since there can only be one result record.) Search parameters are set when <i>fOpt</i> is FIND_FIRST, and input values in the ListData argument are ignored when <i>fOpt </i>is FIND_NEXT.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long GMS_getListData(<i>listData</i>, <i>fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td><i>listData</i>
</td><td>GMS_ListData *
</td><td>input/output
</td><td>Address of a GMS_ListData structure
</td></tr>
<tr>
<td><i>fOpt</i>
</td><td>long
</td><td>output
</td><td>either FIND_FIRST or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR
</p>
<a name="GMS_findListData" id="GMS_findListData"></a><h4> <span class="mw-headline">GMS_findListData</span></h4>
<p>GMS_findListData retrieves all records from the LISTDATA table for  given <i> gid </i>value specified in the GID  field of the GMS_ListData structure.   <i>fOpt</i> should be set equal to FIND_FIRST on the first call, and FIND_NEXT in the succeeding calls.   Search parameters are set when <i>fOpt</i> is FIND_FIRST, and input values in the ListData argument are ignored when <i>fOpt </i>is FIND_NEXT.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long GMS_getListData(<i>listData</i>, <i>fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td><i>listData</i>
</td><td>GMS_ListData *
</td><td>input/output
</td><td>Address of a GMS_ListData structure
</td></tr>
<tr>
<td><i>fOpt</i>
</td><td>long
</td><td>output
</td><td>either FIND_FIRST or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR
</p>
<a name="GMS_setListData" id="GMS_setListData"></a><h4> <span class="mw-headline">GMS_setListData</span></h4>
<p>GMS_setListData changes the value of fields in the local LISTDATA table for given <i>listid</i> and <i>lrecid</i> fields of GMS_ListData structure.  (Note the LISTID and LRECID fields cannot be changed.) 
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_setListData</b>(<i>listData</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td><i>listData</i>
</td><td>GMS_ListData *
</td><td>input
</td><td>Address of a GMS_ListData structure
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR
</p>
<a name="GMS_addListData" id="GMS_addListData"></a><h4> <span class="mw-headline">GMS_addListData</span></h4>
<p>GMS_addListData adds one record to the LISTDATA table assigning value automatically to ENTRYID field.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_addListData</b>(<i>listData</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td><i>listData</i>
</td><td>GMS_ListData *
</td><td>input
</td><td>Address of a GMS_ListData structure
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR
</p>
<a name="GMS_deleteListData" id="GMS_deleteListData"></a><h4> <span class="mw-headline">GMS_deleteListData</span></h4>
<p>GMS_deleteListData deletes records from the LISTDATA table for a given <i>listid</i> or,<i> listid</i> and<i> lrecid</i>. If <i>lrecid</i> is zero the function will delete all records where <i>listid</i>=LISTID, otherwise delete record where<i> listid</i>=LISTID and <i>entryid</i>=ENTRYID.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_deleteListData</b>(<i>listid</i>, <i>lrecid</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td><i>listid</i>
</td><td>Long
</td><td>input
</td><td align="justify">value of LISTID of which LISTDATA record to delete
</td></tr>
<tr>
<td><i>lrecid</i>
</td><td>Long
</td><td>input
</td><td align="justify">value of LRECID, if LRECID is not zero, with the condition above applied of which LISTDATA record to delete
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR
</p>
<a name="USER_DEFINED_FIELDS_AND_CONSTANTS_FUNCTIONS" id="USER_DEFINED_FIELDS_AND_CONSTANTS_FUNCTIONS"></a><h2> <span class="mw-headline">USER DEFINED FIELDS AND CONSTANTS FUNCTIONS</span></h2>
<a name="GMS_getUDField" id="GMS_getUDField"></a><h4> <span class="mw-headline">GMS_getUDField</span></h4>
<p>GMS_getUDField will retrieve details of any user-defined field from the UDFLDS table. The first argument of GMS_getUDField is a pointer to a GMS_UDField structure.  If the FLDNO is not zero when the function is called then it returns the details for the corresponding user defined field.  If it is zero then the function returns details for the first user defined field if <i>fOpt </i>= FIND_FIRST or for the next available user defined field if <i>fOpt </i>= FIND_NEXT. Any call which fails to get user defined field information returns GMS_NO_DATA.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_getUDField</b>(UDField, szFDesc, nszFDesc, fOpt)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>UDField
</td><td>GMS_UDField*
</td><td>input/<br />output
</td><td>Address of a GMS_UDField structure
</td></tr>
<tr>
<td>szFDesc
</td><td>char *
</td><td>output
</td><td>Address of a string variable to contain the field description as a NULL terminated string
</td></tr>
<tr>
<td>nszFDesc
</td><td>Long
</td><td>input
</td><td>Maximum size of <i>szFDesc</i>
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>input
</td><td>Either FIND_FIRST  or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The principle of using GMS_getUDField is almost the same as GMS_getAttribute. If the function is called and there was a problem accessing the database, the function will return GMS_ERROR.
</p><p><br />
</p>
<a name="GMS_getUDField2" id="GMS_getUDField2"></a><h4> <span class="mw-headline">GMS_getUDField2</span></h4>
<p>GMS_getUDField2 will retrieve the allowable constant values for a column (FTYPE) of an ICIS table (FTABLE). The first argument is a pointer to a GMS_UDField structure where FTABLE and FTYPE are given. If fopt is FIND_FIRST (0),  the function retrieves the first matched record.  If fopt is FIND_NEXT (1), details about the succeeding matched record is retreived .Any call which fails to get user defined field information returns GMS_NO_DATA.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_getUDField2</b>(UDField, szFDesc, nszFDesc, fOpt)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>UDField
</td><td>GMS_UDField*
</td><td>input/<br />output
</td><td>Address of a GMS_UDField structure
</td></tr>
<tr>
<td>szFDesc
</td><td>char *
</td><td>output
</td><td>Address of a string variable to contain the field description as a NULL terminated string
</td></tr>
<tr>
<td>nszFDesc
</td><td>Long
</td><td>input
</td><td>Maximum size of <i>szFDesc</i>
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>input
</td><td>Either FIND_FIRST  or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p><p><br />
</p>
<a name="GMS_findUDField" id="GMS_findUDField"></a><h4> <span class="mw-headline">GMS_findUDField</span></h4>
<p>GMS_findUDField searches for UDFLDS record with name matching the string FNAME. The first argument is a pointer to a GMS_UDField structure where FNAME is given. If fopt is FIND_FIRST (0),  the function retrieves the first matched record.  If fopt is FIND_NEXT (1), details about the succeeding matched record is retreived .Any call which fails to get user defined field information returns GMS_NO_DATA.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_findUDField</b>(UDField, szFDesc, nszFDesc, fOpt)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>UDField
</td><td>GMS_UDField*
</td><td>input/<br />output
</td><td>Address of a GMS_UDField structure
</td></tr>
<tr>
<td>szFDesc
</td><td>char *
</td><td>output
</td><td>Address of a string variable to contain the field description as a NULL terminated string
</td></tr>
<tr>
<td>nszFDesc
</td><td>Long
</td><td>input
</td><td>Maximum size of <i>szFDesc</i>
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>input
</td><td>Either FIND_FIRST  or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<a name="DMS_DLL_FUNCTIONS" id="DMS_DLL_FUNCTIONS"></a><h2> <span class="mw-headline">DMS DLL FUNCTIONS</span></h2>
<table border="0" cellspacing="2" width="100%">
<tr>
<td>
</td><td>&nbsp;
</td><td>&nbsp;
</td><td>&nbsp;
</td><td>&nbsp;
</td><td>
</td></tr>
</table>
<a name="INTRODUCTION_3" id="INTRODUCTION_3"></a><h3> <span class="mw-headline">INTRODUCTION</span></h3>
<p>The DMS_openDatabase function mentioned should be called first before calling any functions mentioned in this section.  The different data structures used by the functions are discussed in section IV.I.2.
</p>
<a name="ADD_FUNCTIONS" id="ADD_FUNCTIONS"></a><h3> <span class="mw-headline">ADD FUNCTIONS</span></h3>
<a name="DMS_addStudy" id="DMS_addStudy"></a><h4> <span class="mw-headline">DMS_addStudy</span></h4>
<p>DMS_addStudy adds new study record in the DMS database according to the information in the STUDY argument. STUDYID is automatically assigned by the function.   The name of the study should be unique.  If a study with similar name already exists in the database, the function returns DMS_EXIST  (-5).
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_addStudy</b>(<i>STUDY, szObjective</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>STUDY
</td><td>DMS_STUDY
</td><td>Input
</td><td>Address of the DMS_STUDY structure  that contains the information to be added to the database.<br />
</td></tr>
<tr>
<td>szObjective
</td><td>Char*
</td><td>Input
</td><td>The pointer to a null terminated string containing the objective of the Study<br />
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_EXIST(-5), DMS_ERROR(-1)
</p>
<a name="DMS_addFactor" id="DMS_addFactor"></a><h4> <span class="mw-headline">DMS_addFactor</span></h4>
<p>DMS_addFactor adds new factor of a given study (STUDYID) according to the information in the FACTOR argument.  FACTORID is automatically assigned by the function.  Factor name should be unique within a study.  Hence, if a factor with similar name exists in the given study, the function returns DMS_EXIST (-5). If the STUDYID  does not exist in the database,  DMS_INVALID_ID (-9) is returned.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_addFactor</b>(<i>FACTOR)</i>
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>FACTOR
</td><td>DMS_FACTOR
</td><td>Input
</td><td>Address of the DMS_FACTOR  structure that contains the information to be added to the database<br />.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_EXIST(-5), DMS_INVALID_ID(-9),DMS_ERROR(-1)
</p>
<a name="DMS_addVariate" id="DMS_addVariate"></a><h4> <span class="mw-headline">DMS_addVariate</span></h4>
<p>DMS_addVariate adds new variate of a given study (STUDYID) according to the information in the VARIATE argument. VARIATID is automatically assigned by the function. Variate name should be unique within the study.  Hence, if a variate with similar name exists in the given study, the function returns DMS_EXIST (-5). If the STUDYID  does not exist in the database,  DMS_INVALID_ID (-9) is returned.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_addVariate</b>(<i>VARIATE</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>VARIATE
</td><td>DMS_VARIATE
</td><td>Input
</td><td>Address of the DMS_VARIATE  structure that contains the information to be added to the database<br />.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_EXIST(-5), DMS_INVALID_ID(-9),DMS_ERROR(-1)
</p>
<a name="DMS_addLevelN" id="DMS_addLevelN"></a><h4> <span class="mw-headline">DMS_addLevelN</span></h4>
<p><b>DMS_addLevelN</b> adds new level of a particular factor (FACTORID) having numeric type  according to the information in the LEVELN argument.  LEVELNO is assigned by the function and it is unique within a factor.  If there is a level of similar value for that factor, DMS_EXIST is returned by the function. If the FACTORID  does not exist in the database,  DMS_INVALID_ID (-9) is returned.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_addLevelN</b>(<i>LEVELN</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>LEVELN
</td><td>DMS_LEVELN
</td><td>Input
</td><td>Address of the DMS_LEVELN  structure that contains the information to be added to the database.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_EXIST(-5), DMS_INVALID_ID(-9),DMS_ERROR(-1)
</p>
<a name="DMS_addLevelC" id="DMS_addLevelC"></a><h4> <span class="mw-headline">DMS_addLevelC</span></h4>
<p>DMS_addLevelC adds new level of a particular factor (FACTORID) having character type  according to the information in the LEVELC argument. The LEVELNO is assigned by the function and it is unique within a factor.  If there is a level of similar value for that factor, DMS_EXIST is returned by the function. If the FACTORID  does not exist in the database,  DMS_INVALID_ID (-9) is returned.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_addLevelC</b><i>(LEVELC</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>LEVELC
</td><td>DMS_LEVELC
</td><td>Input
</td><td>Address of the DMS_LEVELC  structure that contains the information to be added to the database.<br />
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_EXIST(-5), DMS_INVALID_ID(-9),DMS_ERROR(-1)
</p>
<a name="DMS_addDataN" id="DMS_addDataN"></a><h4> <span class="mw-headline">DMS_addDataN</span></h4>
<p>DMS_addDataN adds new data value for a particular variate of numeric type according to the information in the DATAN argument.  If either  OUNITID or VARIATID does not exist in the database, the function returned DMS_INVALID_ID (-9).
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_addDataN</b>(<i>DATAN</i>);
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td>Argument
</td><td>Type
</td><td>Use
</td><td>Description
</td></tr>
<tr>
<td>DATAN
</td><td>DMS_DATAN
</td><td>Input
</td><td>Address of the DMS_DATAN  structure that contains the information to be added to the database.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_INVALID_ID(-9), DMS_ERROR(-1)
</p>
<a name="DMS_addDataC" id="DMS_addDataC"></a><h4> <span class="mw-headline">DMS_addDataC</span></h4>
<p>DMS_addDataC adds new data value for a particular variate of character type according to the information in the DATAC argument.  If either  OUNITID or VARIATID does not exist in the database, the function returned DMS_INVALID_ID (-9).
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_addDataC</b>(<i>DATAC</i>);
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>DATAC
</td><td>DMS_DATAC
</td><td>Input
</td><td>Address of the DMS_DATAC  structure that contains the information to be added to the database.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_INVALID_ID(-9), DMS_ERROR(-1)
</p>
<a name="DMS_addObsunit" id="DMS_addObsunit"></a><h4> <span class="mw-headline">DMS_addObsunit</span></h4>
<p>DMS_addObsUnit creates new observation unit for a given study.  The information required by the function is the STUDYID.  A new observation unit  (OUNITID)  is assigned by the function.  If STUDYID is non-existing, DMS_EXIST (-5) is returned.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_addObsunit</b>(<i>OBS</i>);
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>OBS
</td><td>DMS_OBSUNIT
</td><td>Input
</td><td>Address of the DMS_OBSUNIT structure that contains the information  to be added to the database<br />.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_EXIST(-5), DMS_ERROR(-1)
</p>
<a name="DMS_addOindex" id="DMS_addOindex"></a><h4> <span class="mw-headline">DMS_addOindex</span></h4>
<p>DMS_addOindex adds new factor level defining an observation unit.  OUNITID, FACTORID and LEVELNO should all be existing in the database or else the function returns DMS_INVALID_ID (-9).
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_addOindex</b>(<i>OINDEX</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>OINDEX
</td><td>DMS_OINDEX
</td><td>Input
</td><td>Address of the DMS_OINDEX  structure that contains the information to be added to the database.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_INVALID_ID(-9), DMS_ERROR(-1)
</p>
<a name="0__DMS_addAttr" id="0__DMS_addAttr"></a><h4> <span class="mw-headline">0  DMS_addAttr</span></h4>
<p>DMS_addAttr adds new attribute associated to either the STUDY,FACTOR or VARIATE table.to the DMSATTR table.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_addAttr</b>(Attr)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>Attr
</td><td>DMS_ATTR
</td><td>Input
</td><td>Address of the DMS_DMSATTR  structure that contains the information to be added to the database.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1)
</p>
<a name="DMS_addTrait" id="DMS_addTrait"></a><h4> <span class="mw-headline">DMS_addTrait</span></h4>
<p>DMS_addTrait adds new trait according to the information in the TRAIT argument with trait name being unique. TRAITID is automatically assigned by the function.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_addTrait</b>(<i>Trait,szObj</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>Trait
</td><td>DMS_TRAIT
</td><td>Input
</td><td>Address of the DMS_TRAIT  structure that contains the information to be added to the database.
</td></tr>
<tr>
<td>szObj
</td><td>Char*
</td><td>Input
</td><td>Address of  a null terminated string that contains the objective of the Study.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1)
</p>
<a name="DMS_addScale" id="DMS_addScale"></a><h4> <span class="mw-headline">DMS_addScale</span></h4>
<p>DMS_addScale adds new scale for a triat according to the information in the SCALE argument with scale name being unique within the trait. SCALEID is automatically assigned by the function.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_addScale</b><i>(Scale)</i>
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>Scale
</td><td>DMS_SCALE
</td><td>Input
</td><td>Address of the DMS_SCALE  structure that contains the information to be added to the database.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1)
</p>
<a name="DMS_addTmethod" id="DMS_addTmethod"></a><h4> <span class="mw-headline">DMS_addTmethod</span></h4>
<p>DMS_addTmethod adds new method for a trait according to the information in the TMETH argument with method name being unique within the trait. TMETHID is automatically assigned by the function.
</p><p>Syntax
</p><p>long <b>DMS_addTmethod</b><i>(Tmeth,szDesc)</i>
</p><p>Arguments
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>Tmeth
</td><td>DMS_TMETHOD
</td><td>Input
</td><td>Address of the DMS_TMETHOD  structure that contains the information to be added to the database.
</td></tr>
<tr>
<td>szDesc
</td><td>Char*
</td><td>Input
</td><td>Address of a null terminated string that contains the description of the method.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1)
</p>
<a name="DMS_addEffect" id="DMS_addEffect"></a><h4> <span class="mw-headline">DMS_addEffect</span></h4>
<p>DMS_addEffect adds new representation of an effect by appending the list of factors that defines the representation to the EFFECT table.
</p><p>Syntax
</p><p>long <b>DMS_addEffect</b><i> (lstfactor,  nfactor, represno, effectid)</i>
</p><p>Arguments
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>lstfactor
</td><td>long*
</td><td>Input
</td><td>Address of a list of factors that defines the representation of an effect
</td></tr>
<tr>
<td>nfactor
</td><td>long
</td><td>Input
</td><td>The number of factors in the list.
</td></tr>
<tr>
<td>represno
</td><td>Long*
</td><td>Output
</td><td>The assigned number of the representation
</td></tr>
<tr>
<td>effectid
</td><td>Char*
</td><td>Input
</td><td>Address of a null terminated string that contains the description of the method.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_EXIST(-5), DMS_INVALID_ID(-9),DMS_ERROR(-1)
</p>
<a name="DMS_addVEffect" id="DMS_addVEffect"></a><h4> <span class="mw-headline">DMS_addVEffect</span></h4>
<p>DMS_addVEffect adds a variate of  an effect representation to the VEFFECT table.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_addVEffect</b><i> (veffect))</i>
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>veffect
</td><td>DMS_VEFFECT
</td><td>Input
</td><td>Address of the DMS_VEFFECT structure to contain the representation number and the variate id.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_EXIST(-5), DMS_ERROR(-1)
</p>
<a name="DMS_FIND_FUNCTIONS" id="DMS_FIND_FUNCTIONS"></a><h3> <span class="mw-headline">DMS FIND FUNCTIONS</span></h3>
<p>The find functions search the DMS database based on a give name or value.
</p>
<a name="DMS_findStudy" id="DMS_findStudy"></a><h4> <span class="mw-headline">DMS_findStudy</span></h4>
<p><b>DMS_findStudy </b> searches for study with name matching the string <i>szStudy</i>.  If fopt is FIND_FIRST (0),  the function stores the study details of the first matched record.  If fopt is FIND_NEXT (1), details about the succeeding matched record is retreived .
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_findStudy</b>(<i>szStudy, STUDY, fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>szStudy
</td><td>Char*
</td><td>Input
</td><td>Address of NULL terminated string containing the string to be matched<br />
</td></tr>
<tr>
<td>STUDY
</td><td>DMS_STUDY
</td><td>Output
</td><td>Address of the DMS_STUDY structure  to contain  the study data of the retrieved record.<br />
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST(0) or FIND_NEXT(1)<br />
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_NO_DATA(0), DMS_ERROR(-1)
</p>
<a name="DMS_findFactor" id="DMS_findFactor"></a><h4> <span class="mw-headline">DMS_findFactor</span></h4>
<p><b>DMS_findFactor </b>searches for factor with name matching <i>szName</i>.  If STUDYID is zero, the function looks for all factors having the matched name; otherwise, the function considers factor names within the given study. If fopt is FIND_FIRST (0), the function stores the factor details of the first matched record.  If fopt is FIND_NEXT, details about the succeeding matched record is stored..
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_findFactor</b>(<i>szName, FACTOR, fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>szName
</td><td>Char*
</td><td>Input
</td><td>Address of NULL terminated string containing the string to be matched<br />
</td></tr>
<tr>
<td>FACTOR
</td><td>DMS_FACTOR
</td><td>Output
</td><td>Address of the DMS_FACTOR structure  to contain  the  data of the retrieved record.<br />
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST(0) or FIND_NEXT(1)<br />
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_NO_DATA(0), DMS_ERROR(-1)
</p>
<a name="DMS_findVariate" id="DMS_findVariate"></a><h4> <span class="mw-headline">DMS_findVariate</span></h4>
<p>DMS_findVariate<b> </b>searches for variate with name matching <i>szName</i>.  If STUDYID is zero, the function looks for all variates having the matched name; otherwise, the function considers variates within the given study. If fopt is FIND_FIRST (0), the function stores the variate details of the first matched record.  If fopt is FIND_NEXT, details about the succeeding matched record is stored..
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_findVariate</b>(<i>szName, VARIATE, fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>szName
</td><td>Char*
</td><td>Input
</td><td>Address of NULL terminated string containing the string to be matched<br />
</td></tr>
<tr>
<td>VARIATE
</td><td>DMS_VARIATE
</td><td>Output
</td><td>Address of the DMS_VARIATE structure  to contain  the variate data of the retrieved record.<br />
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST(0) or FIND_NEXT(1)<br />
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_NO_DATA(0), DMS_ERROR(-1)
</p>
<a name="DMS_findLevelN" id="DMS_findLevelN"></a><h4> <span class="mw-headline">DMS_findLevelN</span></h4>
<p>DMS_findLevelN returns the LEVELNO of numeric value equal to LVALUE under the factor identified by LABELID.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_findLevelN</b>(<i>LevN</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>LevN
</td><td>DMS_LEVELN<br /><br />FACTORID<br />LABELID<br />LEVELNO<br />LEVEL_VALUE
</td><td>Output<br /><br />Output<br />Input<br />Output<br />Input
</td><td>Address of the DMS_LEVELN structure  to contain  the given factor identification number and the level value, and the retrieved LEVELNO.<br />
</td></tr>
</table>
<a name="DMS_findLevelC" id="DMS_findLevelC"></a><h4> <span class="mw-headline">DMS_findLevelC</span></h4>
<p>DMS_findLevelC returns the LEVELNO of character value equal to LVALUE under the factor identified by LABELID.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_findLevelC</b>(<i>LevC</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>LevC
</td><td>DMS_LEVELC<br /><br />LABELID<br />FACTORID<br />LEVELNO<br />LEVEL_VALUE
</td><td>Output<br /><br />Output<br />Input<br />Output<br />Input
</td><td>Address of the DMS_LEVELC structure  to contain  the given factor identification  and the character level value, and the retrieved LEVELNO .<br />
</td></tr>
</table>
<a name="DMS_findLabelC" id="DMS_findLabelC"></a><h4> <span class="mw-headline">DMS_findLabelC</span></h4>
<p><b>DMS_findLabelC </b>searches for character label value equal to LVALUE identified by LABELID, FACTORID and LEVELNO.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_findLabelC</b>(<i>LevC</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>LevC
</td><td>DMS_LEVELC<br /><br />FACTORID<br />LEVELNO<br />LEVEL_VALUE
</td><td>Output<br /><br />Input<br />Output<br />Input
</td><td>Address of the DMS_LEVELC structure to contain the given label, factor and level number identification and the character label value.<br />
</td></tr>
</table>
<a name="DMS_findLabelN" id="DMS_findLabelN"></a><h4> <span class="mw-headline">DMS_findLabelN</span></h4>
<p><b>DMS_findLabelN </b>searches for numeric label value equal to LVALUE identified by LABELID, FACTORID and LEVELNO.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_findLabelN</b>(<i>LevN</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>LevN
</td><td>DMS_LEVELN<br /><br />FACTORID<br />LABELID<br />LEVELNO<br />LEVEL_VALUE
</td><td>Output<br /><br />Input<br />Input<br />Output<br />Input
</td><td>Address of the DMS_LEVELN structure  to contain  the given factor identification number and the level value, and the retrieved LEVELNO.<br />
</td></tr>
</table>
<a name="DMS_findStOunit" id="DMS_findStOunit"></a><h4> <span class="mw-headline">DMS_findStOunit</span></h4>
<p><b>DMS_findStOunit </b>finds the observation unit that contains the global factors particularly the study factor. The input argument StuChar  should have the trait id of the Study factor and name of the study stored in CVALUE element.
</p><p>Syntax
</p><p>long <b>DMS_findStOunit</b>(<i>StuChar, fopt</i>)
</p><p>Arguments
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>StuChar
</td><td>DMS_CharVALUE<br /><br /><br />Ounitid<br />traitid<br />scaleid<br />tmethid<br />cvalue
</td><td>Output/ Input<br /><br />Output<br />Input<br /><br /><br />Input
</td><td>Address of the DMS_CharVALUE structure  to contain  the study trait id  and the study name, and the retrieved OUNITID .<br />
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST(0) or FIND_NEXT(1)<br />
</td></tr>
</table>
<a name="DMS_findStEffect" id="DMS_findStEffect"></a><h4> <span class="mw-headline">DMS_findStEffect</span></h4>
<p><b>DMS_findStEffect </b>finds the effect representation that is defined by the global factors particularly the study factor. The input argument StuChar  should have be the TRAITID of the Study factor and a particular study name stored in CVALUE.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>DMS_findStEffect</b>(<i> studyid, represno</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>Studyid
</td><td>Long
</td><td>Input
</td><td>The id of the given study.
</td></tr>
<tr>
<td>Represno
</td><td>Long*
</td><td>Output
</td><td>The number of the representation defined by the global factors.<br />
</td></tr>
</table>
<p><br />
</p>
<a name="DMS_GENERAL_QUERY_FUNCTIONS" id="DMS_GENERAL_QUERY_FUNCTIONS"></a><h3> <span class="mw-headline">DMS GENERAL QUERY FUNCTIONS</span></h3>
<a name="DMS_searchLevelN" id="DMS_searchLevelN"></a><h4> <span class="mw-headline">DMS_searchLevelN</span></h4>
<p>DMS_searchLevelN searches for the numeric level values of any factor belonging to a specific trait.   If  <i>scaleid</i> is non-zero,  the function will only extract level data expressed by the given scale.  If t<i>methid</i> is non-zero, then level data measured through the given method will be retrieved.  If <i>scaleid</i> and <i>tmethid</i> are both zero, all level values of the trait will be extracted.
</p><p>Syntax
</p><p>Long  <b>DMS_searchLevelN</b>( <i>traitid, scaleid, tmethid,  ounitid, flevelN, fopt</i>)
</p><p>Arguments
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>traitid
</td><td>Long
</td><td>Input
</td><td>The identification no. of the trait you want to get.
</td></tr>
<tr>
<td>scaleid
</td><td>Long
</td><td>Input
</td><td>The identification no. of the traits scale.
</td></tr>
<tr>
<td>tmethid
</td><td>Long
</td><td>Input
</td><td>The identification no. of the traits method.
</td></tr>
<tr>
<td>ounitid
</td><td>Long
</td><td>Output
</td><td>The observation unit having value for the specified trait.
</td></tr>
<tr>
<td>flevelN
</td><td>double
</td><td>Output
</td><td>The level  value of the trait of numeric type.
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<p><b>Returns</b>
</p><p>DMS_SUCCESS(1),   DMS_ERROR (-1),  DMS_NO_DATA (0)
</p>
<a name="DMS_searchDataN" id="DMS_searchDataN"></a><h4> <span class="mw-headline">DMS_searchDataN</span></h4>
<p><b>DMS_searchDataN </b>searches for all numeric values of any  variable belonging to a specified trait.  If  <i>scaleid</i> is non-zero, the function will extract data  expressed by the given scale.  If <i>tmethid </i>is non-zero, then data observed by the given method will be retrieved.  If <i>scaleid</i> and <i>tmethid </i>are both zero, all data values of the trait will be extracted.
</p><p>Syntax
</p><p>Long  <b>DMS_searchDataN</b>( <i>traitid, scaleid, tmethid,  ounitid, dvalueN, fopt</i>)
</p><p>Arguments
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>traitid
</td><td>Long
</td><td>Input
</td><td>The identification no. of the trait you want to get<br />.
</td></tr>
<tr>
<td>scaleid
</td><td>Long
</td><td>Input
</td><td>The identification no. of the traits scale.<br />
</td></tr>
<tr>
<td>tmethid
</td><td>Long
</td><td>Input
</td><td>The identification no. of the traits method<br />.
</td></tr>
<tr>
<td>Ountid
</td><td>Long
</td><td>Output
</td><td>The observation unit having value for the specified trait.<br />
</td></tr>
<tr>
<td>dvalueN
</td><td>Double
</td><td>Output
</td><td>The data  value of the trait of numeric type.<br />
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<p><b>Returns</b>
</p><p>DMS_SUCCESS(1),   DMS_ERROR (-1),  DMS_NO_DATA (0)
</p>
<a name="DMS_searchLevelC" id="DMS_searchLevelC"></a><h4> <span class="mw-headline">DMS_searchLevelC</span></h4>
<p><b>DMS_searchLevelC</b> searches for all character level values of any factor belonging to a specific trait.  If  <i>scaleid</i> is non-zero, the function will extract level data expressed by the given scale.  If <i>tmethid</i> is non-zero, then factor level applied  through the given method will be retrieved.   If <i>scaleid</i> and <i>tmethid</i> are both zero, all level values of the trait will be extracted.
</p><p>Syntax
</p><p>Long  <b>DMS_searchLevelC</b>(<i> traitid, scaleid, tmethid,  ounitid , flevelC, fopt</i>)
</p><p>Arguments
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>tratid
</td><td>Long
</td><td>Input
</td><td>The identification no. of the trait you want to get.<br />
</td></tr>
<tr>
<td>scaleid
</td><td>Long
</td><td>Input
</td><td>The identification no. of the traits scale.<br />
</td></tr>
<tr>
<td>tmethid
</td><td>Long
</td><td>Input
</td><td>The identification no. of the traits method.<br />
</td></tr>
<tr>
<td>Ounit
</td><td>Long
</td><td>Output
</td><td>The observation unit having value for the specified trait.
</td></tr>
<tr>
<td>flevelC
</td><td>Char[255]
</td><td>Output
</td><td>The level  value of the trait of character type.<br />
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<p><b>Returns</b>
</p><p>DMS_SUCCESS(1),   DMS_ERROR (-1),  DMS_NO_DATA (0)
</p>
<a name="DMS_searchDataC" id="DMS_searchDataC"></a><h4> <span class="mw-headline">DMS_searchDataC</span></h4>
<p><b>DMS_searchDataN </b>searches for all character values of any variable belonging to a specified trait.  If  <i>scaleid</i> is non-zero, then the function will only extract data expressed  by the given scale.  If <i>tmethid</i> is non-zero, then data values  which are observed  through the given method will be retrieved.   If <i>scaleid</i> and <i>tmethid</i> are both zero, all data values of the trait will be extracted.
</p><p>Syntax
</p><p>Long  <b>DMS_searchDataC</b>(<i>traitid, scaleid, tmethid,  ounitid,</i> <i>dvalueC, fopt</i>)
</p><p>Arguments
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>Traitid
</td><td>Long
</td><td>Input
</td><td>The identification no. of the trait you want to get.
</td></tr>
<tr>
<td>Scaleid
</td><td>Long
</td><td>Input
</td><td>The identification no. of the traits scale.
</td></tr>
<tr>
<td>Tmethid
</td><td>Long
</td><td>Input
</td><td>The identification no. of the traits method.
</td></tr>
<tr>
<td>Ounitid
</td><td>Long
</td><td>Output
</td><td>The observation unit having value for the specified trait.
</td></tr>
<tr>
<td>dvalueC
</td><td>Char[255]
</td><td>Output
</td><td>The data  value of the trait of character type.
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<p><b>Returns</b>
</p><p>DMS_SUCCESS(1),   DMS_ERROR (-1),  DMS_NO_DATA (0)
</p>
<a name="QUERY_THROUGH_OBSERVATION_UNIT" id="QUERY_THROUGH_OBSERVATION_UNIT"></a><h3> <span class="mw-headline">QUERY THROUGH OBSERVATION UNIT</span></h3>
<a name="DMS_defineOunitDN" id="DMS_defineOunitDN"></a><h4> <span class="mw-headline">DMS_defineOunitDN</span></h4>
<p>DMS_defineOunitDN retrieves the trait and the character data value describing a given observation unit.  The trait value is searched from the DATA_N table.  The function outputs the trait, the scale for expressing it, the method for measuring it and  its value.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_defineOunitDN</b>(<i>NumValue,fopt</i>)
</p><p>Arguments
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>NumValue
</td><td>DMS_NumVALUE<br /><br /><br />.ounitid<br /><br />.traitid<br />.scaleid<br />.tmethid<br />.nvalue<br />
</td><td>Input/<br />Output<br /><br />Input<br /><br />Output
</td><td><br /><br /><br />The observation unit being described.<br /><br />The numeric value of the factor level which is one of those that defines the observation unit, together with its traitid, scaleid,  and tmethid
</td></tr>
<tr>
<td>Fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_defineOunitDC" id="DMS_defineOunitDC"></a><h4> <span class="mw-headline">DMS_defineOunitDC</span></h4>
<p>DMS_defineOunitDN retrieves the trait and the character data value describing a given observation unit.  The trait value is searched from the DATA_C table.  The function outputs the trait, the scale for expressing it, the method for measuring it and its value.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_defineOunitDC</b>(<i>CharValue,fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>CharValue
</td><td>DMS_CharVALUE<br /><br /><br />.ounitid<br /><br />.traitid<br />.scaleid<br />.tmethid<br />.cvalue<br />
</td><td>Input/<br />Output<br /><br />Input<br /><br />Output
</td><td><br /><br /><br />The observation unit being described.<br /><br />The numeric value of the factor level which is one of those that defines the observation unit, together with its traitid, scaleid,  and tmethid
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_defineOunitLN" id="DMS_defineOunitLN"></a><h4> <span class="mw-headline">DMS_defineOunitLN</span></h4>
<p>DMS_defineOunitLN retrieves the trait and the numeric level value describing the specified observation unit. .  The function outputs the factor trait, the scale for expressing it, the method for measuring it and its value.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_defineOunitLN</b>(<i>NumValue,fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>NumValue
</td><td>DMS_NumVALUE<br /><br /><br />.ounitid<br /><br />.traitid<br />.scaleid<br />.tmethid<br />.nvalue<br />
</td><td>Input/<br />Output<br /><br />Input<br /><br />Output
</td><td><br /><br /><br />The observation unit being described.<br /><br />The numeric value of the factor level which is one of those that defines the observation unit, together with its traitid, scaleid,  and tmethid
</td></tr>
<tr>
<td>Fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_defineOunitLC" id="DMS_defineOunitLC"></a><h4> <span class="mw-headline">DMS_defineOunitLC</span></h4>
<p>DMS_defineOunitLC retrieves the trait and the character level value describing the given observation unit. .  The function outputs the factor trait, the scale for expressing it, the method for measuring it and its value.
</p><p><b>Syntax</b>
</p><p>Long <b>DMS_defineOunitLC</b>(<i>CharValue,fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>CharValue
</td><td>DMS_CharVALUE<br /><br /><br />.ounitid<br /><br />.traitid<br />.scaleid<br />.tmethid<br />.cvalue<br />
</td><td>Input/<br />Output<br /><br />Input<br /><br />Output
</td><td><br /><br /><br />The observation unit being described.<br /><br />The numeric value of the factor level which is one of those that defines the observation unit, together with its traitid, scaleid,  and tmethid
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_extractOunitDN" id="DMS_extractOunitDN"></a><h4> <span class="mw-headline">DMS_extractOunitDN</span></h4>
<p>DMS_extractOunitDN extracts the observation unit from a given <i>studyid</i> having trait value associated to the specified <i>dblValue. </i>The trait value can be equal, greater than, less than, greater than or equal or less than or equal to the <i>dblValue</i> depending on the specified <i>operator</i>. The trait is represented by the traitid, expressed by <i>scaleid</i> and measured by <i>tmethid</i>. The trait value is searched from the DATA_N table. The function returns DMS_ERROR  if no observation unit found.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_extractOunitDN</b> (<i>studyid,dblValue,NumValue,operator,fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>studyid
</td><td>Long
</td><td>Input
</td><td>&nbsp;
</td></tr>
<tr>
<td>dblValue
</td><td>Double
</td><td>Input
</td><td>The value to compare.
</td></tr>
<tr>
<td>NumValue
</td><td>DMS_NumVALUE<br /><br />.ounitid<br /><br />.traitid<br /><br />.scaleid<br /><br /><br />.tmethid<br /><br /><br />.nvalue
</td><td>Input/<br />Output<br />Output<br /><br />Input<br /><br />Input<br /><br /><br />Input<br /><br /><br />Output
</td><td>The identification no. of the trait you want to get.<br /><br />The observation unit where the trait is observed.<br /><br />The identification no. of the trait.<br /><br />The identification no. of the scale used in expressing the trait.<br /><br />The identification no. of the method used in measuring the trait.<br /><br />The retrieved numeric data value.
</td></tr>
<tr>
<td>operator
</td><td>Long
</td><td>Input
</td><td>Can be any of the following: DMS_EQ(0),DMS_GT(1),DMS_LT(2),<br />DMS_GTE(3),DMS_LTE(4)
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA (0)
</p>
<a name="DMS_extractOunitDC" id="DMS_extractOunitDC"></a><h4> <span class="mw-headline">DMS_extractOunitDC</span></h4>
<p>DMS_extractOunitDC extracts the observation unit from a given <i>studyid </i>having trait value equal to the specified <i>cvalue. </i>The trait is represented by the <i>traitid</i>, expressed by <i>scaleid</i> and measured by <i>tmethid</i>. The trait value is searched from the DATA_C table..  The function returns DMS_ERROR  if no observation unit found.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_extractOunitDC</b> <i>(studyid,szValue,CharValue,fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>CharValue
</td><td>DMS_CharVALUE<br /><br /><br />.ounitid<br /><br /><br />.traitid<br /><br />.scaleid<br /><br /><br />.tmethid<br /><br /><br />.cvalue
</td><td>Input/<br />Output<br /><br />Output<br /><br /><br />Input<br /><br />Input<br /><br /><br />Input<br /><br /><br />Input
</td><td>The identification no. of the trait you want to get.<br /><br />The observation unit where the trait is observed.<br /><br />The identification no. of the trait.<br /><br />The identification no. of the scale used in expressing the trait.<br /><br />The identification no. of the method used in measuring the trait.<br /><br />The character data value to be compared.
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA (0)
</p>
<a name="DMS_extractOunitLN" id="DMS_extractOunitLN"></a><h4> <span class="mw-headline">DMS_extractOunitLN</span></h4>
<p>DMS_extractOunitLN extracts the observation unit from a given <i>studyid</i> having trait value associated to the specified <i>dblValue. </i>The trait value can be equal, greater than, less than, greater than and equal or less than and equal to the <i>dblValue</i> depending on the specified <i>operator</i>. The trait is represented by the <i>traitid</i>, expressed by <i>scaleid</i> and measured by <i>tmethid</i>. The trait value is searched from the LEVEL_N table...  The function returns DMS_ERROR  if no observation unit found.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_extractOunitLN</b>(<i>studyid,dblValue,NumValue,operator,fopt</i>)
</p><p>Arguments
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>studyid
</td><td>Long
</td><td>Input
</td><td>&nbsp;
</td></tr>
<tr>
<td>dblValue
</td><td>Double
</td><td>Input
</td><td>The value to compare.
</td></tr>
<tr>
<td>NumValue
</td><td>DMS_NumVALUE<br /><br /><br />.ounitid<br /><br /><br />.traitid<br /><br />.scaleid<br /><br /><br />.tmethid<br /><br /><br />.nvalue
</td><td>Input/<br />Output<br /><br />Output<br /><br /><br />Input<br /><br />Input<br /><br /><br />Input<br /><br /><br />Output
</td><td>The identification no. of the trait you want to get.<br /><br />The observation unit where the trait is observed.<br /><br />The identification no. of the trait.<br /><br />The identification no. of the scale used in expressing the trait.<br /><br />The identification no. of the method used in measuring the trait.<br /><br />The numeric data value to be compared.
</td></tr>
<tr>
<td>operator
</td><td>Long
</td><td>Input
</td><td>Can be any of the following: DMS_EQ(0),DMS_GT(1),DMS_LT(2),<br />DMS_GTE(3),DMS_LTE(4)
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA (0)
</p>
<a name="DMS_extractOunitLC" id="DMS_extractOunitLC"></a><h4> <span class="mw-headline">DMS_extractOunitLC</span></h4>
<p>DMS_extractOunitLC extracts the observation unit from a given <i>studyid </i>having trait value equal to the specified <i>szValue. </i>The trait is represented by the <i>traitid</i>, expressed by <i>scaleid</i> and measured by <i>tmethid</i>. The trait value is searched from the LEVEL_C table..  The function returns DMS_ERROR  if no observation unit found.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_extractOunitLC</b> <i>(studyid,cvalue,CharValue,fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>CharValue
</td><td>DMS_CharVALUE<br /><br /><br />.ounitid<br /><br /><br />.traitid<br /><br />.scaleid<br /><br /><br />.tmethid<br /><br /><br />.cvalue
</td><td>Input/<br />Output<br /><br />Output<br /><br /><br />Input<br /><br />Input<br /><br /><br />Input<br /><br /><br />Input
</td><td>The identification no. of the trait you want to get.<br /><br />The observation unit where the trait is observed.<br /><br />The identification no. of the trait.<br /><br />The identification no. of the scale used in expressing the trait.<br /><br />The identification no. of the method used in measuring the trait.<br /><br />The character data value to be compared.
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA (0)
</p>
<a name="DMS_describeOunit" id="DMS_describeOunit"></a><h4> <span class="mw-headline">DMS_describeOunit</span></h4>
<p>DMS_describeOunit returns an array of factor ids and level numbers that defines a specific observation unit.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_describeOunit </b>(<i>ounitid, arrLev, nArr, fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>ounitid
</td><td>Long
</td><td>Input
</td><td>The number of the observation unit.
</td></tr>
<tr>
<td>arrLev
</td><td>*source
</td><td>Output
</td><td>The address of the first element of the array that will contain the factor ids and level numbers
</td></tr>
<tr>
<td>nArr
</td><td>Long
</td><td>Input/<br />Output
</td><td>As input, the maximum allowable number of element of the array  and as output the number of retrieved factors.
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA (0)
</p>
<a name="DMS_describeEffectOunit" id="DMS_describeEffectOunit"></a><h4> <span class="mw-headline"> DMS_describeEffectOunit</span></h4>
<p>DMS_describeEffectOunit returns an array of factor ids and level numbers that defines a specific observation unit of a given representation.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_describeEffectOunit </b>(<i>ounitid,represno,  arrLev, nArr, fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>ounitid
</td><td>Long
</td><td>Input
</td><td>The number of the observation unit.
</td></tr>
<tr>
<td>represno
</td><td>Long
</td><td>Input
</td><td>The number of the effect representation.
</td></tr>
<tr>
<td>arrLev
</td><td>*source
</td><td>Output
</td><td>The address of the first element of the array that will contain the factor ids and level numbers.
</td></tr>
<tr>
<td>nArr
</td><td>Long
</td><td>Input/<br />Output
</td><td>As input, the maximum allowable number of element of the array  and as output the number of retrieved factors.
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA (0)
</p>
<a name="DMS_ACCESS_FUNCTIONS" id="DMS_ACCESS_FUNCTIONS"></a><h3> <span class="mw-headline">DMS ACCESS FUNCTIONS</span></h3>
<p>These functions searches the DMS based on the key ids of the DMS tables.
</p>
<a name="DMS_getStudy" id="DMS_getStudy"></a><h4> <span class="mw-headline">DMS_getStudy</span></h4>
<p>DMS_getStudy retrieves details of a Study.   The first argument of the function is a pointer to DMS_STUDY structure.  If the STUDYID element is not zero then the details for the corresponding study is retrieved.  If it is zero, the function returns the details for the first study if fOpt = FIND_FIRST (0)  or for the next available study if fOpt = FIND_NEXT(1).  The objective of the study is placed in a separate argument <i>szObj</i>.  Any call which fails to find a study returns DMS_NO_DATA.
</p><p><b> Syntax</b>
</p><p>Long <b>DMS_getStudy</b>(<i>STUDY, szSObj, cSObj, fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>STUDY
</td><td>DMS_STUDY
</td><td>Input/Output
</td><td>Address of a DMS_STUDY structure.
</td></tr>
<tr>
<td>szSObj
</td><td>Char *
</td><td>Output
</td><td>Address of a NULL terminated string to place the trait description.
</td></tr>
<tr>
<td>cSObj
</td><td>Long
</td><td>Input
</td><td>Maximum size of szTDesc.
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getObsunit" id="DMS_getObsunit"></a><h4> <span class="mw-headline">DMS_getObsunit</span></h4>
<p>DMS_getObsunit retrieves the observation unit of a study.  The first argument of the fucntion is the study id and the next argument is a pointer to DMS_OBSUNIT structure. The functions gets the first found observation unit if fOpt = FIND_FIRST (0)  or for the next available observation unit  if fOpt = FIND_NEXT(1). Any call which fails to find an observation unit returns DMS_NO_DATA.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getObsunit</b>(<i>studyid,Obs, fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>studyid
</td><td>Long
</td><td>Input
</td><td>The study where to retrieve the observation unit.
</td></tr>
<tr>
<td>Obs
</td><td>DMS_OBS
</td><td>Output
</td><td>Address of a DMS_OBSUNIT structure.
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getLevelC" id="DMS_getLevelC"></a><h4> <span class="mw-headline">DMS_getLevelC</span></h4>
<p>DMS_getLevelC retrieves the value of a specific level of a character factor.  The argument of the function is a pointer to DMS_LEVELC structure which contains the label id, factor id and the level no that identify the factor value. If the function fails to find a character factor value, it returns DMS_NO_DATA.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getLevelC</b>(<i>LevC</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>LevC
</td><td>DMS_LEVELC
</td><td>Input/Output
</td><td>The address of the DMS_LEVELC structure.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getLabelC" id="DMS_getLabelC"></a><h4> <span class="mw-headline">DMS_getLabelC</span></h4>
<p>DMS_getLabelC retrieves the label ids and its associated values for a given level of a factor. The parameters passed to the function are the factor id and level number stored in the DMS_LEVELC structure, which will also contain the returned label id and value.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getLabelC</b>(<i>LevC, fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>LevC
</td><td>DMS_LEVELC
</td><td>Input/Output
</td><td>The address of the DMS_LEVELC structure.
</td></tr>
<tr>
<td>Fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getAllLevelC" id="DMS_getAllLevelC"></a><h4> <span class="mw-headline">DMS_getAllLevelC</span></h4>
<p>DMS_getAllLevelC retrieves the levels and values of a given character label or factor.  The argument of the function is a pointer to DMS_LEVELC structure, which contains the label id.  The level number and the character value of the label are returned to the LEVELNO and LEVEL_VALUE elements of the data structure.  If the function does not find any character factor value, it returns DMS_NO_DATA.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getAllLevelC</b>(<i>LevC, fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>LevC
</td><td>DMS_LEVELC
</td><td>Input/Output
</td><td>The address of the DMS_LEVELC structure.
</td></tr>
<tr>
<td>Fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getAllLabelC" id="DMS_getAllLabelC"></a><h4> <span class="mw-headline">DMS_getAllLabelC</span></h4>
<p>DMS_getAllLabelC retrieves the labels and factor values of a given factorid from the LEVEL_C table. The argument of the function is a pointer to DMS_LEVELC structure, which contains the factorid.  The value, level no and labeid are returned to the LEVEL_VALUE, LEVELNO and LABELID elements of the data strcuture.  The function returns DMS_NO_DATA if no record is found.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getAllLabelC</b>(<i>LevC, fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>LevC
</td><td>DMS_LEVELC
</td><td>Input/Output
</td><td>The address of the DMS_LEVELC structure.
</td></tr>
<tr>
<td>Fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getLevelN" id="DMS_getLevelN"></a><h4> <span class="mw-headline">DMS_getLevelN</span></h4>
<p>DMS_getLevelC retrieves the value of a numeric factor.  The argument of the function is a pointer to DMS_LEVELN structure which contains the label id, factor id and the level no that identify the factor value. If the function fails to find a numeric factor value, it returns DMS_NO_DATA.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getLevelN</b>(<i>LevN</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>LevN
</td><td>DMS_LEVELN
</td><td>Input/Output
</td><td>The address of the DMS_LEVELN structure.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getLabelN" id="DMS_getLabelN"></a><h4> <span class="mw-headline">DMS_getLabelN</span></h4>
<p>DMS_getLabelN retrieves the label ids and its associated values for a given level of a factor. The parameters passed to the function are the factor id and level number stored in the DMS_LEVELN structure, which will also contain the returned label id and value.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getLabelN</b>(<i>LevN, fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>LevN
</td><td>DMS_LEVELN
</td><td>Input/Output
</td><td>The address of the DMS_LEVELC structure.
</td></tr>
<tr>
<td>Fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getAllLevelN" id="DMS_getAllLevelN"></a><h4> <span class="mw-headline">DMS_getAllLevelN</span></h4>
<p>DMS_getAllLevelN retrieves the levels and values of a given numeric label or factor.  The argument of the function is a pointer to DMS_LEVELN structure, which contains the label id.  The level number and the numeric value of the label are returned to the LEVELNO and LEVEL_VALUE elements of the data structure.  If the function fails to find a numeric factor value, it returns DMS_NO_DATA.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getAllLevelN</b>(<i>LevN, fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>LevN
</td><td>DMS_LEVELN
</td><td>Input/Output
</td><td>The address of the DMS_LEVELN structure.
</td></tr>
<tr>
<td>Fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="0DMS_getAllLabelN" id="0DMS_getAllLabelN"></a><h4> <span class="mw-headline">0DMS_getAllLabelN</span></h4>
<p>DMS_getAllLabelN retrieves the labels and factor values of a given factorid from the LEVEL_N table. The argument of the function is a pointer to DMS_LEVELN structure, which contains the factorid.  The value, level no and labeid are returned to the LEVEL_VALUE, LEVELNO and LABELID elements of the data strcuture.  The function returns DMS_NO_DATA if no record is found.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getAllLabelN</b>(<i>LevN, fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>LevN
</td><td>DMS_LEVELN
</td><td>Input/Output
</td><td>The address of the DMS_LEVELN structure.
</td></tr>
<tr>
<td>Fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getDataC" id="DMS_getDataC"></a><h4> <span class="mw-headline">DMS_getDataC</span></h4>
<p>DMS_getDataC retrieves the value of a character data.  The argument of the function is a pointer to DMS_DATAC structure which contains the observation unit id and the variate id that identify the data value. If the function fails to find a character data value, it returns DMS_NO_DATA.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getDataC</b>(<i>DatC)</i>
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>DatC
</td><td>DMS_DATAC
</td><td>Input/Output
</td><td>The address of the DMS_DATAC structure.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getDataN" id="DMS_getDataN"></a><h4> <span class="mw-headline">DMS_getDataN</span></h4>
<p>DMS_getDataN retrieves the value of a numeric data.  The argument of the function is a pointer to DMS_DATAN structure which contains the observation unit id and the variate id that identify the data value. If the function fails to find a numeric data value, it returns DMS_NO_DATA.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getDataN</b>(<i>DatN)</i>
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>DatN
</td><td>DMS_DATAN
</td><td>Input/Output
</td><td>The address of the DMS_DATAN structure.
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getTrait" id="DMS_getTrait"></a><h4> <span class="mw-headline">DMS_getTrait</span></h4>
<p>DMS_getTrait retrieves details of a trait.   The first argument of the function is a pointer to DMS_TRAIT structure.  If the TRAITID element is not zero then the details for the corresponding trait is retrieved.  If it is zero, the function returns the details for the first trait if fOpt = FIND_FIRST (0)  or for the next available trait if fOpt = FIND_NEXT(1).  The description of the trait is placed in a separate argument <i>szTDesc</i>.  Any call which fails to find a trait returns DMS_NO_DATA.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getTrait</b>(<i>TRAIT, szTDesc, cTDesc, fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>TRAIT
</td><td>DMS_TRAIT
</td><td>Input/Output
</td><td>Address of a DMS_TRAIT structure.
</td></tr>
<tr>
<td>szTDesc
</td><td>Char *
</td><td>Output
</td><td>Address of a NULL terminated string to place the trait description.
</td></tr>
<tr>
<td>cTDesc
</td><td>Long
</td><td>Input
</td><td>Maximum size of szTDesc.
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getScale" id="DMS_getScale"></a><h4> <span class="mw-headline">DMS_getScale</span></h4>
<p>DMS_getScale retrieves details of a scale.   The first argument of the function is a pointer to DMS_SCALE structure.  If the SCALEID element is not zero then the details for the corresponding scale is retrieved.  If it is zero, the function returns the details for the first scale if fOpt = FIND_FIRST (0)  or for the next available scale if fOpt=FIND_NEXT(1).
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getScale</b>(<i>SCALE, fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>SCALE
</td><td>DMS_SCALE
</td><td>Input/Output
</td><td>Address of a DMS_SCALE structure<br />.
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getScaleCon" id="DMS_getScaleCon"></a><h4> <span class="mw-headline">DMS_getScaleCon</span></h4>
<p>DMS_getScaleCon retrieves the start value and end value of continuous numeric scale.   The first argument of the function is a pointer to DMS_SCALECON structure.  If the SCALEID element is not zero then the range for the corresponding scale is retrieved.  If it is zero, the function returns all the ranges of the continuous scales.  If fOpt = FIND_FIRST (0), then first record is retrieved.  if fOpt=FIND_NEXT(1), then the succedding record is retrieved.  If no record is found, DMS_NO_DATA is return value of the function.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long  <b>DMS_getScaleCon</b><i>(ScaleCon; fopt)</i>
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>ScaleCon
</td><td>DMS_SCALECON
</td><td>Input/Output
</td><td>Address of a DMS_SCALECON structure<br />.
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<p><br />
</p>
<table border="0" cellspacing="2" width="100%">
<tr>
<td><b>5.6.16</b>
</td><td>DMS_getScaleDis
</td></tr>
</table>
<p>DMS_getScaleDis retrieves the allowed value of a discreet scale and its description.   The first argument of the function is a pointer to DMS_SCALEDIS structure.  If the SCALEID element is not zero then the allowed values for the given scale are retrieved.  If it is zero, the function returns all the values of the discreets scales.  If fOpt = FIND_FIRST (0), then first record is retrieved.  if fOpt=FIND_NEXT(1), then the succeeding record is retrieved.  If no record is found, DMS_NO_DATA is return value of the function.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long  <b>DMS_getScaleDis</b><i>(ScaleDis; fopt)</i>
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>ScaleDis
</td><td>DMS_SCALEDIS
</td><td>Input/Output
</td><td>Address of a DMS_SCALEDIS structure<br />.
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<a name="DMS_getScaleDis2" id="DMS_getScaleDis2"></a><h4> <span class="mw-headline">DMS_getScaleDis2</span></h4>
<p>DMS_getScaleDis2 retrieves the description of the value of a given scaleid.   If no record is found, DMS_NO_DATA is return value of the function.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long  <b>DMS_getScaleDis2</b><i>(ScaleDis; fopt)</i>
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>ScaleDis
</td><td>DMS_SCALEDIS
</td><td>Input/Output
</td><td>Address of a DMS_SCALEDIS structure.  The value and scalied are provided as inputs and the description is returned by the function
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<a name="DMS_getScaleTab" id="DMS_getScaleTab"></a><h4> <span class="mw-headline">DMS_getScaleTab</span></h4>
<p>DMS_getScaleTab executes the SQL statement stored in the ScaleTab table for the specified scaleid.   The result of the query is stored in the given file name and the number of resulted columns is returned by the function.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long  <b>DMS_getScaleTab</b><i>(scaleid,fileName,noCol)</i>
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>scaleid
</td><td>long
</td><td>Input
</td><td>The identification of the scale whose values are stored in the ICIS tables.<br />.
</td></tr>
<tr>
<td>fileName
</td><td>Char *
</td><td>Input
</td><td>Address of a NULL terminated string that contains the file name where the result of the SQL statement is stored.
</td></tr>
<tr>
<td>noCol
</td><td>Long
</td><td>Output
</td><td>The number of columns returned by the SQL statement.
</td></tr>
</table>
<p><br />
</p>
<a name="DMS_getTmethod" id="DMS_getTmethod"></a><h4> <span class="mw-headline">DMS_getTmethod</span></h4>
<p>DMS_getTmethod retrieves details of a method.   The first argument of the function is a pointer to DMS_TMETHOD structure.  If the TMETHID element is not zero then the details for the corresponding method is retrieved.  If it is zero, the function returns the details for the first method if fOpt = FIND_FIRST (0)  or for the next available method if fOpt = FIND_NEXT(1).
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getTmethod</b>(<i>TMETHOD,</i> szTmethDesc,cTmethDescn,<i>fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>TMETHOD
</td><td>DMS_TMETHOD
</td><td>Input/Output
</td><td>Address of a DMS_TMETHOD structure.
</td></tr>
<tr>
<td>szTmethDesc
</td><td>Char *
</td><td>Output
</td><td>Address of a NULL terminated string to place the method description.
</td></tr>
<tr>
<td>cTmethDesc
</td><td>Long
</td><td>Input
</td><td>Maximum size of szTmethDesc.
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getOunitLevelN" id="DMS_getOunitLevelN"></a><h4> <span class="mw-headline">DMS_getOunitLevelN</span></h4>
<p>DMS_getOunitLevelN retrieves an observation unit of a numeric factor level.  The first argument of the function is a pointer to LEVELN structure.  Values for the LABELID and FACTORID elements must be provided.  The corresponding observation unit for the LABELID and FACTORID is retrieved, along with the LEVELNO and LVALUE values.  If fOpt = FIND_FIRST (0), details of the first level value is retrieved, or the next available level value, of fOpt = FIND_NEXT(1).
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getOunitLevelN</b>(<i>LEVELN,ouid,fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>LEVELN
</td><td>DMS_LEVELN
</td><td>Input/Output
</td><td>Address of a DMS_LEVELN structure.
</td></tr>
<tr>
<td>ounitid
</td><td>Long
</td><td>Output
</td><td>The observation unit number being defined by the combination of factors and levels.
</td></tr>
<tr>
<td>Fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getOunitLevelC" id="DMS_getOunitLevelC"></a><h4> <span class="mw-headline">DMS_getOunitLevelC</span></h4>
<p>DMS_getOunitLevelC retrieves an observation unit of a character factor level.  The first argument of the function is a pointer to LEVELC structure.  Values for the LABELID and FACTORID elements must be provided.  The corresponding observation unit for the LABELID and FACTORID is retrieved, along with the LEVELNO and LVALUE values.  If fOpt = FIND_FIRST (0), details of the first level value is retrieved, or the next available level value, of fOpt = FIND_NEXT(1).
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getOunitLevelC</b>(<i>LEVELC,ouid,fopt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>LEVELC
</td><td>DMS_LEVELC
</td><td>Input/Output
</td><td>Address of a DMS_LEVELC structure.
</td></tr>
<tr>
<td>ounitid
</td><td>Long
</td><td>Output
</td><td>The observation unit number being defined by the combination of factors and levels.
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getEffectOunit" id="DMS_getEffectOunit"></a><h4> <span class="mw-headline">DMS_getEffectOunit</span></h4>
<p>DMS_getEffectOunit extracts the observation units included in an effect representation.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getEffectOunit</b>( <i>represno, ounitid, fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>represno
</td><td>Long
</td><td>Input
</td><td>The number of an effect representation.
</td></tr>
<tr>
<td>ounitid
</td><td>Long *
</td><td>Output
</td><td>The observation unit number included in an effect representation.
</td></tr>
<tr>
<td>fopt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getEffectRecord" id="DMS_getEffectRecord"></a><h4> <span class="mw-headline">DMS_getEffectRecord</span></h4>
<p>DMS_getEffectRecord retrieves records of representation number, factor id and effect number of a study from the EFFECT table.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getEffectRecord</b>(<i>studyid, effect, fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>studyid
</td><td>Long
</td><td>Input
</td><td>The identification number of a study.
</td></tr>
<tr>
<td>effect
</td><td>DMS_EFFECT
</td><td>Output
</td><td>The address to the DMS_EFFECT table.
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getEffectRecordV" id="DMS_getEffectRecordV"></a><h4> <span class="mw-headline">DMS_getEffectRecordV</span></h4>
<p>DMS_getEffectRecordV extracts the representation number, variate id and effect number of a study.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getEffectRecord</b>(<i>studyid, effect, fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>studyid
</td><td>Long
</td><td>Input
</td><td>The identification number of a study.
</td></tr>
<tr>
<td>Effect
</td><td>DMS_EFFECT
</td><td>Output
</td><td>The address to the DMS_EFFECT table to contain the representation number, the variate id and effect number.
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getEffect" id="DMS_getEffect"></a><h4> <span class="mw-headline">DMS_getEffect</span></h4>
<p>DMS_getEffect retrieves the effect representations of a study.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getEffect</b>(<i>studyid, effectid,  repres,, fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>studyid
</td><td>Long
</td><td>Input
</td><td>The identification number of a study.
</td></tr>
<tr>
<td>effectid
</td><td>Long *
</td><td>Output
</td><td>The identification number of an effect.
</td></tr>
<tr>
<td>repres
</td><td>Long *
</td><td>Output
</td><td>The identification number of  an effect representation.
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getFactorEffect" id="DMS_getFactorEffect"></a><h4> <span class="mw-headline">DMS_getFactorEffect</span></h4>
<p>DMS_getFactorEffect retrieves the factors of an effect representation.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getFactorEffect</b>(<i> effect, fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>Effect
</td><td>DMS_EFFECT
</td><td>Input/Output
</td><td>The address to the DMS_EFFECT structure.  The representation number and effect id are passed to the function while the factor id is returned by the function.
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getFactor" id="DMS_getFactor"></a><h4> <span class="mw-headline">DMS_getFactor</span></h4>
<p>DMS_getFactor retrieves the factors of a given study.  If the id of the factor label is specified, the function retrieves its record.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<a name="Long_DMS_getFactor.28_factor.2C_fOpt.29" id="Long_DMS_getFactor.28_factor.2C_fOpt.29"></a><h4> <span class="mw-headline">Long DMS_getFactor( factor, fOpt)</span></h4>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>Factor
</td><td>DMS_FACTOR
</td><td>Input/Output
</td><td>The address to the DMS_FACTOR structure to contain the record of a factor label.  The study id or the label id is a parameter passed to the function.
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getFactorLabel" id="DMS_getFactorLabel"></a><h4> <span class="mw-headline">DMS_getFactorLabel</span></h4>
<p>DMS_getFactorLabel retrieves the labels of a given factor id.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getFactor</b>(<i> factor, fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>Factor
</td><td>DMS_FACTOR
</td><td>Input/Output
</td><td>The address to the DMS_FACTOR structure to contain the record of a factor label.  The factor id  is a parameter passed to the function.
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getVariate" id="DMS_getVariate"></a><h4> <span class="mw-headline">DMS_getVariate</span></h4>
<p>DMS_getVariate retrieves the variates a given study. If the id of the variate is specified, the function gets its record.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getVariate</b>(<i> variate, fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>variate
</td><td>DMS_VARIATE
</td><td>Input/Output
</td><td>The address to the DMS_VARIATE structure to contain the record of a variate.  The id of the study or variate is a parameter passed to the function.
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_getDMSAttr" id="DMS_getDMSAttr"></a><h4> <span class="mw-headline">DMS_getDMSAttr</span></h4>
<p>DMS_getDMSAttr retrieves additional attributes of a given DMS entity. The type of entity or table name (e.g. STUDY, FACTOR,VARIATE)  is provided in the TABLE_NAME element of the DMS_DMSATTR structure. The ATTRIBUTE_TYPE element contains the id of the attribute type (e.g. Description), which is defined in the UDFLDS table.  The record id of the entity in a DMS table (e.g. LABELID, VARIATID) is stored in the RECORDID_IN_TABLE element.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>Long <b>DMS_getDMSAttr</b>(<i> attr, fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>attr
</td><td>DMS_DMSATTR
</td><td>Input/Output
</td><td>The address to the DMS_DMSATTR structure to contain the attribute of DMS entity.  The type of entity, type of attribute and the specific id of the entity are parameters passed to the function.
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST (0) or FIND_NEXT (1)
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_UPDATE_FUNCTIONS" id="DMS_UPDATE_FUNCTIONS"></a><h3> <span class="mw-headline">DMS UPDATE FUNCTIONS</span></h3>
<a name="DMS_updateDataC" id="DMS_updateDataC"></a><h4> <span class="mw-headline">DMS_updateDataC</span></h4>
<p>DMS_updateDataC changes the character data value associated to the given ounitid and variatid.
</p><p><b>Syntax</b>
</p><p>Long <b>DMS_updateDataC</b>(<i> DataC</i>)
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>DataC
</td><td>DMS_DATAC
</td><td>Input/Output
</td><td>The address to the DMS_DATAC structure that contains the new data value and the variatid and ounitid
</td></tr>
</table>
<p><b>Returns</b>
</p><p>DMS_SUCCESS(1), DMS_ERROR(-1)
</p>
<a name="DMS_updateDataN" id="DMS_updateDataN"></a><h4> <span class="mw-headline">DMS_updateDataN</span></h4>
<p>DMS_updateDataN changes the numeric data value associated to the given ounitid and variatid.
</p><p><b>Syntax</b>
</p><p>Long <b>DMS_updateDataN</b>(<i> DataN</i>)
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>DataN
</td><td>DMS_DATAN
</td><td>Input/Output
</td><td>The address to the DMS_DATAN structure that contains the new data value and the variatid and ounitid
</td></tr>
</table>
<p><b>Returns</b>
</p><p>DMS_SUCCESS(1), DMS_ERROR(-1)
</p><p><br />
</p>
<a name="DMS_DELETE_FUNCTION" id="DMS_DELETE_FUNCTION"></a><h3> <span class="mw-headline">DMS DELETE FUNCTION</span></h3>
<a name="DMS_deleteStudy" id="DMS_deleteStudy"></a><h4> <span class="mw-headline">DMS_deleteStudy</span></h4>
<p>DMS_deleteStudy deletes all information about a study stored in the local DMS database. 
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_deleteStudy</b>(<i>studyid</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td><i>studyid</i>
</td><td>Long
</td><td>input
</td><td align="justify"> the ID of the study to be deleted
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR
</p>
<a name="MISCELLANEOUS_FUNCTIONS" id="MISCELLANEOUS_FUNCTIONS"></a><h3> <span class="mw-headline">MISCELLANEOUS FUNCTIONS</span></h3>
<a name="DMS_existCombination" id="DMS_existCombination"></a><h4> <span class="mw-headline"> DMS_existCombination</span></h4>
<p>DMS_existCombination determines if a combination of factor levels exists or not in a study.  It retrieves the observation unit which is defined by the array of factor ids and level numbers.  It returns DMS_SUCCESS if the combination exists.
</p><p><b>Syntax</b>
</p><p>Long <b>DMS_existCombination</b> (<i>studyid, arrLev, ounitid,  nArr</i>)
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>Studyid
</td><td>Long
</td><td>Input
</td><td>The specific study where to search.
</td></tr>
<tr>
<td>ArrLev
</td><td>*source
</td><td>Input
</td><td>The address of the first element of the array of factor ids and level numbers
</td></tr>
<tr>
<td>Ounitid
</td><td>Long
</td><td>Output
</td><td>The observation unit number being defined by the combination of factors and levels.
</td></tr>
<tr>
<td>NArr
</td><td>Long
</td><td>Input/<br />Output
</td><td>The number of factors in the array.
</td></tr>
</table>
<p><b>Returns</b>
</p><p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA (0)
</p>
<a name="DMS_existEffect" id="DMS_existEffect"></a><h4> <span class="mw-headline">DMS_existEffect</span></h4>
<p>DMS_existEffect determines if there is an effect representation defined by the given list of factors.  It retrieves the representation number and effect number if it exists and returns DMS_SUCCESS.
</p><p><b>Syntax</b>
</p><p>Long <b>DMS_existEffect</b> (<i>lstfactor,  nfactor, represno, effectid</i>)
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>lstfactor
</td><td>Long*
</td><td>Input
</td><td>The address to the array of factors.
</td></tr>
<tr>
<td>nfactor
</td><td>Long
</td><td>Input
</td><td>The number of  factors.
</td></tr>
<tr>
<td>represno
</td><td>Long*
</td><td>Output
</td><td>The  number of the representation defined by the given list of factors.
</td></tr>
<tr>
<td>effectid
</td><td>Long*
</td><td>Output
</td><td>The  number of the effect.
</td></tr>
</table>
<p><b>Returns</b>
</p><p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA (0)
</p>
<a name="DMS_minOunitid" id="DMS_minOunitid"></a><h4> <span class="mw-headline">DMS_minOunitid</span></h4>
<p>DMS_minOunitid gets the minimum number of  observation unit existing in the database.   This function is primarily used in loading data to DMS.
</p><p><b>Syntax</b>
</p><p>Long <b>DMS_minOunitid</b>(<i>ounitid</i>)
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>ounitid
</td><td>long
</td><td>Output
</td><td>The minimum number of observation  unit existing in the database.
</td></tr>
</table>
<p><b>Returns</b>
</p><p>DMS_SUCCESS(1), DMS_ERROR(-1), DMS_NO_DATA(0)
</p>
<a name="DMS_deleteStudy_2" id="DMS_deleteStudy_2"></a><h4> <span class="mw-headline">DMS_deleteStudy </span></h4>
<p>DMS_deleteStudy deletes all records associated to the specified studyid.
</p><p><b>Syntax</b>
</p><p>Long <b>DMS_deleteStudy</b>(<i>studyid</i>)
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>studyid
</td><td>long
</td><td>Output
</td><td>The identification number of the study to be deleted.
</td></tr>
</table>
<p><b>Returns</b>
</p><p>DMS_SUCCESS(1), DMS_ERROR(-1)
</p>
<a name="DMS_deleteDataC" id="DMS_deleteDataC"></a><h4> <span class="mw-headline">DMS_deleteDataC</span></h4>
<p>DMS_deleteDataC deletes a record from the DATA_C table based on the specified ounitid and variateid.
</p><p><b>Syntax</b>
</p><p>Long <b>DMS_deleteDataC</b>(<i>ounitid, variateid</i>)
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>ounitid
</td><td>long
</td><td>Input
</td><td>The observation unit of the record to be deleted.
</td></tr>
<tr>
<td>variateid
</td><td>long
</td><td>Input
</td><td>The variateid of the record to be deleted
</td></tr>
</table>
<p><b>Returns</b>
</p><p>DMS_SUCCESS(1), DMS_ERROR(-1)
</p>
<a name="DMS_deleteDataN" id="DMS_deleteDataN"></a><h4> <span class="mw-headline">DMS_deleteDataN</span></h4>
<p>DMS_deleteDataN deletes a record from the DATA_N table based on the specified ounitid and variateid.
</p><p><b>Syntax</b>
</p><p>Long <b>DMS_deleteDataN</b>(<i>ounitid, variateid</i>)
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td><b>Argument</b>
</td><td><b>Type</b>
</td><td><b>Use</b>
</td><td><b>Description</b>
</td></tr>
<tr>
<td>ounitid
</td><td>long
</td><td>Input
</td><td>The observation unit of the record to be deleted.
</td></tr>
<tr>
<td>variateid
</td><td>long
</td><td>Input
</td><td>The variateid of the record to be deleted
</td></tr>
</table>
<p><b>Returns</b>
</p><p>DMS_SUCCESS(1), DMS_ERROR(-1)
</p>
<a name="IMS_DLL_FUNCTIONS" id="IMS_DLL_FUNCTIONS"></a><h2> <span class="mw-headline">IMS DLL FUNCTIONS</span></h2>
<p>The IMS_openDatabase function should be called first before calling any function mentioned in this section.  The different data structures used by the functions are discussed in section 2.
</p>
<a name="ADD_Functions_2" id="ADD_Functions_2"></a><h3> <span class="mw-headline">ADD Functions</span></h3>
<a name="IMS_addLot" id="IMS_addLot"></a><h4> <span class="mw-headline">IMS_addLot</span></h4>
<p>IMS_addLot adds a new LOT record in the LOT table of the inventory database.  LOTID is automatically assigned by the function.  EID needs to exist already in the GERMPLSM table.  If it doesnt, the function returns IMS_INVALID_ID(-9).
</p><p><b>Syntax</b>
</p><p>Long <b>IMS_addLot(LOT)</b>
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="91%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>lotData</i>
</td><td align="justify">IMS_LOT
</td><td align="justify">Input
</td><td align="justify">Address of the IMS_LOT structure that contains the information to be added to the database.
</td></tr>
</table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS(1), IMS_INVALID_ID(-9), IMS_ERROR(-1)
</p>
<a name="IMS_addTransaction" id="IMS_addTransaction"></a><h4> <span class="mw-headline">IMS_addTransaction</span></h4>
<p>IMS_addTransaction adds a new transaction record in the Transactions table.  TRNID is automatically assigned by the function.  LOTID needs to exist in the LOT table.  If it doesnt, the function returns IMS_INVALID_ID (-9).
</p><p><b>Syntax</b>
</p><p>long <b>IMS_addTransaction('''</b><i>TRANSACTION'''</i><b>)</b>
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>transactionData</i>
</td><td align="justify">IMS_TRANSACTION
</td><td align="justify">Input
</td><td align="justify">Address of the IMS_TRANSACTION structure that contains the information to be added to the database.
</td></tr>
</table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS(1), IMS_INVALID_ID(-9), IMS_ERROR(-1)
</p>
<a name="DATA_RETRIEVAL_FUNCTIONS" id="DATA_RETRIEVAL_FUNCTIONS"></a><h3> <span class="mw-headline">DATA RETRIEVAL FUNCTIONS</span></h3>
<a name="IMS_findLotRecord" id="IMS_findLotRecord"></a><h4> <span class="mw-headline">IMS_findLotRecord</span></h4>
<p>IMS_findLotRecord retrieves data from the Lot table for a given
</p>
<ul><li> <i>Etype</i>
</li><li> <i>Or etype and eid</i>
</li><li> <i>Or etype and locid</i>
</li><li> <i>Or etype and eid or locid</i>
</li></ul>
<p>Values specified in the ETYPE, EID, and LOCID fields of the IMS_LOT structure.
</p><p>If no records match the given criteria, the function returns IMS_NO_DATA .
</p><p><b>Syntax</b>
</p><p>Long IMS_findLotRecord (<i> lotData, fOpt)</i>
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="91%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>lotData</i>
</td><td align="justify">IMS_LOT
</td><td align="justify">Input/Output
</td><td align="justify">Address of a IMS_Lot record<br />
</td></tr>
<tr>
<td align="justify"><i>fOpt</i>
</td><td align="justify">long
</td><td align="justify">Input
</td><td align="justify">Either FIND_FIRST or FIND_NEXT
</td></tr>
</table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS, IMS_ERROR, NO_DATA
</p>
<a name="IMS_findTransactionRecord" id="IMS_findTransactionRecord"></a><h4> <span class="mw-headline">IMS_findTransactionRecord</span></h4>
<p>IMS_findTransactionRecord retrieves transaction records from the Transaction Table for a specified LOTID value.
</p><p><b>Syntax</b>
</p><p>Long IMS_findTransactionRecord (<i>lotid, transactionData, fOpt</i>)
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="93%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>Lotid</i>
</td><td align="justify">long
</td><td align="justify">Input
</td><td align="justify">The TRNID to search<br />
</td></tr>
<tr>
<td align="justify"><i>transactionData</i>
</td><td align="justify">IMS_TRANSACTION
</td><td align="justify">Output
</td><td align="justify">Address of a IMS_Transaction record<br />
</td></tr>
<tr>
<td align="justify"><i>fOpt</i>
</td><td align="justify">long
</td><td align="justify">Input
</td><td align="justify">FIND_FIRST or FIND_NEXT
</td></tr>
</table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS, IMS_ERROR, NO_DATA
</p>
<a name="IMS_getTransactionReserve" id="IMS_getTransactionReserve"></a><h4> <span class="mw-headline">IMS_getTransactionReserve</span></h4>
<p>IMS_getTransactionReserve  retrieves all reserve transaction records from the Transaction Table. If the flagAll is not 1, then only transactions reserved by the current user are retrieved.
</p><p><b>Syntax</b>
</p><p>Long IMS_getTransactionReserve (<i>flagAll, transactionData,LotData,  fOpt</i>)
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="93%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>flagAll</i>
</td><td align="justify">long
</td><td align="justify">Input
</td><td align="justify">1 (all reserve) or 0  (only reserve done by the current user)<br />
</td></tr>
<tr>
<td align="justify"><i>transactionData</i>
</td><td align="justify">IMS_TRANSACTION
</td><td align="justify">Output
</td><td align="justify">Address of a IMS_Transaction record<br />
</td></tr>
<tr>
<td align="justify"><i>lotData</i>
</td><td align="justify">IMS_LOT
</td><td align="justify">Output
</td><td align="justify">Address of a IMS_Lot record<br />
</td></tr>
<tr>
<td align="justify"><i>fOpt</i>
</td><td align="justify">long
</td><td align="justify">input
</td><td align="justify">FIND_FIRST or FIND_NEXT
</td></tr>
</table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS, IMS_ERROR, NO_DATA
</p>
<a name="IMS_getTransactionDeposit" id="IMS_getTransactionDeposit"></a><h4> <span class="mw-headline">IMS_getTransactionDeposit</span></h4>
<p>IMS_getTransactionDeposit  retrieves all deposit transaction records from the Transaction Table. If the flagAll is not 1, then only transactions deposited by the current user are retrieved.
</p><p><b>Syntax</b>
</p><p>Long IMS_getTransactionDeposit (<i>flagAll, transactionData,LotData,  fOpt</i>)
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="93%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>flagAll</i>
</td><td align="justify">long
</td><td align="justify">Input
</td><td align="justify">1 (all deposit) or 0  (only deposit done by the current user)<br />
</td></tr>
<tr>
<td align="justify"><i>transactionData</i>
</td><td align="justify">IMS_TRANSACTION
</td><td align="justify">Output
</td><td align="justify">Address of a IMS_Transaction record<br />
</td></tr>
<tr>
<td align="justify"><i>lotData</i>
</td><td align="justify">IMS_LOT
</td><td align="justify">Output
</td><td align="justify">Address of a IMS_Lot record<br />
</td></tr>
<tr>
<td align="justify"><i>fOpt</i>
</td><td align="justify">long
</td><td align="justify">input
</td><td align="justify">FIND_FIRST or FIND_NEXT
</td></tr>
</table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS, IMS_ERROR, NO_DATA
</p><p><br />
</p>
<a name="IMS_getReserveByPerson" id="IMS_getReserveByPerson"></a><h4> <span class="mw-headline">IMS_getReserveByPerson</span></h4>
<p>IMS_getReserveByPerson  retrieves all reserve transaction made by a particular requestor. The PERSONID of the requestor is stored in the IMS_TRANSACTION data structure (transactionData).
</p><p><b>Syntax</b>
</p><p>Long IMS_getReserveByPerson (<i>transactionData, LotData,  fOpt</i>)
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="93%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>flagAll</i>
</td><td align="justify">long
</td><td align="justify">Input
</td><td align="justify">1 (all reserve) or 0  (only reserve done by the current user)<br />
</td></tr>
<tr>
<td align="justify"><i>transactionData</i>
</td><td align="justify">IMS_TRANSACTION
</td><td align="justify">Output
</td><td align="justify">Address of a IMS_Transaction record<br />
</td></tr>
<tr>
<td align="justify"><i>lotData</i>
</td><td align="justify">IMS_LOT
</td><td align="justify">Output
</td><td align="justify">Address of a IMS_Lot record<br />
</td></tr>
<tr>
<td align="justify"><i>fOpt</i>
</td><td align="justify">long
</td><td align="justify">input
</td><td align="justify">FIND_FIRST or FIND_NEXT
</td></tr>
</table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS, IMS_ERROR, NO_DATA
</p>
<a name="IMS_getDepositByPerson" id="IMS_getDepositByPerson"></a><h4> <span class="mw-headline">IMS_getDepositByPerson</span></h4>
<p>IMS_getDepositByPerson  retrieves all deposits done by a particular person. The PERSONID is stored in the IMS_TRANSACTION data structure (transactionData).
</p><p><b>Syntax</b>
</p><p>Long IMS_getDepositByPerson (<i>transactionData, LotData,  fOpt</i>)
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="93%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>flagAll</i>
</td><td align="justify">long
</td><td align="justify">Input
</td><td align="justify">1 (all reserve) or 0  (only reserve done by the current user)<br />
</td></tr>
<tr>
<td align="justify"><i>transactionData</i>
</td><td align="justify">IMS_TRANSACTION
</td><td align="justify">Output
</td><td align="justify">Address of a IMS_Transaction record<br />
</td></tr>
<tr>
<td align="justify"><i>lotData</i>
</td><td align="justify">IMS_LOT
</td><td align="justify">Output
</td><td align="justify">Address of a IMS_Lot record<br />
</td></tr>
<tr>
<td align="justify"><i>fOpt</i>
</td><td align="justify">long
</td><td align="justify">input
</td><td align="justify">FIND_FIRST or FIND_NEXT
</td></tr>
</table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS, IMS_ERROR, NO_DATA
</p><p><br />
</p>
<a name="IMS_getBalanceOfLot" id="IMS_getBalanceOfLot"></a><h4> <span class="mw-headline">IMS_getBalanceOfLot</span></h4>
<p>This function retrieves the total sum of the transaction quantities for a given lot. 
</p><p><b>Syntax</b>
</p><p>Long <b>IMS_reportBalance</b> (<i>lotid, sumTrans</i>)
</p>
<table border="2" cellspacing="0" cellpadding="4" width="93%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>lotid</i>
</td><td align="justify">Long
</td><td align="justify">input
</td><td align="justify">The lot
</td></tr>
<tr>
<td align="justify"><i>sumTrans</i>
</td><td align="justify">Double
</td><td align="justify">output
</td><td align="justify">The sum of the transaction quantities of the lot
</td></tr></table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS(1), IMS_ERROR(-1), IMS_NO_DATA(0)
</p>
<a name="UPDATE_FUNCTIONS" id="UPDATE_FUNCTIONS"></a><h3> <span class="mw-headline">UPDATE FUNCTIONS</span></h3>
<a name="IMS_setTransaction" id="IMS_setTransaction"></a><h4> <span class="mw-headline">IMS_setTransaction</span></h4>
<p>This function changes the value of any field in of the IMS_Transaction Table except LOTID and TRANSID given TRANSID. The status of the transaction can be updated by setting the TRNSTAT field to 1 (committed) or to 9 (cancelled) .
</p><p><b>Syntax</b>
</p><p>Long <b>IMS_setTransaction </b>(<i>transactionData</i>)
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>transactionData</i>
</td><td align="justify">IMS_TRANSACTION
</td><td align="justify">Input
</td><td align="justify">Address of the IMS_TRANSACTION data structure
</td></tr>
</table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS, IMS_ERROR
</p><p><br />
</p>
<a name="IMS_setLot" id="IMS_setLot"></a><h4> <span class="mw-headline">IMS_setLot</span></h4>
<p>This function changes the value of any field in of the IMS_LOT Table except LOTID which is the given parameter. 
</p><p><b>Syntax</b>
</p><p>Long <b>IMS_setLot </b>(<i>lotData</i>)
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>lotData</i>
</td><td align="justify">IMS_LOT
</td><td align="justify">Input
</td><td align="justify">Address of the IMS_LOT data structure
</td></tr>
</table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS, IMS_ERROR
</p><p><br />
</p>
<a name="REPORT_FUNCTIONS" id="REPORT_FUNCTIONS"></a><h3> <span class="mw-headline">REPORT FUNCTIONS</span></h3>
<a name="IMS_reportAllTransaction" id="IMS_reportAllTransaction"></a><h4> <span class="mw-headline">IMS_reportAllTransaction</span></h4>
<p>This function retrieves all uncommitted transactions which include commitment date and quantity of the transaction, location, scale and comment about its lot.
</p><p><b>Syntax</b>
</p><p>Long <b>IMS_reportAllTransaction</b> (<i>lotid, cmtdate, quantity, szLocName, szScale, szComment, fOpt</i>)
</p>
<table border="2" cellspacing="0" cellpadding="4" width="93%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>lotid</i>
</td><td align="justify">Long
</td><td align="justify">Output
</td><td align="justify">The lot of the transaction
</td></tr>
<tr>
<td align="justify"><i>cmtdate</i>
</td><td align="justify">Long
</td><td align="justify">output
</td><td align="justify">The commitment date of the transaction
</td></tr>
<tr>
<td align="justify"><i>quantity</i>
</td><td align="justify">Double
</td><td align="justify">output
</td><td align="justify">The quantity of the transaction
</td></tr>
<tr>
<td align="justify"><i>szLocName</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The location where the lot is stored
</td></tr>
<tr>
<td align="justify"><i>szScale</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The scale or measurement unit on how the lot is stored
</td></tr>
<tr>
<td align="justify"><i>szComment</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">Comment about the lot
</td></tr>
<tr>
<td align="justify"><i>fOpt</i>
</td><td align="justify">Long
</td><td align="justify">input
</td><td align="justify">0 (FIND_FIRST) to get the first record, 1 for succeeding records
</td></tr></table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS(1), IMS_ERROR(-1), IMS_NO_DATA(0)
</p><p><br />
</p>
<a name="IMS_reportMaterialDist" id="IMS_reportMaterialDist"></a><h4> <span class="mw-headline">IMS_reportMaterialDist</span></h4>
<p>This function reports on all requested reserve (uncommitted withdrawal). 
</p><p><b>Syntax</b>
</p><p>Long <b>IMS_reportMaterialDist</b> (<i>lotid, eid, quantity, szLocName, szScale, szComment, cmtdate, fOpt</i>)
</p>
<table border="2" cellspacing="0" cellpadding="4" width="93%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>lotid</i>
</td><td align="justify">Long
</td><td align="justify">Output
</td><td align="justify">The lot of the transaction
</td></tr>
<tr>
<td align="justify"><i>eid</i>
</td><td align="justify">Long
</td><td align="justify">Output
</td><td align="justify">The ID of the entity (e.g. GID) in the lot
</td></tr>
<tr>
<td align="justify"><i>quantity</i>
</td><td align="justify">Double
</td><td align="justify">output
</td><td align="justify">The quantity of the transaction
</td></tr>
<tr>
<td align="justify"><i>szLocName</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The location where the lot is stored
</td></tr>
<tr>
<td align="justify"><i>szScale</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The scale or measurement unit on how the lot is stored
</td></tr>
<tr>
<td align="justify"><i>szComment</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">Comment about the lot
</td></tr>
<tr>
<td align="justify"><i>cmtdate</i>
</td><td align="justify">Long
</td><td align="justify">output
</td><td align="justify">The commitment date of the transaction
</td></tr>
<tr>
<td align="justify"><i>fOpt</i>
</td><td align="justify">Long
</td><td align="justify">input
</td><td align="justify">0 (FIND_FIRST) to get the first record, 1 for succeeding records
</td></tr></table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS(1), IMS_ERROR(-1), IMS_NO_DATA(0)
</p>
<a name="IMS_reportByRequestor" id="IMS_reportByRequestor"></a><h4> <span class="mw-headline">IMS_reportByRequestor</span></h4>
<p>This function reports on all requested reserves and withdrawals including the persons who requested  for them. The first record is returned if fOpt = FIND_FIRST and the succeeding record is returned if fOpt = FIND_NEXT
</p><p><b>Syntax</b>
</p><p>Long <b>IMS_reportMaterialDist</b> (<i>lotid, eid, quantity, szLocName, szScale, szComment, cmtdate, lngStat, lngPerson, fOpt</i>)
</p>
<table border="2" cellspacing="0" cellpadding="4" width="93%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>lotid</i>
</td><td align="justify">Long
</td><td align="justify">Output
</td><td align="justify">The lot of the transaction
</td></tr>
<tr>
<td align="justify"><i>eid</i>
</td><td align="justify">Long
</td><td align="justify">Output
</td><td align="justify">The ID of the entity (e.g. GID) in the lot
</td></tr>
<tr>
<td align="justify"><i>quantity</i>
</td><td align="justify">Double
</td><td align="justify">output
</td><td align="justify">The quantity of the reserve or withdrawal
</td></tr>
<tr>
<td align="justify"><i>szLocName</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The location where the lot is stored
</td></tr>
<tr>
<td align="justify"><i>szScale</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The scale or measurement unit on how the lot is stored
</td></tr>
<tr>
<td align="justify"><i>szComment</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">Comment about the lot
</td></tr>
<tr>
<td align="justify"><i>cmtdate</i>
</td><td align="justify">Long
</td><td align="justify">output
</td><td align="justify">The commitment date of the transaction
</td></tr>
<tr>
<td align="justify"><i>lngPerson</i>
</td><td align="justify">Long
</td><td align="justify">output
</td><td align="justify">The person who reserved or withdrew the amount
</td></tr>
<tr>
<td align="justify"><i>fOpt</i>
</td><td align="justify">Long
</td><td align="justify">input
</td><td align="justify">0 (FIND_FIRST) to get the first record, 1 for succeeding records
</td></tr></table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS(1), IMS_ERROR(-1), IMS_NO_DATA(0)
</p>
<a name="IMS_reportBalance" id="IMS_reportBalance"></a><h4> <span class="mw-headline">IMS_reportBalance</span></h4>
<p>This function retrieves the sum of the transaction, location and scale of all lots. The first record is returned if fOpt = FIND_FIRST and the succeeding record is returned if fOpt = FIND_NEXT
</p><p><b>Syntax</b>
</p><p>Long <b>IMS_reportBalance</b> (<i>lotid, sumTrans, szLocName, szScale, fOpt</i>)
</p>
<table border="2" cellspacing="0" cellpadding="4" width="93%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>lotid</i>
</td><td align="justify">Long
</td><td align="justify">Output
</td><td align="justify">The lot of the transactions
</td></tr>
<tr>
<td align="justify"><i>sumTrans</i>
</td><td align="justify">Double
</td><td align="justify">output
</td><td align="justify">The sum of the quantity of the transactions
</td></tr>
<tr>
<td align="justify"><i>szLocName</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The location where the lot is stored
</td></tr>
<tr>
<td align="justify"><i>szScale</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The scale or measurement unit on how the lot is stored
</td></tr>
<tr>
<td align="justify"><i>fOpt</i>
</td><td align="justify">Long
</td><td align="justify">input
</td><td align="justify">0 (FIND_FIRST) to get the first record, 1 for succeeding records
</td></tr></table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS(1), IMS_ERROR(-1), IMS_NO_DATA(0)
</p>
<a name="IMS_reportEmptyShelves" id="IMS_reportEmptyShelves"></a><h4> <span class="mw-headline">IMS_reportEmptyShelves</span></h4>
<p>This function reports on the lot that have zero balance or the sum of committed transactions is zero. The first record is returned if fOpt = FIND_FIRST and the succeeding record is returned if fOpt = FIND_NEXT
</p><p><b>Syntax</b>
</p><p>Long <b>IMS_reportEmptyShelves</b> (<i>lotid, eid, szLocName, szScale, fOpt</i>)
</p>
<table border="2" cellspacing="0" cellpadding="4" width="93%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>lotid</i>
</td><td align="justify">Long
</td><td align="justify">Output
</td><td align="justify">The lot which has zero balance
</td></tr>
<tr>
<td align="justify"><i>eid</i>
</td><td align="justify">Long
</td><td align="justify">Input
</td><td align="justify">The identification (GID) of the entity asoociated with the lot
</td></tr>
<tr>
<td align="justify"><i>szLocName</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The location where the lot is originally stored
</td></tr>
<tr>
<td align="justify"><i>szScale</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The scale or measurement unit on how the lot is stored
</td></tr>
<tr>
<td align="justify"><i>fOpt</i>
</td><td align="justify">Long
</td><td align="justify">input
</td><td align="justify">0 (FIND_FIRST) to get the first record, 1 (FIND_NEXT) for succeeding records
</td></tr></table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS(1), IMS_ERROR(-1), IMS_NO_DATA(0)
</p><p><br />
</p>
<a name="IMS_reportDormantEntries" id="IMS_reportDormantEntries"></a><h4> <span class="mw-headline">IMS_reportDormantEntries</span></h4>
<p>This function reports on the lots with non-zero actual balance that are stored on or earlier than the specified year. The first record is returned if fOpt = FIND_FIRST and the succeeding record is returned if fOpt = FIND_NEXT
</p><p><b>Syntax</b>
</p><p>Long <b>IMS_reportDormantEntries</b> (<i>minYear, lotid, eid, quantity, szLocName, szScale, fOpt</i>)
</p>
<table border="2" cellspacing="0" cellpadding="4" width="93%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>minYear</i>
</td><td align="justify">Long
</td><td align="justify">Input
</td><td align="justify">The year used as basis for dormant entries
</td></tr>
<tr>
<td align="justify"><i>lotid</i>
</td><td align="justify">Long
</td><td align="justify">Input
</td><td align="justify">The lot considered as dormant
</td></tr>
<tr>
<td align="justify"><i>eid</i>
</td><td align="justify">Long
</td><td align="justify">Input
</td><td align="justify">The identification (GID) of the entity asoociated with the lot
</td></tr>
<tr>
<td align="justify"><i>quantity</i>
</td><td align="justify">Double
</td><td align="justify">Input
</td><td align="justify">The actual balance or sum of committed transactions
</td></tr>
<tr>
<td align="justify"><i>szLocName</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The location where the lot is stored
</td></tr>
<tr>
<td align="justify"><i>szScale</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The scale or measurement unit on how the lot is stored
</td></tr>
<tr>
<td align="justify"><i>fOpt</i>
</td><td align="justify">Long
</td><td align="justify">input
</td><td align="justify">0 (FIND_FIRST) to get the first record, 1 (FIND_NEXT) for succeeding records
</td></tr></table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS(1), IMS_ERROR(-1), IMS_NO_DATA(0)
</p>
<a name="IMS_reportMinimumAmount" id="IMS_reportMinimumAmount"></a><h4> <span class="mw-headline">IMS_reportMinimumAmount</span></h4>
<p>This function reports on the lots with actual balance (or sum of committed transactions) less than the given amount. The first record is returned if fOpt = FIND_FIRST and the succeeding record is returned if fOpt = FIND_NEXT
</p><p><b>Syntax</b>
</p><p>Long <b>IMS_reportMinimumAmount</b> (<i>minQty, lotid, eid, quantity, szLocName, szScale, fOpt</i>)
</p>
<table border="2" cellspacing="0" cellpadding="4" width="93%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>minQty</i>
</td><td align="justify">Long
</td><td align="justify">Input
</td><td align="justify">The amount used as basis
</td></tr>
<tr>
<td align="justify"><i>lotid</i>
</td><td align="justify">Long
</td><td align="justify">Input
</td><td align="justify">The lot where it is considered below the minimum balance
</td></tr>
<tr>
<td align="justify"><i>eid</i>
</td><td align="justify">Long
</td><td align="justify">Input
</td><td align="justify">The identification (GID) of the entity asoociated with the lot
</td></tr>
<tr>
<td align="justify"><i>quantity</i>
</td><td align="justify">Double
</td><td align="justify">Input
</td><td align="justify">The actual balance or sum of committed transactions
</td></tr>
<tr>
<td align="justify"><i>szLocName</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The location where the lot is stored
</td></tr>
<tr>
<td align="justify"><i>szScale</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The scale or measurement unit on how the lot is stored
</td></tr>
<tr>
<td align="justify"><i>fOpt</i>
</td><td align="justify">Long
</td><td align="justify">input
</td><td align="justify">0 (FIND_FIRST) to get the first record, 1 (FIND_NEXT) for succeeding records
</td></tr></table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS(1), IMS_ERROR(-1), IMS_NO_DATA(0)
</p>
<a name="IMS_reportLotByEntity" id="IMS_reportLotByEntity"></a><h4> <span class="mw-headline">IMS_reportLotByEntity</span></h4>
<p>This function retrieves the lot, scale, location and ids for a given type of Entity (e.g. GERMPLASM).
</p><p><b>Syntax</b>
</p><p>Long <b>IMS_reportLotByEntity</b> (<i>szType, lotid, eid, szLocName, szScale, szComment, fOpt</i>)
</p>
<table border="2" cellspacing="0" cellpadding="4" width="93%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>szType</i>
</td><td align="justify">Char *
</td><td align="justify">Input
</td><td align="justify">The type of Entity. Generally, it is "GERMPLASM".
</td></tr>
<tr>
<td align="justify"><i>lotid</i>
</td><td align="justify">Long
</td><td align="justify">Output
</td><td align="justify">The lotid of a particular instance of the given Entity
</td></tr>
<tr>
<td align="justify"><i>eid</i>
</td><td align="justify">Long
</td><td align="justify">Output
</td><td align="justify">The identification (GID) of a particular instance of the entity
</td></tr>
<tr>
<td align="justify"><i>szLocName</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The location where the lot is stored
</td></tr>
<tr>
<td align="justify"><i>szScale</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The scale or measurement unit on how the lot is stored
</td></tr>
<tr>
<td align="justify"><i>szComment</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">Comment about the lot
</td></tr>
<tr>
<td align="justify"><i>fOpt</i>
</td><td align="justify">Long
</td><td align="justify">input
</td><td align="justify">0 (FIND_FIRST) to get the first record, 1 for succeeding records
</td></tr></table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS(1), IMS_ERROR(-1), IMS_NO_DATA(0)
</p>
<a name="IMS_reportLotByEntityGIDFrom" id="IMS_reportLotByEntityGIDFrom"></a><h4> <span class="mw-headline">IMS_reportLotByEntityGIDFrom</span></h4>
<p>This function reports on the lot, scale, location for a given type of Entity (e.g. GERMPLASM) and its identification (e.g. GID). The first match is returned if fOpt = FIND_FIRST and the next matching record is returned if fOpt = FIND_NEXT
</p><p><b>Syntax</b>
</p><p>Long <b>IMS_reportLotByEntityGIDFrom</b> (<i>szType, lotid, eid, szLocName, szScale, szComment, fOpt</i>)
</p>
<table border="2" cellspacing="0" cellpadding="4" width="93%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>szType</i>
</td><td align="justify">Char *
</td><td align="justify">Input
</td><td align="justify">The type of Entity. Generally, it is "GERMPLASM".
</td></tr>
<tr>
<td align="justify"><i>lotid</i>
</td><td align="justify">Long
</td><td align="justify">Output
</td><td align="justify">The lotid of a particular instance of the given Entity
</td></tr>
<tr>
<td align="justify"><i>eid</i>
</td><td align="justify">Long
</td><td align="justify">Input
</td><td align="justify">The identification (GID) of the entity
</td></tr>
<tr>
<td align="justify"><i>szLocName</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The location where the lot is stored
</td></tr>
<tr>
<td align="justify"><i>szScale</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The scale or measurement unit on how the lot is stored
</td></tr>
<tr>
<td align="justify"><i>szComment</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">Comment about the lot
</td></tr>
<tr>
<td align="justify"><i>fOpt</i>
</td><td align="justify">Long
</td><td align="justify">input
</td><td align="justify">0 (FIND_FIRST) to get the first record, 1 (FIND_NEXT) for succeeding records
</td></tr></table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS(1), IMS_ERROR(-1), IMS_NO_DATA(0)
</p>
<a name="IMS_reportLotByEntityGIDRange" id="IMS_reportLotByEntityGIDRange"></a><h4> <span class="mw-headline">IMS_reportLotByEntityGIDRange</span></h4>
<p>This function reports on the lot, scale, location for a given type of Entity (e.g. GERMPLASM) and range of its IDs (e.g. GID). The first match is returned if fOpt = FIND_FIRST and the next matching record is returned if fOpt = FIND_NEXT
</p><p><b>Syntax</b>
</p><p>Long <b>IMS_reportLotByEntityGIDRange</b> (<i>szType, lotid, eidFrom, eidTo, szLocName, szScale, szComment, fOpt</i>)
</p>
<table border="2" cellspacing="0" cellpadding="4" width="93%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>szType</i>
</td><td align="justify">Char *
</td><td align="justify">Input
</td><td align="justify">The type of Entity. Generally, it is "GERMPLASM".
</td></tr>
<tr>
<td align="justify"><i>lotid</i>
</td><td align="justify">Long
</td><td align="justify">Output
</td><td align="justify">The lotid of a particular instance of the given Entity
</td></tr>
<tr>
<td align="justify"><i>eid</i>
</td><td align="justify">Long
</td><td align="justify">Input
</td><td align="justify">The identification (GID) of the entity
</td></tr>
<tr>
<td align="justify"><i>szLocName</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The location where the lot is stored
</td></tr>
<tr>
<td align="justify"><i>szScale</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">The scale or measurement unit on how the lot is stored
</td></tr>
<tr>
<td align="justify"><i>szComment</i>
</td><td align="justify">Char *
</td><td align="justify">output
</td><td align="justify">Comment about the lot
</td></tr>
<tr>
<td align="justify"><i>fOpt</i>
</td><td align="justify">Long
</td><td align="justify">input
</td><td align="justify">0 (FIND_FIRST) to get the first record, 1 (FIND_NEXT) for succeeding records
</td></tr></table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS(1), IMS_ERROR(-1), IMS_NO_DATA(0)
</p>
<a name="MISCELLANEOUS" id="MISCELLANEOUS"></a><h3> <span class="mw-headline">MISCELLANEOUS</span></h3>
<a name="IMS_closeLot" id="IMS_closeLot"></a><h4> <span class="mw-headline">IMS_closeLot</span></h4>
<p>This function changes the STATUS field of the Lot Table to 1  "Closed".  Lot records are not deleted from the table.
</p><p><b>Syntax</b>
</p><p>Long <b>IMS_closeLot</b> (<i>lotid</i>)
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="91%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>lotid</i>
</td><td align="justify">Long
</td><td align="justify">Input
</td><td align="justify">The lotid to close.
</td></tr>
</table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS, IMS_ERROR
</p><p><br />
</p>
<a name="IMS_calculateBalance" id="IMS_calculateBalance"></a><h4> <span class="mw-headline">IMS_calculateBalance</span></h4>
<p>IMS_calculateBalance gets all values from field TRNQTY of the Transaction Table, for a given LOTID, and adds up all the anticipated and committed values to get the available balance, and all the committed values to get the actual balance. Cancelled transactions are ignored
</p><p><b>Syntax</b>
</p><p>Long <b>IMS_calculateBalance</b>(<i>lotid, trnqty1, trnqty2</i>)
</p><p><b>Arguments</b>
</p>
<table border="2" cellspacing="0" cellpadding="4" width="91%">
<tr>
<td align="justify"><b>Argument</b>
</td><td align="justify"><b>Type</b>
</td><td align="justify"><b>Use</b>
</td><td align="justify"><b>Description</b>
</td></tr>
<tr>
<td align="justify"><i>Lotid</i>
</td><td align="justify">long
</td><td align="justify">input
</td><td align="justify">&nbsp;
</td></tr>
<tr>
<td align="justify"><i>Trnqty1</i>
</td><td align="justify">long
</td><td align="justify">Output
</td><td align="justify">The summation of the TRNQTY field values for anticipated and committed transactions
</td></tr>
<tr>
<td align="justify"><i>Trnqty2</i>
</td><td align="justify">long
</td><td align="justify">Output
</td><td align="justify">The summation of the TRNQTY field values for committed transactions only.
</td></tr>
</table>
<p><b>Returns</b>
</p><p>IMS_SUCCESS(1), IMS_ERROR(-1), IMS_NO_DATA (0)
</p>
<a name="LMS_DLL_FUNCTIONS" id="LMS_DLL_FUNCTIONS"></a><h2> <span class="mw-headline">LMS DLL FUNCTIONS</span></h2>
<p>The GMS_openDatabase function mentioned in Section IV.A.3 should be called first before calling any functions mentioned in this section.  The different data structures used by the functions are discussed in section 2.
</p>
<a name="GMS_findLocation" id="GMS_findLocation"></a><h4> <span class="mw-headline">GMS_findLocation</span></h4>
<p>GMS_findLocation searches the location table for the first location with name which matches the string in the PREFERRED_NAME field of the <i>Locn</i> argument when <i>fOpt</i>=FIND_FIRST. It searches for the next match if <i>fOpt</i> is FIND_NEXT. If the TYPE field of <i>Locn </i>is non zero, the search is restricted to locations with LOCATION TYPE which match its value. The search string may contain wild cards such as _ and&nbsp;%.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_findLocation</b>(<i>Locn, fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>Locn
</td><td>GMS Location Structure
</td><td>Input/ output
</td><td>Address of a GMS_Germplasm record
</td></tr>
<tr>
<td>fOpt
</td><td>long
</td><td>input
</td><td>Either FIND_FIRST or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<a name="GMS_getLocation" id="GMS_getLocation"></a><h4> <span class="mw-headline">GMS_getLocation</span></h4>
<p>GMS_getLocation will retrieve location information. The first argument of GMS_getLocation is a pointer to a GMS_Location structure (6.1.2f). If the LOCATION_ID is not zero when the function is called then it returns the details for the corresponding location ID.  If it is zero then the function returns details for the first location record if <i>fOpt </i>= FIND_FIRST or for the next available location record if <i>fOpt </i>= FIND_NEXT. Any call which fails to get location information returns GMS_NO_DATA.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_getLocation</b>(<i>location ,fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>location
</td><td>GMS_Location*
</td><td>input/output
</td><td>Address of a GMS_Location structure
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST  or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>If the function is called and there is a problem accessing the database, the function will return GMS_ERROR. Any call which fails to get location information returns GMS_NO_DATA.
</p>
<a name="GMS_getLocation2" id="GMS_getLocation2"></a><h4> <span class="mw-headline">GMS_getLocation2</span></h4>
<p>GMS_getLocation2 will retrieve location information for all locations matching specified criteria. The first argument of GMS_getLocation2 is a pointer to a GMS_Location structure (6.1.2f).  All elements of the structure must be set to valid values or zeros or blanks before calling the function with parameter fOpt=FIND_FIRST. This sets a search template restricting the search to records with fields matching the valid values. The first match is returned if <i>fOpt </i>= FIND_FIRST and the next matching location is returned if <i>fOpt </i>= FIND_NEXT
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_getLocation2</b>(<i>location ,fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>location
</td><td>GMS_Location*
</td><td>input/output
</td><td>Address of a GMS_Location structure
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST  or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The principle of using GMS_getLocation2 is similar to GMS_getAttribute2.  If the function is called and there is a problem accessing the database, the function will return GMS_ERROR. Any call which fails to get location information returns GMS_NO_DATA.
</p>
<a name="GMS_addLocation" id="GMS_addLocation"></a><h4> <span class="mw-headline">GMS_addLocation</span></h4>
<p>GMS_addLocation adds a new location to the local LOCATION table. Details of the location must be stored in appropriate elements of the <i>location</i> parameter (6.1.2f), and the LOCATION_ID element must be set to zero before the call to GMS_addLocation. The next available location number will be returned in the LOCATION_ID element
</p><p>New data is not committed to the local database until the function GMS_commitData (6.8.1) has been called, and uncommitted data can be deleted from the buffer with the GMS_rollbackData function (6.8.2)
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_addLocation</b>(<i>location</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>Location
</td><td>GMS_Location *
</td><td>input/output
</td><td>Address of a GMS_Location structure
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR , GMS_NO_ACCESS
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The following fields of the <i>location</i> structure (6.1.2f) must be properly populated with values before calling the function:
</p><p> LOCATION_ID  must be set to 0,
</p><p> PREFERRED_NAME must be set to a null terminated ASCII string,
</p><p>Other elements may be set if values are known. Otherwise they should be set to the defined nulls for each field
</p>
<a name="BIBREF_DLL_FUNCTIONS" id="BIBREF_DLL_FUNCTIONS"></a><h2> <span class="mw-headline">BIBREF DLL FUNCTIONS</span></h2>
<p>The GMS_openDatabase function mentioned in Section 3.1 should be called first before calling any functions mentioned in this section.  The different data structures used by the functions are discussed in section IV.A.2.
</p>
<a name="GMS_getBibrefs" id="GMS_getBibrefs"></a><h4> <span class="mw-headline">GMS_getBibrefs</span></h4>
<p>GMS_getBibrefs retrieves bibliographic reference information.  The first argument is a pointer to GMS_BIBREFS structure. If the referenece ID is not zero when the function is called then it returns the details for the corresponding reference ID.  If it is zero then the function returns details for the first bibliographic reference record if <i>fOpt </i>= FIND_FIRST or for the next available reference record if <i>fOpt </i>= FIND_NEXT. If no bibliographic information is found, the function  returns GMS_NO_DATA.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_getBibrefs</b>(<i>bibref ,fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>bibref
</td><td>GMS_BIBREFS*
</td><td>input/output
</td><td>Address of a GMS_BIBREFS structure
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST  or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<a name="GMS_addBibrefs" id="GMS_addBibrefs"></a><h4> <span class="mw-headline">GMS_addBibrefs</span></h4>
<p>GMS_addBibrefs adds a new record of bibliographic reference to the local BIBREFS table. Details of the bibliographic reference must be stored in appropriate elements of the <i>bibref</i> parameter, and the REFID element must be set to zero before the call to GMS_addBibrefs. The next available bibliographic reference number will be returned in the REFID element
</p><p>New data is not committed to the local database until the function GMS_commitData (see Section 3.1) has been called, and uncommitted data can be deleted from the buffer with the GMS_rollbackData function (see Section 3.1)
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GMS_addBibrefs</b>(<i>bibref</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>bibref
</td><td>GMS_BIBREFS*
</td><td>input/output
</td><td>Address of a GMS_BIBREFS structure
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR , GMS_NO_ACCESS
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The following fields of the <i>bibref</i> structure must be properly populated with values before calling the function:
</p><p> REFID  must be set to 0,
</p><p> All character fields must be null terminated ASCII string,
</p><p>Other elements may be set if values are known. Otherwise they should be set to the default values.
</p>
<a name="GEMS_DLL_FUNCTIONS" id="GEMS_DLL_FUNCTIONS"></a><h2> <span class="mw-headline">GEMS DLL FUNCTIONS</span></h2>
<p>The GEMS_openDatabase function mentioned in Section 3 should be called first before calling any functions mentioned in this section.  The different data structures used by the functions are discussed in section 2.
</p>
<a name="ADD_FUNCTIONS_3" id="ADD_FUNCTIONS_3"></a><h3> <span class="mw-headline"> ADD FUNCTIONS </span></h3>
<a name="GEMS_addGEMSName" id="GEMS_addGEMSName"></a><h4> <span class="mw-headline">GEMS_addGEMSName</span></h4>
<p>(GEMS_NAME *recName)
GEMS_addGEMSName adds a new record of names for GEMS entities to the local GEMS_NAMES table. Details of the names must be stored in appropriate elements of the <i>recName</i> parameter, and the GNID element must be set to zero before the call to GMS_addGEMSName. The next available name ID will be returned in the GNID element.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_addGEMSName</b>(<i>recName</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>recName
</td><td>GEMS_NAME*
</td><td>input/output
</td><td>Address of a GEMS_NAME structure
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR , GMS_NO_ACCESS
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The following fields of the <i>recName</i> structure must be properly populated with values before calling the function:
</p><p> GNID  must be set to 0,
</p><p> All character fields must be null terminated ASCII string
</p><p> Other elements may be set if values are known. Otherwise they should be set to the default values.
</p><p><br />
</p>
<a name="GEMS_addComponent" id="GEMS_addComponent"></a><h4> <span class="mw-headline">GEMS_addComponent</span></h4>
<p>GEMS_addComponent adds a new record of component of a polymorphic detector to the GEMS_COMP table. Details of the component must be stored in appropriate elements of the <i>data</i> parameter, and the CID element must be set to zero before the call to GMS_addComponent. The next available component ID will be returned in the CID element.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_addComponent</b>(<i>data</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>data
</td><td>GEMS_COMPONENT*
</td><td>input/output
</td><td>Address of a GEMS_COMPONENT structure
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR , GMS_NO_ACCESS
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The following fields of the <i>data</i> structure must be properly populated with values before calling the function:
</p><p> CID  must be set to 0,
</p><p> All character fields must be null terminated ASCII string
</p><p> Other elements may be set if values are known. Otherwise they should be set to the default values.
</p><p><br />
</p>
<a name="GEMS_addMD" id="GEMS_addMD"></a><h4> <span class="mw-headline">GEMS_addMD</span></h4>
<p>GEMS_addMD adds a record in GEMS_MARKER_DETECTOR table. Details of the marker detector must be stored in appropriate elements of the <i>data</i> parameter, and the MDID element must be set to zero before the call to GMS_addMD. The next available component ID will be returned in the MDID element.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_addMD</b>(<i>data</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>data
</td><td>GEMS_MARKER_DETECTOR*
</td><td>input/output
</td><td>Address of a GEMS_MARKER_DETECTOR structure
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR , GMS_NO_ACCESS
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The following fields of the <i>data</i> structure must be properly populated with values before calling the function:
</p><p> MDID  must be set to 0,
</p><p> All character fields must be null terminated ASCII string
</p><p> Other elements may be set if values are known. Otherwise they should be set to the default values.
</p><p><br />
</p>
<a name="GEMS_addMV" id="GEMS_addMV"></a><h4> <span class="mw-headline">GEMS_addMV</span></h4>
<p>GEMS_addMV adds a record of information on molecular variant names in GEMS_MV table. Details of the molecular variant must be stored in appropriate elements of the <i>data</i> parameter, and the MVID element must be set to zero before the call to GEMS_addMV. The next available ID will be returned in the MVID element.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_addMV</b>(<i>data</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>data
</td><td>GEMS_MV*
</td><td>input/output
</td><td>Address of a GEMS_MV structure
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR , GMS_NO_ACCESS
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The following fields of the <i>data</i> structure must be properly populated with values before calling the function:
</p><p> MVID  must be set to 0,
</p><p> All character fields must be null terminated ASCII string
</p><p> Other elements may be set if values are known. Otherwise they should be set to the default values.
</p><p><br />
</p>
<a name="GEMS_addLocus" id="GEMS_addLocus"></a><h4> <span class="mw-headline">GEMS_addLocus</span></h4>
<p>GEMS_addLocus adds a record in GEMS_LOCUS table. GEMS_LOCUS table contains information on chromosome and location of a molecular variant. Details of the locus must be stored in appropriate elements of the <i>data</i> parameter, and the LOCUSID element must be set to zero before the call to GEMS_LOCUS. The next available ID will be returned in the LOCUSID element.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_addLocus</b>(<i>data</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>data
</td><td>GEMS_LOCUS*
</td><td>input/output
</td><td>Address of a GEMS_LOCUS structure
</td></tr></table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR , GMS_NO_ACCESS
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The following fields of the <i>data</i> structure must be properly populated with values before calling the function:
</p><p> LOCUSID  must be set to 0,
</p><p> All character fields must be null terminated ASCII string
</p><p> Other elements may be set if values are known. Otherwise they should be set to the default values.
</p>
<a name="GEMS_addPD" id="GEMS_addPD"></a><h4> <span class="mw-headline">GEMS_addPD</span></h4>
<p>GEMS_addPD adds a record in GEMS_PD table. The PD table the different combination of Marker Detector ID(MDID) and condition ID (condid). Details of this relationship must be stored in appropriate elements of the <i>data</i> parameter, and the PDID element must be set to zero before the call to GMS_addPD. The next available ID will be returned in the PDID element.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_addPD</b>(<i>data</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>data
</td><td>GEMS_PD*
</td><td>input/output
</td><td>Address of a GEMS_PD structure
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR , GMS_NO_ACCESS
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The following fields of the <i>data</i> structure must be properly populated with values before calling the function:
</p><p> PDID  must be set to 0,
</p><p> All character fields must be null terminated ASCII string
</p><p> Other elements may be set if values are known. Otherwise they should be set to the default values.
</p>
<a name="GEMS_addPdComp" id="GEMS_addPdComp"></a><h4> <span class="mw-headline">GEMS_addPdComp</span></h4>
<p>GEMS_addPdComp adds a record in GEMS_PD_COMP table. The GEMS_PD_COMP (Polymorphic Detector and Components) table serves as the intermediate table to break the many-to-many relationship between the protocols/conditions and marker detector.  Details of this relationship must be stored in appropriate elements of the <i>data</i> parameter, and the PD_COMP element must be set to zero before the call to GMS_addPdComp. The next available ID will be returned in the PD_COMP element.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_addPdComp</b>(<i>data</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>data
</td><td>GEMS_PD_COMP*
</td><td>input/output
</td><td>Address of a GEMS_PD_COMP structure
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR , GMS_NO_ACCESS
</p>
<a name="GEMS_addProp" id="GEMS_addProp"></a><h4> <span class="mw-headline">GEMS_addProp</span></h4>
<p>GEMS_addProp adds a record in GEMS_PROPERTY table. This table defines the property, method and scale used by each component in the GEMS_COMP table. These information must be stored in appropriate elements of the <i>data</i> parameter.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_addProp</b>(<i>data</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>data
</td><td>GEMS_PROP*
</td><td>input/output
</td><td>Address of a GEMS_PROP structure
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR , GMS_NO_ACCESS
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The following fields of the <i>data</i> structure must be properly populated with values before calling the function:
</p><p> All character fields must be null terminated ASCII string
</p><p> Other elements may be set if values are known. Otherwise they should be set to the default values.
</p>
<a name="GEMS_addScale" id="GEMS_addScale"></a><h4> <span class="mw-headline">GEMS_addScale</span></h4>
<p>GEMS_addScale adds a record in GEMS_SCALE table. Details of the scale are stored in the appropriate elements of the <i>data</i> parameter.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_addScale</b>(<i>data</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>data
</td><td>GEMS_SCALE*
</td><td>input/output
</td><td>Address of a GEMS_SCALE structure
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR , GMS_NO_ACCESS
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The following fields of the <i>data</i> structure must be properly populated with values before calling the function:
</p><p> All character fields must be null terminated ASCII string
</p><p> Other elements may be set if values are known. Otherwise they should be set to the default values.
</p>
<a name="GEMS_addMethod" id="GEMS_addMethod"></a><h4> <span class="mw-headline">GEMS_addMethod</span></h4>
<p>GEMS_addMethod adds a record in GEMS_METHOD table. Details of the method are stored in the appropriate elements of the <i>data</i> parameter.
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_addMethod</b>(<i>data</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>data
</td><td>GEMS_METHOD*
</td><td>input/output
</td><td>Address of a GEMS_METHOD structure
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR , GMS_NO_ACCESS
</p>
<dl><dd><b>Comments</b>
</dd></dl>
<p>The following fields of the <i>data</i> structure must be properly populated with values before calling the function:
</p><p> All character fields must be null terminated ASCII string
</p><p> Other elements may be set if values are known. Otherwise they should be set to the default values.
</p>
<a name="GET_FUNCTIONS" id="GET_FUNCTIONS"></a><h3> <span class="mw-headline"> GET FUNCTIONS </span></h3>
<a name="GEMS_getGemsMID" id="GEMS_getGemsMID"></a><h4> <span class="mw-headline">GEMS_getGemsMID</span></h4>
<p>GMS_getGemsMID retrieves the corresponding GEMS MID based on the marker name &amp; object type .  The function returns details of the first matched record if <i>fOpt </i>= FIND_FIRST or of the succeeding matched record if <i>fOpt </i>= FIND_NEXT. 
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_getGemsMID</b>(<i>gemsInfo ,fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>gemsInfo
</td><td>GEMS_INFO*
</td><td>input/output
</td><td>Address of a GMS_INFO structure
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST  or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<a name="GEMS_getGemsMVID" id="GEMS_getGemsMVID"></a><h4> <span class="mw-headline"> GEMS_getGemsMVID </span></h4>
<p>GEMS_getGemsMVID retrieves the corresponding GEMS MVID based on the allele name, object type, &amp; marker ID. The function returns details of the first matched record if <i>fOpt </i>= FIND_FIRST or of the succeeding matched record if <i>fOpt </i>= FIND_NEXT. 
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_getGemsMVID</b>(<i>gemsInfo ,fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>gemsInfo
</td><td>GEMS_INFO*
</td><td>input/output
</td><td>Address of a GMS_INFO structure
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>Input
</td><td>Either FIND_FIRST  or FIND_NEXT
</td></tr>
</table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<a name="GEMS_getNameID" id="GEMS_getNameID"></a><h4> <span class="mw-headline"> GEMS_getNameID </span></h4>
<p>GEMS_getNameID gets the corresponding GOBJID from GEMS_NAMES table based on the given GOBJTYPE and GNVAL. The function returns the retrieved ID in the GOBJID element of the <i>data</i> parameter. 
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_getNameID</b>(<i>data</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>data
</td><td>GEMS_INFO*
</td><td>input/output
</td><td>Address of a GMS_INFO structure
</td></tr></table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p><p><br />
</p>
<a name="GEMS_getProtocolID" id="GEMS_getProtocolID"></a><h4> <span class="mw-headline"> GEMS_getProtocolID </span></h4>
<p>GEMS_getProtocolID gets the corresponding GOBJID from GEMS_NAMES table where GOBJTYPE= PROTOCOL and on the given GNVAL. The function returns the retrieved ID in the GOBJID element of the <i>data</i> parameter. 
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_getProtocolID</b>(<i>data, fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>data
</td><td>GEMS_INFO*
</td><td>input/output
</td><td>Address of a GMS_INFO structure
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>input
</td><td>FIND_FIRST = 0 or FIND_NEXT = 1
</td></tr></table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p><p><br />
</p>
<a name="GEMS_getPdComp" id="GEMS_getPdComp"></a><h4> <span class="mw-headline"> GEMS_getPdComp </span></h4>
<p>GEMS_getPdComp add all cids in gems_comp where condition is equal to <i>Condition</i>  of the <i>pdCompInfo</i> parameter. All cids found will be added to GEMS_PD_COMP table with pd_comp equal to the next available id.
</p><p><b>Syntax</b>
long <b>GEMS_getPdComp</b>(<i>pdCompInfo, fOpt</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>pdCompInfo
</td><td>GEMS_PD_COMP*
</td><td>input/output
</td><td>Address of a GMS_PD_COMP structure
</td></tr>
<tr>
<td>fOpt
</td><td>Long
</td><td>input
</td><td>FIND_FIRST = 0 or FIND_NEXT = 1
</td></tr></table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<a name="GEMS_findPID" id="GEMS_findPID"></a><h4> <span class="mw-headline"> GEMS_findPID </span></h4>
<p>GEMS_findPID gets the corresponding PID from GEMS_PROP table given the property, scale, method and property group. The function returns the retrieved ID in the PID element of the <i>data</i> parameter. 
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_findPID</b>(<i>data</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>data
</td><td>PROP_INFO*
</td><td>input/output
</td><td>Address of a PROP_INFO structure
</td></tr></table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p><p><br />
</p>
<a name="GEMS_findPdid" id="GEMS_findPdid"></a><h4> <span class="mw-headline"> GEMS_findPdid </span></h4>
<p>gems_pd.condid =&nbsp;? AND gems_pd.mdid =
GEMS_findPdid gets the corresponding PDID from GEMS_PD table given CONDID and MDID. The function returns the retrieved ID in the PDID element of the <i>data</i> parameter. 
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_findPdid</b>(<i>data</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>data
</td><td>GEMS_PD*
</td><td>input/output
</td><td>Address of a GEMS_PD structure
</td></tr></table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<a name="GEMS_findPropID" id="GEMS_findPropID"></a><h4> <span class="mw-headline"> GEMS_findPropID </span></h4>
<p>GEMS_findPID gets the corresponding PID and PROPID from GEMS_PROP table given the property name and property group. The function returns the retrieved IDs in the appropriate elements of the <i>data</i> parameter. 
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_findPID</b>(<i>data</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>data
</td><td>GEMS_PROP*
</td><td>input/output
</td><td>Address of a GEMS_PROP structure
</td></tr></table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<a name="GEMS_findScale" id="GEMS_findScale"></a><h4> <span class="mw-headline"> GEMS_findScale </span></h4>
<p>GEMS_findScale gets the corresponding SCALEID from GEMS_SCALE table given the scale name and property  id. The specified information should be stored in the appropriate elements of the <i>data</i> parameter. The function returns the retrieved ID in the SCALEID element of the parameter. 
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_findScale</b>(<i>data</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>data
</td><td>GEMS_SCALE*
</td><td>input/output
</td><td>Address of a GEMS_SCALE structure
</td></tr></table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p><p><br />
</p>
<a name="GEMS_findMethod" id="GEMS_findMethod"></a><h4> <span class="mw-headline"> GEMS_findMethod </span></h4>
<p>GEMS_findMethod retrieves a record of the method from GEMS_METHOD table given the name. Details of the information are stored in the appropriate elements of the <i>data</i> parameter. 
</p>
<dl><dd><b>Syntax</b>
</dd></dl>
<p>long <b>GEMS_findMethod</b>(<i>data</i>)
</p>
<dl><dd><b>Arguments</b>
</dd></dl>
<table border="2" cellspacing="0" cellpadding="4" width="100%">
<tr>
<td align="center"><b>Argument</b>
</td><td align="center"><b>Type</b>
</td><td align="center"><b>Use</b>
</td><td align="center"><b>Description</b>
</td></tr>
<tr>
<td>data
</td><td>GEMS_METHOD*
</td><td>input/output
</td><td>Address of a GEMS_METHOD structure
</td></tr></table>
<dl><dd><b>Returns</b>
</dd></dl>
<p>GMS_SUCCESS, GMS_ERROR, GMS_NO_DATA
</p>
<!-- 
NewPP limit report
Preprocessor node count: 1373/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->
<div class="printfooter">
Retrieved from "<a href="http://localhost../../../../articles/t/d/m/TDM_Windows_Application_Programming_Interface_5.4_258d.html">http://localhost../../../../articles/t/d/m/TDM_Windows_Application_Programming_Interface_5.4_258d.html</a>"</div>
			<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="../../../../articles/c/a/t/Special%7ECategories_101d.html" title="Special:Categories">Category</a>:&#32;<span dir='ltr'><a href="../../../../articles/w/o/r/Category%7EWord2MediaWikiPlus_a5c7.html" class="new" title="Category:Word2MediaWikiPlus (page does not exist)">Word2MediaWikiPlus</a></span></div></div>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="../../../../articles/t/d/m/TDM_Windows_Application_Programming_Interface_5.4_258d.html" title="View the content page [c]" accesskey="c">Page</a></li>
				 <li id="ca-talk" class="new"><a href="../../../../articles/t/d/m/Talk%7ETDM_Windows_Application_Programming_Interface_5.4_30f2.html" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-viewsource"><a href="../../../../articles/t/d/m/TDM_Windows_Application_Programming_Interface_5.4_258d.html" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></li>
				 <li id="ca-history"><a href="../../../../articles/t/d/m/TDM_Windows_Application_Programming_Interface_5.4_258d.html" title="Past versions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="../../../../articles/u/s/e/Special%7EUserLogin_94cd.html" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(../../../../misc/icis-wiki3.png);" href="../../../../index.html" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage"><a href="../../../../index.html" title="Visit the main page [z]" accesskey="z">Main Page</a></li>
				<li id="n-portal"><a href="../../../../articles/c/o/m/ICISWiki%7ECommunity_Portal_7449.html" title="About the project, what you can do, where to find things">Community portal</a></li>
				<li id="n-recentchanges"><a href="../../../../articles/r/e/c/Special%7ERecentChanges_e0d0.html" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-help"><a href="../../../../articles/c/o/n/Help%7EContents_22de.html" title="The place to find out">Help</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="../../../../articles/s/e/a/Special%7ESearch_a8e5.html" id="searchform"><div>
				<input id="searchInput" name="search" type="text" title="Search ICISWiki [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search the pages for this text" />
			</div></form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="../../../../articles/w/h/a/Special%7EWhatLinksHere_TDM_Windows_Application_Programming_Interface_5.4_1692.html" title="List of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="../../../../articles/r/e/c/Special%7ERecentChangesLinked_TDM_Windows_Application_Programming_Interface_5.4_3ab6.html" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-specialpages"><a href="../../../../articles/s/p/e/Special%7ESpecialPages_f12b.html" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="../../../../articles/t/d/m/TDM_Windows_Application_Programming_Interface_5.4_258d.html" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="../../../../articles/t/d/m/TDM_Windows_Application_Programming_Interface_5.4_258d.html" title="Permanent link to this version of the page">Permanent link</a></li>			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="../../../../skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
				<div id="f-copyrightico"><a href="../../../../../COPYING.html"><img src="/icis/skins/common/images/gnu-fdl.png" alt='GNU Free Documentation License 1.2' /></a></div>
			<ul id="f-list">
					<li id="credits">This page was last modified 09:00, 19 May 2008 by <a href="../../../../articles/a/p/o/User%7EAportugal_745d.html" title="User:Aportugal">Arllet Portugal</a>. Based on work by <a href="../../../../articles/g/m/c/User%7EGmclaren_b845.html" title="User:Gmclaren">Graham McLaren</a>.</li>
					<li id="copyright">Content is available under <a href="../../../../../COPYING.html" class="external " title="../../../../../COPYING.html">GNU Free Documentation License 1.2</a>.</li>
					<li id="privacy"><a href="../../../../articles/p/r/i/ICISWiki%7EPrivacy_policy_0cbf.html" title="ICISWiki:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="../../../../articles/a/b/o/ICISWiki%7EAbout_53aa.html" title="ICISWiki:About">About ICISWiki</a></li>
					<li id="disclaimer"><a href="../../../../articles/g/e/n/ICISWiki%7EGeneral_disclaimer_9129.html" title="ICISWiki:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served in 140.494 secs. --></body></html>
